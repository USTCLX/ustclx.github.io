<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>herrycodelee blog</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-10-24T03:40:44.659Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Xiang Li</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>整理英语学习资源</title>
    <link href="http://yoursite.com/2021/10/23/%E6%95%B4%E7%90%86%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    <id>http://yoursite.com/2021/10/23/%E6%95%B4%E7%90%86%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/</id>
    <published>2021-10-23T04:20:18.000Z</published>
    <updated>2021-10-24T03:40:44.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="资源整理"><a href="#资源整理" class="headerlink" title="资源整理"></a>资源整理</h2><p>目前收集了很多的英语学习资源，在国内的时候更多的是单纯的学习，而来到新加坡后有了很多的实战场景，除了日常的积累外，还是需要一些系统性的学些 lah！🤪</p><ul><li>方法论<ul><li><a href="https://github.com/byoungd/English-level-up-tips-for-Chinese" target="_blank" rel="noopener">English leval up tips for chinese</a></li></ul></li><li>APP<ul><li><a href="">开言英语</a></li><li><a href="">英语流利说</a></li></ul></li><li>视频<ul><li><a href="https://www.bilibili.com/video/BV1wM4y137kP" target="_blank" rel="noopener">五分钟英语基础语法</a></li><li><a href="https://www.bilibili.com/video/BV1aM4y1g7mj" target="_blank" rel="noopener">外教 Gill 英语精品课</a></li><li><a href="https://www.bilibili.com/video/BV1cM4y1V7t1" target="_blank" rel="noopener">说一口流利标准英语</a></li><li><a href="https://bilibili.com/video/BV1zy4y1b7jZ" target="_blank" rel="noopener">English with Lucy</a></li></ul></li><li>B 站 UP 主<ul><li><a href="https://space.bilibili.com/454755309" target="_blank" rel="noopener">Youtobe 口语精选</a></li><li><a href="https://space.bilibili.com/483301783" target="_blank" rel="noopener">Youtobe 英语精选</a></li><li><a href="https://space.bilibili.com/6926237/" target="_blank" rel="noopener">Youtobe 听力精选</a></li><li><a href="https://space.bilibili.com/1589382178" target="_blank" rel="noopener">Bigshot 英语</a></li></ul></li><li>Youtobe<ul><li><a href="https://www.youtube.com/c/EnglishwithLucy/featured" target="_blank" rel="noopener">English with Lucy</a></li><li><a href="https://www.youtube.com/user/theteachervanessa" target="_blank" rel="noopener">Speak English With Vanessa</a></li></ul></li><li>公众号<ul><li><a href="">英语资源学习中心</a></li></ul></li><li>Podcast<ul><li><a href="">潘吉 JENNY 告诉你</a></li><li><a href="">ALL EARS ENGLISH</a></li><li><a href="">英文小酒馆 LHH</a></li><li><a href="">一席英语</a></li><li><a href="">6 Minute English</a></li></ul></li></ul><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>某次偶然的机会听到了<code>潘吉 JENNY 告诉你</code>这款播客，感觉这种中英对话聊天的形式很有意思，每期一个话题，除了学习英语，还可以知道一些有趣的事情。<br>继而开始使用他们公司开发的<code>开言英语</code>App，使用了外交视频课，感觉还不错，根据具体的场景来学习英语。</p><p>其他资源自然是屯起来才有安全感 lah！还都没开始看 🤪。</p><p>播客打算额外选择一个<code>一席英语</code>，再从视频里选择<code>说一口流利标准英语</code>把它办了 💪！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;资源整理&quot;&gt;&lt;a href=&quot;#资源整理&quot; class=&quot;headerlink&quot; title=&quot;资源整理&quot;&gt;&lt;/a&gt;资源整理&lt;/h2&gt;&lt;p&gt;目前收集了很多的英语学习资源，在国内的时候更多的是单纯的学习，而来到新加坡后有了很多的实战场景，除了日常的积累外，还是需要一</summary>
      
    
    
    
    
    <category term="英语学习" scheme="http://yoursite.com/tags/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>算法资源整理</title>
    <link href="http://yoursite.com/2021/10/20/%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%E8%B5%84%E6%BA%90/"/>
    <id>http://yoursite.com/2021/10/20/%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%E8%B5%84%E6%BA%90/</id>
    <published>2021-10-20T11:18:43.000Z</published>
    <updated>2021-10-24T03:40:44.659Z</updated>
    
    <content type="html"><![CDATA[<p>最近打算再一次系统的学习数据结构与算法，并再次开始有节奏的刷 leetcode。功在平时，有备无患，在还没有熟练掌握之前，学习数据结构与算法和刷题必然是一个长期的过程。</p><h2 id="资源整理"><a href="#资源整理" class="headerlink" title="资源整理"></a>资源整理</h2><p>目前手头上掌握的资源挺多，可真正耐下心看完的没有几个。很多都是看到之后，随手就丢进了收藏夹里吃灰（众所周知，收藏就等于学会了 🤪）。</p><ul><li>在线书籍<ul><li><a href="https://labuladong.github.io/algo" target="_blank" rel="noopener">labuladong 算法小抄</a></li><li><a href="https://www.pzijun.cn/algorithms" target="_blank" rel="noopener">瓶子君的算法小书</a></li><li><a href="https://github.com/chefyuan/algorithm-base" target="_blank" rel="noopener">程序厨的动画算法</a></li><li><a href="https://books.halfrost.com/leetcode" target="_blank" rel="noopener">leetcode cookbook</a></li></ul></li><li>极客时间<ul><li><a href="https://time.geekbang.org/course/detail/100019701-67635" target="_blank" rel="noopener">算法面试通过 40 讲</a></li><li><a href="https://time.geekbang.org/column/article/76207" target="_blank" rel="noopener">数据结构与算法之美</a></li><li><a href="https://time.geekbang.org/opencourse/intro/100057601" target="_blank" rel="noopener">常用算法 25 讲</a></li></ul></li><li>视频<ul><li><a href="">百度云-算法训练营</a></li><li><a href="https://space.bilibili.com/525438321/video" target="_blank" rel="noopener">代码随想录</a></li><li><a href="https://www.bilibili.com/video/BV1E741157bP" target="_blank" rel="noopener">清华大学数据结构精品课-邓俊辉</a></li><li><a href="https://www.bilibili.com/video/BV1m54y1t7F7/" target="_blank" rel="noopener">左程云 LeetCode 刷题笔记</a></li></ul></li><li>github<ul><li><a href="https://github.com/yuanguangxin/LeetCode" target="_blank" rel="noopener">LeetCode 题目分类与面试问题整理</a></li><li><a href="https://github.com/labuladong/fucking-algorithm" target="_blank" rel="noopener">Fucking Algorithm(同 labuladong 算法小抄)</a></li><li><a href="https://github.com/dongxiaohuang/leetcode_solutions" target="_blank" rel="noopener">LeetCode Classify</a></li><li><a href="https://github.com/imarvinle/awesome-cs-books" target="_blank" rel="noopener">Awesome CS Books</a></li><li><a href="https://github.com/jwasham/coding-interview-university" target="_blank" rel="noopener">Coding Interview University</a></li><li><a href="https://github.com/MisterBooo/LeetCodeAnimation" target="_blank" rel="noopener">LeetCode Animation</a></li><li><a href="https://github.com/doocs/leetcode" target="_blank" rel="noopener">LeetCode 全解</a></li></ul></li><li>书籍<ul><li><a href="">剑指 offer</a></li><li><a href="">编程之美</a></li></ul></li></ul><h2 id="挑选"><a href="#挑选" class="headerlink" title="挑选"></a>挑选</h2><p>资料整理了好多，但是之前没有系统的钻研过。除了面试前看的《算法面试通关 40 讲》和《数据结构与算法之美》,前者属于视频类，后者属于小册类。</p><p>资料太多，不可能一次全部搞完，没有计划，很容易他们就集体吃灰了，还是需要逐个击破。这次决定从众多资料中，挑出两个，一个文字阅读类，一个视频类，互为补充的来学习。</p><ul><li>labuladong 算法小抄</li><li>百度云-算法训练营</li></ul><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>从 labuladong 算法小抄中，从头到尾，按照专题，每两天做一道题目，如果遇到简单的做过的，就顺势做到下一题。遇到复杂的概念和困难的题目，可以结合算法训练营视频来消化。</p><p>2021/10/20 星期三</p><h2 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h2><p>这里等待反馈，如果 labuladong 算法小抄过了一遍，再来这篇 blog 记录下成功的时间。</p><p>未完待续。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近打算再一次系统的学习数据结构与算法，并再次开始有节奏的刷 leetcode。功在平时，有备无患，在还没有熟练掌握之前，学习数据结构与算法和刷题必然是一个长期的过程。&lt;/p&gt;&lt;h2 id=&quot;资源整理&quot;&gt;&lt;a href=&quot;#资源整理&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="算法与数据结构" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Mac 安装和启动MySQL数据库</title>
    <link href="http://yoursite.com/2021/10/19/Mac-%E5%AE%89%E8%A3%85%E5%92%8C%E5%90%AF%E5%8A%A8MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2021/10/19/Mac-%E5%AE%89%E8%A3%85%E5%92%8C%E5%90%AF%E5%8A%A8MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2021-10-19T11:05:29.000Z</published>
    <updated>2021-10-24T03:40:44.651Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习 NestJS 框架，需要使用 MySQL 数据库来配合完成一些功能，以前只使用过 MongoDB，第一次使用 MySQL，在安装和使用时踩了一些坑，记录下来。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>MySQL 分为商业版和社区版，社区版我理解就是开源免费的。但是在官网想要找到下载入口比较费劲，个人感觉不是清晰。下载社区版可以直接使用下面这个链接。<br><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">MySQL Community Download</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载完成后，直接双击 dmg 文件进行安装。安装过程中需要输入输入 root 的密码，这里需要记下来。后面链接数据库的时候需要使用。</p><p><img src="/images/mysql_install.png" alt="mysql_install"></p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>为了启动 MySQL 我走了不少弯路，一开始使用命令行来启动，结果很麻烦，也没有成功启动。后来发现其实 MySQL 很人性化，它会在 System Perference 里面生成一个图标，点击图标后就可进行一些基本操作，包括</p><ul><li>start</li><li>stop</li><li>initialize</li></ul><p><img src="/images/mysql_perference_1.png" alt="mysql_perference_1"><br><img src="/images/mysql_perference_2.png" alt="mysql_perference_2"></p><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>建议直接使用图形化界面来操作，使用命令行太麻烦了。图形化界面有两个选择一个是收费的<code>Navicat</code>，一个是开源免费的<code>Sequel Pro</code>。<br>笔者一开始试用过<code>Navicat</code>，确实非常好用，鉴于平时需求不是很大，所以暂时没有打算付费使用。于是选择了<code>Sequel Pro</code>。</p><p>在使用<code>Sequel Pro</code>的过程中遇到了一些问题。最开始下载的是<code>v1.1.2</code>正式版，但是使用过程中无法连接数据库，还总是闪退。尝试重装也没有解决。搜索后发现很多人都遇到了这个问题。解决方案是下载<code>test build</code>版本。可以完美解决。</p><p>下载地址: <a href="https://sequelpro.com/test-builds" target="_blank" rel="noopener">Sequel Pro test build</a></p><p><img src="/images/sequel_pro_1.png" alt="sequel_pro_1"><br><img src="/images/sequel_pro_2.png" alt="sequel_pro_2"></p><p>如此依赖就可以快乐的使用 MySQL 数据库了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在学习 NestJS 框架，需要使用 MySQL 数据库来配合完成一些功能，以前只使用过 MongoDB，第一次使用 MySQL，在安装和使用时踩了一些坑，记录下来。&lt;/p&gt;&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    
    <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>使用React设计一个Form表单组件</title>
    <link href="http://yoursite.com/2021/07/18/%E4%BD%BF%E7%94%A8React%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AAForm%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2021/07/18/%E4%BD%BF%E7%94%A8React%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AAForm%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6/</id>
    <published>2021-07-18T17:18:44.000Z</published>
    <updated>2021-10-24T03:40:44.651Z</updated>
    
    <content type="html"><![CDATA[<p>通过设计一个 Form 组件，学习 React 中，<code>React.Children.forEach</code> 和 <code>React.CloneElement</code> 以及 <code>React.isValidElement</code> 这三个 API 的用法。</p><h1 id="组件-API-设计"><a href="#组件-API-设计" class="headerlink" title="组件 API 设计"></a>组件 API 设计</h1><p>组件用法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRef &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Form, FormItem, Input &#125; <span class="keyword">from</span> <span class="string">"./Form"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> form = useRef();</span><br><span class="line">  <span class="keyword">const</span> onSubmit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    form.current.submit(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"data"</span>, data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> onReset = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    form.current.reset();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;Form ref=&#123;form&#125;&gt;</span><br><span class="line">        &lt;FormItem name=<span class="string">"name"</span> label=<span class="string">"姓名"</span>&gt;</span><br><span class="line">          &lt;Input /&gt;</span><br><span class="line">        &lt;<span class="regexp">/FormItem&gt;</span></span><br><span class="line"><span class="regexp">        &lt;FormItem name="age" label="年龄"&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Input /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/FormItem&gt;</span></span><br><span class="line"><span class="regexp">        &lt;FormItem name="sex" label="性别"&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Input /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/FormItem&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Form&gt;</span><br><span class="line"></span><br><span class="line">      &lt;button onClick=&#123;onSubmit&#125;&gt;提交&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;onReset&#125;&gt;重置&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="组件实现"><a href="#组件实现" class="headerlink" title="组件实现"></a>组件实现</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Form</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    formData: &#123;&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  submit = <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">    cb &amp;&amp; cb(&#123; ...this.state.formData &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  reset = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; formData &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="built_in">Object</span>.keys(formData).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">      formData[key] = <span class="string">""</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; formData &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  setValue = <span class="function">(<span class="params">name, value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; formData &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    formData[name] = value;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; formData &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; children &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">const</span> &#123; formData &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">const</span> renderChildren = [];</span><br><span class="line"></span><br><span class="line">    React.Children.forEach(children, (child) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (child.type.displayName === <span class="string">"FormItem"</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; name &#125; = child.props;</span><br><span class="line">        renderChildren.push(</span><br><span class="line">          React.cloneElement(</span><br><span class="line">            child,</span><br><span class="line">            &#123;</span><br><span class="line">              key: name,</span><br><span class="line">              value: formData[name] || <span class="string">""</span>,</span><br><span class="line">              handleChange: <span class="keyword">this</span>.setValue,</span><br><span class="line">            &#125;,</span><br><span class="line">            child.props.children</span><br><span class="line">          )</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> renderChildren;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">FormItem</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> displayName = <span class="string">"FormItem"</span>;</span><br><span class="line"></span><br><span class="line">  onChange = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, handleChange &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    handleChange &amp;&amp; handleChange(name, value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; label, value, children &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;span&gt;&#123;label&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &#123;React.isValidElement(children) &amp;&amp;</span></span><br><span class="line"><span class="regexp">        children.type.displayName === "FormItem-Input"</span></span><br><span class="line"><span class="regexp">          ? React.cloneElement(children, &#123; onChange: this.onChange, value &#125;)</span></span><br><span class="line"><span class="regexp">          : null&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> displayName = <span class="string">"FormItem-Input"</span>;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value, onChange &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;input</span><br><span class="line">        value=&#123;value&#125;</span><br><span class="line">        onChange=&#123;(e) =&gt; &#123;</span><br><span class="line">          onChange &amp;&amp; onChange(e.target.value);</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;通过设计一个 Form 组件，学习 React 中，&lt;code&gt;React.Children.forEach&lt;/code&gt; 和 &lt;code&gt;React.CloneElement&lt;/code&gt; 以及 &lt;code&gt;React.isValidElement&lt;/code&gt; 这三个 </summary>
      
    
    
    
    
    <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>数组排序系列</title>
    <link href="http://yoursite.com/2021/04/18/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%B3%BB%E5%88%97/"/>
    <id>http://yoursite.com/2021/04/18/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%B3%BB%E5%88%97/</id>
    <published>2021-04-18T15:52:57.000Z</published>
    <updated>2021-10-24T03:40:44.659Z</updated>
    
    <content type="html"><![CDATA[<p>数组的排序应该是基本中的基本了。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title=" 冒泡排序"></a> 冒泡排序</h2><p>冒泡排序的思想是，通过一次遍历，通过比较，将一个最大的元素，调整到数组的末尾，进行 n 次之后，数组就有序了。<br>因此时间复杂度是 O(n^2)</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortArray</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.length - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的思想是，将数组分成两部分，左半部分是有序的，右半部分是无序的，每次从右半部分取出第一个元素，插入到左半部分。<br>插入的过程是，把待插入元素和左半部分的元素比较，如果小于就交换，如果大于等于就停止。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortArray</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="comment">// nums[i] 是待插入的元素</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j] &lt; nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        swap(nums, j - <span class="number">1</span>, j);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序的思想是，每次将数组分为左右两部分，左半部分的所有值都小于右半部分，然后对左右部分再进行这样的操作。最终整个数组有序。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">nums: <span class="built_in">number</span>[], left: <span class="built_in">number</span>, right: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> right;</span><br><span class="line">  <span class="keyword">const</span> pvoit = nums[left];</span><br><span class="line">  <span class="keyword">const</span> start = left;</span><br><span class="line">  left = left + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[left] &gt; pvoit &amp;&amp; nums[right] &lt; pvoit) &#123;</span><br><span class="line">      swap(nums, left++, right--);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt;= pvoit) &#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap(nums, start, right);</span><br><span class="line">  <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">nums: <span class="built_in">number</span>[], left: <span class="built_in">number</span>, right: <span class="built_in">number</span></span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> p = partition(nums, left, right);</span><br><span class="line">  quickSort(nums, left, p - <span class="number">1</span>);</span><br><span class="line">  quickSort(nums, p + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortArray</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数组的排序应该是基本中的基本了。&lt;/p&gt;&lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot; 冒泡排序&quot;&gt;&lt;/a&gt; 冒泡排序&lt;/h2&gt;&lt;p&gt;冒泡排序的思想是，通过一次遍历，通过比较，将一个最大的元素，调整到数组</summary>
      
    
    
    
    
    <category term="算法与数据结构" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>前缀和系列</title>
    <link href="http://yoursite.com/2021/04/17/%E5%89%8D%E7%BC%80%E5%92%8C%E7%B3%BB%E5%88%97/"/>
    <id>http://yoursite.com/2021/04/17/%E5%89%8D%E7%BC%80%E5%92%8C%E7%B3%BB%E5%88%97/</id>
    <published>2021-04-17T10:44:29.000Z</published>
    <updated>2021-10-24T03:40:44.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><p>前缀和，简单说就是数组的前 n 项的和。不过需要注意，在代码里面，presum[i] 代表前 i 项的和，也就是 nums[0]~nums[i-1]的和。<br>比如 presum[2] = nums[0] + nums[1]。</p><p>通过前缀和的思想和 map，可以优化很多问题解法。</p><p>同时前缀和不一定真的就是前缀的和，也可以是前缀中奇数数字的个数等。总之就前缀的一个统计信息，可以是和，也可以是其他。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">presum</span>(<span class="params">nums: <span class="built_in">number</span></span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> presum = [<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    presum[i + <span class="number">1</span>] = presum[i] + nums[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="724-寻找数组的中心下标"><a href="#724-寻找数组的中心下标" class="headerlink" title="724. 寻找数组的中心下标"></a>724. 寻找数组的中心下标</h2><p>给你一个整数数组 nums，请编写一个能够返回数组 “中心下标” 的方法。数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。如果数组不存在中心下标，返回 -1 。如果数组有多个中心下标，应该返回最靠近左边的那一个。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先求出总和</span></span><br><span class="line"><span class="comment">// 遍历求出左边的和，然后用总和减去左边的和以及当前值，就是右边的和</span></span><br><span class="line"><span class="comment">// 判断左右的和是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pivotIndex</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> presum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    presum += nums[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> leftsum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> rightsum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    rightsum = presum - leftsum - nums[i];</span><br><span class="line">    <span class="keyword">if</span> (leftsum === rightsum) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    leftsum += nums[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用一个map，记录已经访问过的值</span></span><br><span class="line"><span class="comment">// 遍历数组，判断map中是否已经存在一个值，和当前值相加的和是target</span></span><br><span class="line"><span class="comment">// 如果不是，就把当前值加入到map中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">twoSum</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> Map();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.has(target - nums[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span> [map.get(target - nums[i]), i];</span><br><span class="line">    &#125;</span><br><span class="line">    map.set(nums[i], i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a>560. 和为 K 的子数组</h2><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p><blockquote><p>示例 1 : 输入:nums = [1,1,1], k = 2; 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力法，求出了所有子数组的和</span></span><br><span class="line"><span class="comment">// 有可能会超时</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subarraySum</span>(<span class="params">nums: <span class="built_in">number</span>[], k: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">      sum += nums[j];</span><br><span class="line">      <span class="keyword">if</span> (sum === k) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与两数之和类似，使用map节省时间</span></span><br><span class="line"><span class="comment">// map 中记录前缀和，以及该前缀和出现的次数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subarraySum</span>(<span class="params">nums: <span class="built_in">number</span>[], k: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> presum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> Map();</span><br><span class="line">  map.set(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    presum += nums[i];</span><br><span class="line">    <span class="keyword">if</span> (map.has(presum - k)) &#123;</span><br><span class="line">      cnt += map.get(presum - k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> curVal = map.has(presum) ? map.get(presum) : <span class="number">0</span>;</span><br><span class="line">    map.set(presum, curVal + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1248-统计优美子数组"><a href="#1248-统计优美子数组" class="headerlink" title="1248. 统计优美子数组"></a>1248. 统计优美子数组</h2><p>给你一个整数数组 nums 和一个整数 k。如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。请返回这个数组中「优美子数组」的数目。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用位运算判断数字的奇偶性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isOdd</span>(<span class="params">num: <span class="built_in">number</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (num &amp; <span class="number">1</span>) === <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴力法，遍历所有的子数组，计算子数组奇数的个数，判断个数是否为k</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numberOfSubarrays</span>(<span class="params">nums: <span class="built_in">number</span>[], k: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> oddCnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    oddCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isOdd(nums[j])) oddCnt++;</span><br><span class="line">      <span class="keyword">if</span> (oddCnt === k) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// presum 记录的是当前前缀中的奇数的个数</span></span><br><span class="line"><span class="comment">// map记录前缀中奇数个数，以及该种case出现的次数</span></span><br><span class="line"><span class="comment">// 比如map(5,2) 代表，该前缀中有5个奇数，它出现了2次</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numberOfSubarrays</span>(<span class="params">nums: <span class="built_in">number</span>[], k: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> presum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> Map();</span><br><span class="line">  map.set(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    presum += isOdd(nums[i]) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (map.has(presum - k)) &#123;</span><br><span class="line">      cnt += map.get(presum - k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> curVal = map.has(presum) ? map.get(presum) : <span class="number">0</span>;</span><br><span class="line">    map.set(presum, curVal + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="974-和可被-K-整除的子数组"><a href="#974-和可被-K-整除的子数组" class="headerlink" title="974. 和可被 K 整除的子数组"></a>974. 和可被 K 整除的子数组</h2><p>给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。</p><ul><li>这里的 k 大于 2</li><li>数组 A 中有负数。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力法</span></span><br><span class="line"><span class="comment">// 求出所有子数组的和，验证是否可以被K整除</span></span><br><span class="line"><span class="comment">// 超时了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subarraysDivByK</span>(<span class="params">A: <span class="built_in">number</span>[], K: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; A.length; j++) &#123;</span><br><span class="line">      sum += A[j];</span><br><span class="line">      <span class="keyword">if</span> (sum % K === <span class="number">0</span>) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// presum 还是前缀和</span></span><br><span class="line"><span class="comment">// map记录前缀和对K的余数，以及次数</span></span><br><span class="line"><span class="comment">// (presum[i]-presum[j]) % K = 0 --&gt; presum[i] % K = presum[j] % K</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subarraysDivByK</span>(<span class="params">A: <span class="built_in">number</span>[], K: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> presum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> remainder = <span class="number">0</span>; <span class="comment">// 余数</span></span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> Map();</span><br><span class="line">  <span class="comment">// map记录前缀和对K的余数，以及次数</span></span><br><span class="line">  map.set(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">    presum += A[i];</span><br><span class="line">    <span class="comment">// 这里需要把负数的余数转成正数</span></span><br><span class="line">    remainder = ((presum % K) + K) % K;</span><br><span class="line">    <span class="keyword">if</span> (map.has(remainder)) &#123;</span><br><span class="line">      cnt += map.get(remainder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> curVal = map.has(remainder) ? map.get(remainder) : <span class="number">0</span>;</span><br><span class="line">    map.set(remainder, curVal + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="523-连续的子数组和"><a href="#523-连续的子数组和" class="headerlink" title="523. 连续的子数组和"></a>523. 连续的子数组和</h2><p>给定一个包含 非负数 的数组和一个目标 整数 k ，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，且总和为 k 的倍数，即总和为 n * k ，其中 n 也是一个整数。</p><ul><li>k 是整数，可能为 0</li><li>子数组长度至少为 2</li><li>返回 bool 值，判断这个值是否存在</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map的key为余数，val不再是余数出现的次数，而是该余数最早出现的位置</span></span><br><span class="line"><span class="comment">// 通过这个位置来判断，子树组长度是否大于等于2</span></span><br><span class="line"><span class="comment">// k为0的时候，余数就是presum本身，也就变成了是否有两个前缀和是相等的。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkSubarraySum</span>(<span class="params">nums: <span class="built_in">number</span>[], k: <span class="built_in">number</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> presum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> remainder = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> Map();</span><br><span class="line">  map.set(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    presum += nums[i];</span><br><span class="line">    remainder = k === <span class="number">0</span> ? presum : ((presum % k) + k) % k;</span><br><span class="line">    <span class="keyword">if</span> (map.has(remainder)) &#123;</span><br><span class="line">      <span class="keyword">const</span> index = map.get(remainder);</span><br><span class="line">      <span class="keyword">if</span> (i - index &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map.set(remainder, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="930-和相同的二元子数组"><a href="#930-和相同的二元子数组" class="headerlink" title="930. 和相同的二元子数组"></a>930. 和相同的二元子数组</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前缀和&quot;&gt;&lt;a href=&quot;#前缀和&quot; class=&quot;headerlink&quot; title=&quot;前缀和&quot;&gt;&lt;/a&gt;前缀和&lt;/h2&gt;&lt;p&gt;前缀和，简单说就是数组的前 n 项的和。不过需要注意，在代码里面，presum[i] 代表前 i 项的和，也就是 nums[0]~n</summary>
      
    
    
    
    
    <category term="算法与数据结构" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序-课程表系列</title>
    <link href="http://yoursite.com/2021/04/12/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-%E8%AF%BE%E7%A8%8B%E8%A1%A8%E7%B3%BB%E5%88%97/"/>
    <id>http://yoursite.com/2021/04/12/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-%E8%AF%BE%E7%A8%8B%E8%A1%A8%E7%B3%BB%E5%88%97/</id>
    <published>2021-04-12T21:24:21.000Z</published>
    <updated>2021-10-24T03:40:44.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="leetcode-207-课程表"><a href="#leetcode-207-课程表" class="headerlink" title="leetcode 207 课程表"></a>leetcode 207 课程表</h2><p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程 bi 。</p><p>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。<br>请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。</p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>这种在一个图中，互相有依赖关系，需要按照依赖顺序排序输出的问题，就是拓扑排序。拓扑排序除了排序输出之外，还可以验证图中是否有环。比如下面常见的拓扑排序的应用。</p><ul><li>课程学习的先后顺序</li><li>相互依赖的文件的编译顺序</li></ul><h3 id="拓扑排序的方法"><a href="#拓扑排序的方法" class="headerlink" title="拓扑排序的方法"></a>拓扑排序的方法</h3><p>一是 Kahn 算法。二是深度优先遍历</p><h4 id="Kahn-算法"><a href="#Kahn-算法" class="headerlink" title="Kahn 算法"></a>Kahn 算法</h4><p>个人认为 Kahn 算法还是比较好理解的。首先需要定义 b 依赖与 a，a 要先与 b 执行，那么就是 a-&gt;b。<br>此时 b 的入度是 1，a 的入度是 0。</p><ol><li>算法的思路就是首先统计出所有的点的入度，还需要统计所有点的 next 点</li><li>然后找到入度为 0 的点，访问它，随后，将该点的所有 next 点的入度都减 1</li><li>然后重复 2 这个步骤</li><li>直到没有入度为 0 的点为止</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canFinish</span>(<span class="params">numCourses: <span class="built_in">number</span>, prerequisites: <span class="built_in">number</span>[][]</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inDegree = <span class="built_in">Array</span>(numCourses).fill(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> adjacent = inDegree.map(<span class="function"><span class="params">()</span> =&gt;</span> []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [cur, pre] of prerequisites) &#123;</span><br><span class="line">    <span class="comment">// pre -&gt; cur</span></span><br><span class="line">    inDegree[cur] += <span class="number">1</span>;</span><br><span class="line">    adjacent[pre].push(cur);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到所有入度为0的课程</span></span><br><span class="line">  <span class="keyword">const</span> queue = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; inDegree.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inDegree[i] === <span class="number">0</span>) &#123;</span><br><span class="line">      queue.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> list = [];</span><br><span class="line">  <span class="comment">// 遍历入度为0的课程，入度为0，则加入list, 并将它的临接课程入度-1</span></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> cur = queue.shift();</span><br><span class="line">    list.push(cur);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前课程的所有后序课程的入度减1，如果后序课程的入度为0，则加入list</span></span><br><span class="line">    adjacent[cur].forEach(<span class="function">(<span class="params">next</span>) =&gt;</span> &#123;</span><br><span class="line">      inDegree[next]--;</span><br><span class="line">      <span class="keyword">if</span> (inDegree[next] === <span class="number">0</span>) &#123;</span><br><span class="line">        queue.push(next);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后验证一下，是否所有的课程都学完了</span></span><br><span class="line">  <span class="keyword">return</span> list.length === numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dfs-深度优先遍历"><a href="#dfs-深度优先遍历" class="headerlink" title="dfs 深度优先遍历"></a>dfs 深度优先遍历</h4><p>深度优先遍历，也是解决拓扑排序的常用办法。其思路就是沿着一个点，一直往前找它的前置点，直到没有前置的点了，就是找到头了。此时就可以回溯访问了（从外到内探索，从内到外回溯访问）。<br>需要注意的是，需要记录点的状态，未访问｜访问中｜已经访问。</p><ul><li>如果未访问需要标记未访问中</li><li>如果是访问中，则说明又访问了一次，存在环</li><li>如果是已经访问，那么直接返回就可以了;比如(这里和 Kahn 算法是反的，a-&gt;b 代表 b 先于 a 执行。a 依赖 b)<ul><li>a-&gt;b-&gt;c</li><li>d-&gt;b-&gt;c</li><li>访问完 a 这条链路，b 和 c 就已经访问了。因此再访问 d 这条链路时，就不需要访问 b 和 c 了</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  cur: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  pres: <span class="built_in">number</span>[][],</span></span></span><br><span class="line"><span class="function"><span class="params">  visited: <span class="built_in">number</span>[],</span></span></span><br><span class="line"><span class="function"><span class="params">  res: <span class="built_in">number</span>[]</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (visited[cur] === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 已经访问过了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (visited[cur] === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 正在访问中，结果又来访问了。出现了环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 设为访问中</span></span><br><span class="line">    visited[cur] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pres[cur].length; i++) &#123;</span><br><span class="line">      <span class="comment">// 访问前置节点</span></span><br><span class="line">      <span class="keyword">if</span> (!dfs(pres[cur][i], pres, visited, res)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[cur] = <span class="number">2</span>;</span><br><span class="line">    res.push(cur);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findOrder</span>(<span class="params">numCourses: <span class="built_in">number</span>, prerequisites: <span class="built_in">number</span>[][]</span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> visited = <span class="built_in">Array</span>(numCourses).fill(<span class="number">0</span>); <span class="comment">// 0-未访问；1-访问中；2-已经访问</span></span><br><span class="line">  <span class="keyword">const</span> pres = visited.map(<span class="function"><span class="params">()</span> =&gt;</span> []); <span class="comment">// 记录节点的前置节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 统计节点的前置节点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [cur, pre] of prerequisites) &#123;</span><br><span class="line">    pres[cur].push(pre);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!dfs(i, pres, visited, res)) &#123;</span><br><span class="line">      <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;leetcode-207-课程表&quot;&gt;&lt;a href=&quot;#leetcode-207-课程表&quot; class=&quot;headerlink&quot; title=&quot;leetcode 207 课程表&quot;&gt;&lt;/a&gt;leetcode 207 课程表&lt;/h2&gt;&lt;p&gt;你这个学期必须选修 numC</summary>
      
    
    
    
    
    <category term="算法与数据结构" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>完全二叉树、堆和优先队列</title>
    <link href="http://yoursite.com/2021/04/11/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2021/04/11/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</id>
    <published>2021-04-11T14:10:04.000Z</published>
    <updated>2021-10-24T03:40:44.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>完全二叉树是满二叉树的一种退化。它只缺少最后一排最右边的一些元素。如下图所示。</p><p><img src="/images/bianary-tree.png" alt="bianary-tree"></p><h3 id="完全二叉树的特性"><a href="#完全二叉树的特性" class="headerlink" title="完全二叉树的特性"></a>完全二叉树的特性</h3><p>完全二叉树有一个优秀的特性。就是它可以保存在一个数组中，而不需要使用链表的方式来存储。<br>如果对完全二叉树中的节点编号，那么可以总结出一个规律。<br>如果父节点的编号是 i，那么它的左子节点的编号就是 2<em>i，右子节点的编号就是 2</em>i+1</p><blockquote><p>实际上，在计算机中，我们会把数组作为完全二叉树的实际存储结构，而完全二叉树，则是我们重新看待这段数组信息的思维逻辑结构。因此，数据结构最大的价值，就是对我们思维逻辑结构的改造。</p></blockquote><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><blockquote><p>堆（Heap）是一个可以被看成近似完全二叉树的数组。树上的每一个结点对应数组的一个元素。除了最底层外，该树是完全充满的，而且是从左到右填充。—— 来自：《算法导论》</p></blockquote><p>堆其实就是使用完全二叉树实现的一种数据结构。分为大顶堆和小顶堆。</p><ul><li>小顶堆；如果一个完全二叉树的每一个父节点的值都小于其子节点的值，那么就是一个小顶堆。</li><li>大顶堆；如果一个完全二叉树的每一个父节点的值都大于其子节点的值，那么就是一个大顶堆。</li></ul><blockquote><p>为了让你更好地学习堆这种数据结构，我要和你分享一个学习数据结构的公式：数据结构 = 结构定义 + 结构操作。结构定义和结构操作是组成数据结构最重要的两个部分，也是你之后在学任何一种数据结构时的重点内容。结构定义就是定义一种性质，结构操作就是维护这种性质。</p></blockquote><h3 id="堆的结构定义"><a href="#堆的结构定义" class="headerlink" title="堆的结构定义"></a>堆的结构定义</h3><ul><li>大顶堆可以维护一个集合中的最大值。</li><li>小顶堆可以维护一个集合中的最小值。</li></ul><h3 id="堆的结构操作"><a href="#堆的结构操作" class="headerlink" title="堆的结构操作"></a>堆的结构操作</h3><ul><li>插入新元素<ul><li>插入到最后面（数组的最后）</li><li>向上调整，维护堆的特性</li></ul></li><li>删除最值元素<ul><li>将最后一个元素覆盖堆顶元素（数组尾元素覆盖数组头元素）</li><li>向下调整，维护堆的特性</li></ul></li></ul><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ol><li>对数组建立一个大顶堆</li><li>每次将堆顶元素和堆尾元素调换位置（相当于把最大值放在了最后），然后减小堆的 size，从上到下维护堆</li><li>执行 n 次之后，得到一个从小到达排序的数组</li></ol><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><blockquote><p>优先队列好像就是堆的别名啊？其实不然。你可以把优先队列当成是一种概念，那它的定义就是一种可以实现根据优先级出队的结构。而堆只是实现优先队列的其中一种方式，当然也是最普遍的方式。</p></blockquote><h2 id="实现一个最-小-大堆"><a href="#实现一个最-小-大堆" class="headerlink" title="实现一个最(小)大堆"></a>实现一个最(小)大堆</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Heap&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span> heap: T[] = [];</span><br><span class="line">  <span class="keyword">protected</span> getNumberForCompare: <span class="function">(<span class="params">val: T</span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> compare(indexA: <span class="built_in">number</span>, indexB: <span class="built_in">number</span>): <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">getNumberForCompare: (val: T) =&gt; <span class="built_in">number</span>, values: T[] = []</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.getNumberForCompare = getNumberForCompare;</span><br><span class="line">    <span class="keyword">this</span>.heapify(values);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 交换堆内元素</span></span><br><span class="line">  <span class="keyword">protected</span> swap(indexA: <span class="built_in">number</span>, indexB: <span class="built_in">number</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> temp = <span class="keyword">this</span>.heap[indexA];</span><br><span class="line">    <span class="keyword">this</span>.heap[indexA] = <span class="keyword">this</span>.heap[indexB];</span><br><span class="line">    <span class="keyword">this</span>.heap[indexB] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取左孩子的索引</span></span><br><span class="line">  <span class="keyword">protected</span> getLeftChildIndex(index: <span class="built_in">number</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取右孩子的索引</span></span><br><span class="line">  <span class="keyword">protected</span> getRightChildIndex(index: <span class="built_in">number</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取父亲节点的索引</span></span><br><span class="line">  <span class="keyword">protected</span> getParentIndex(index: <span class="built_in">number</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> (index - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化建堆</span></span><br><span class="line">  <span class="keyword">protected</span> heapify(values: T[]) &#123;</span><br><span class="line">    <span class="keyword">this</span>.heap = values;</span><br><span class="line">    <span class="comment">// 完全二叉树的叶子节点的个数是总节点个数的一半。</span></span><br><span class="line">    <span class="comment">// 叶子节点本身不需要堆化。只需要等待后面的节点堆化。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">this</span>.heap.length &gt;&gt;&gt; <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">this</span>.heapifyDown(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向上维护堆</span></span><br><span class="line">  <span class="keyword">protected</span> heapifyUp(index: <span class="built_in">number</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentIndex = index;</span><br><span class="line">    <span class="keyword">let</span> parentIndex = <span class="keyword">this</span>.getParentIndex(currentIndex);</span><br><span class="line">    <span class="keyword">while</span> (parentIndex &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.compare(currentIndex, parentIndex)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.swap(currentIndex, parentIndex);</span><br><span class="line">      currentIndex = parentIndex;</span><br><span class="line">      parentIndex = <span class="keyword">this</span>.getParentIndex(parentIndex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向下维护堆</span></span><br><span class="line">  <span class="keyword">protected</span> heapifyDown(index: <span class="built_in">number</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentIndex = index;</span><br><span class="line">    <span class="keyword">let</span> lChildIndex = <span class="keyword">this</span>.getLeftChildIndex(currentIndex);</span><br><span class="line">    <span class="keyword">let</span> rChildIndex = <span class="keyword">this</span>.getRightChildIndex(currentIndex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> size = <span class="keyword">this</span>.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前值大于左孩子</span></span><br><span class="line">    <span class="keyword">if</span> (lChildIndex &lt; size &amp;&amp; <span class="keyword">this</span>.compare(lChildIndex, currentIndex)) &#123;</span><br><span class="line">      currentIndex = lChildIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前值大于右孩子</span></span><br><span class="line">    <span class="keyword">if</span> (rChildIndex &lt; size &amp;&amp; <span class="keyword">this</span>.compare(rChildIndex, currentIndex)) &#123;</span><br><span class="line">      currentIndex = rChildIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前索引被替换</span></span><br><span class="line">    <span class="keyword">if</span> (currentIndex !== index) &#123;</span><br><span class="line">      <span class="keyword">this</span>.swap(currentIndex, index);</span><br><span class="line">      <span class="keyword">this</span>.heapifyDown(currentIndex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取堆的大小</span></span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.heap.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断堆是否为空</span></span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.heap.length === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入元素</span></span><br><span class="line">  insert(value: T): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.heap.push(value);</span><br><span class="line">      <span class="keyword">this</span>.heapifyUp(<span class="keyword">this</span>.heap.length - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除堆顶元素</span></span><br><span class="line">  extract(): T &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size() === <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">this</span>.heap.shift();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换堆顶和堆尾元素</span></span><br><span class="line">    <span class="keyword">this</span>.swap(<span class="number">0</span>, <span class="keyword">this</span>.heap.length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 剔除最小元素</span></span><br><span class="line">    <span class="keyword">const</span> top = <span class="keyword">this</span>.heap.pop();</span><br><span class="line">    <span class="comment">// 重新堆化</span></span><br><span class="line">    <span class="keyword">this</span>.heapifyDown(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取堆顶元素</span></span><br><span class="line">  top(): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.isEmpty() ? <span class="literal">null</span> : <span class="keyword">this</span>.heap[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取堆内元素</span></span><br><span class="line">  values(): T[] &#123;</span><br><span class="line">    <span class="keyword">return</span> [...this.heap];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小顶堆</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MinHeap&lt;T&gt; <span class="keyword">extends</span> Heap&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span> compare(indexA: <span class="built_in">number</span>, indexB: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="keyword">this</span>.getNumberForCompare(<span class="keyword">this</span>.heap[indexA]) &lt;</span><br><span class="line">      <span class="keyword">this</span>.getNumberForCompare(<span class="keyword">this</span>.heap[indexB])</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大顶堆</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MaxHeap&lt;T&gt; <span class="keyword">extends</span> Heap&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span> compare(indexA: <span class="built_in">number</span>, indexB: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="keyword">this</span>.getNumberForCompare(<span class="keyword">this</span>.heap[indexA]) &gt;</span><br><span class="line">      <span class="keyword">this</span>.getNumberForCompare(<span class="keyword">this</span>.heap[indexB])</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.davideaversa.it/blog/typescript-binary-heap/" target="_blank" rel="noopener">Typescript binary heap</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;完全二叉树&quot;&gt;&lt;a href=&quot;#完全二叉树&quot; class=&quot;headerlink&quot; title=&quot;完全二叉树&quot;&gt;&lt;/a&gt;完全二叉树&lt;/h2&gt;&lt;p&gt;完全二叉树是满二叉树的一种退化。它只缺少最后一排最右边的一些元素。如下图所示。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/i</summary>
      
    
    
    
    
    <category term="算法与数据结构" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Express Koa Redux 中间件原理分析</title>
    <link href="http://yoursite.com/2021/04/10/Express-Koa-Redux%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2021/04/10/Express-Koa-Redux%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2021-04-10T12:23:57.000Z</published>
    <updated>2021-10-24T03:40:44.651Z</updated>
    
    <content type="html"><![CDATA[<p>最早接触中间件，是在第一次使用 express 框架的时候，那时对中间件的作用有了了解，后面再使用 Koa 框架时，也遇到了中间件，最大的使用感受就是中间件的参数不一样了，可以使用<code>await</code>语法来执行<code>next()</code>函数。几乎于此同时，使用的 Redux 也提出了中间件的概念。中间件的概念被广泛的采用，一定有其优势所在。<br>本篇文章尝试分析和比较 Express Koa2 Redux 这三个框架的实现原理。</p><p>调试这三个框架的源码其实非常简单。</p><ol><li>书写一个 js 文件，编写代码。</li><li>使用 vscode 的 debug 功能启动代码。</li><li>使用 curl 请求 localhost。</li></ol><h2 id="Express-的中间件"><a href="#Express-的中间件" class="headerlink" title="Express 的中间件"></a>Express 的中间件</h2><p>express 是内置路由功能的，并且同时内置了<code>static</code>,<code>json</code>,<code>urlencoded</code> 这三个中间件。</p><p>下面是启动一个 express app 并注册 App-Level middleware 的代码。通过这段代码来分析 express 启动和中间件运行流程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// express相当于一个工厂函数，它会返回一个函数，也就是app</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> <span class="title">middlewareA</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"1"</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> <span class="title">middlewareB</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"3"</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"4"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> <span class="title">middlewareC</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>以上代码返回了一个 express 实例，不过这个实例，是一个挂载了很多属性的函数。下面是<code>express()</code>的调用，在源码中就是<code>createApplication()</code>的调用。如下是源码部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// express/lib/express.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义app是一个函数。</span></span><br><span class="line">  <span class="keyword">var</span> app = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// app.handle 是通过mixin的方式组合进来的</span></span><br><span class="line">    app.handle(req, res, next);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用组合的方式，给app这个函数上挂载通用方法。</span></span><br><span class="line">  mixin(app, EventEmitter.prototype, <span class="literal">false</span>);</span><br><span class="line">  mixin(app, proto, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// expose the prototype that will get set on requests</span></span><br><span class="line">  app.request = <span class="built_in">Object</span>.create(req, &#123;</span><br><span class="line">    app: &#123; <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">value</span>: app &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// expose the prototype that will get set on responses</span></span><br><span class="line">  app.response = <span class="built_in">Object</span>.create(res, &#123;</span><br><span class="line">    app: &#123; <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">value</span>: app &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  app.init();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回app函数</span></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>app 通过 mixin 的方式挂载了很多的方法，其中就包含了 <code>use</code> 和 <code>listen</code> 方法。他们的源码如下。精简了一下代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// express/lib/application.js</span></span><br><span class="line">app.use = <span class="function"><span class="keyword">function</span> <span class="title">use</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> path = <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setup router</span></span><br><span class="line">  <span class="keyword">this</span>.lazyrouter();</span><br><span class="line">  <span class="keyword">var</span> router = <span class="keyword">this</span>._router;</span><br><span class="line"></span><br><span class="line">  fns.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断当前的中间件函数不是express app</span></span><br><span class="line">    <span class="keyword">if</span> (!fn || !fn.handle || !fn.set) &#123;</span><br><span class="line">      <span class="comment">// 把中间件挂载到路由的跟路径下。</span></span><br><span class="line">      <span class="keyword">return</span> router.use(path, fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面可以看到，router 很重要，即使是 App-Level 中间件，也是挂载到 router 上的。下面看一下 router 的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// express/lib/router/index.js</span></span><br><span class="line">proto.use = <span class="function"><span class="keyword">function</span> <span class="title">use</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> offset = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> path = <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// default path to '/'</span></span><br><span class="line">  <span class="comment">// disambiguate router.use([fn])</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> arg = fn;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">Array</span>.isArray(arg) &amp;&amp; arg.length !== <span class="number">0</span>) &#123;</span><br><span class="line">      arg = arg[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// first arg is the path</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">"function"</span>) &#123;</span><br><span class="line">      offset = <span class="number">1</span>;</span><br><span class="line">      path = fn;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> callbacks = flatten(slice.call(<span class="built_in">arguments</span>, offset));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> fn = callbacks[i];</span><br><span class="line">    <span class="comment">// 根据path和中间件函数生成一个layer实例</span></span><br><span class="line">    <span class="comment">// 这里layer大概就是，根据path将处理流程分为一个一个层。</span></span><br><span class="line">    <span class="keyword">var</span> layer = <span class="keyword">new</span> Layer(</span><br><span class="line">      path,</span><br><span class="line">      &#123;</span><br><span class="line">        sensitive: <span class="keyword">this</span>.caseSensitive,</span><br><span class="line">        strict: <span class="literal">false</span>,</span><br><span class="line">        end: <span class="literal">false</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      fn</span><br><span class="line">    );</span><br><span class="line">    layer.route = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 最后将layer推入一个栈中。相当于把中间件保存了起来。</span></span><br><span class="line">    <span class="keyword">this</span>.stack.push(layer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面 router 的代码，就是最终实现了 <code>app.use</code> 方法保存中间件函数的逻辑。如果断点调试，会发现一个有趣的事实，就是在我们的 <code>middlewareA</code> 中间件之前，express 已经加入了两个默认的 layer。如下图<br><img src="/images/image-20210410135049145.png" alt="image-20210410135049145"></p><p>下面再来看下程序运行并收到请求后的执行流程。首先是 <code>app.listen</code>，通过 http.createServer 构造了一个 server 实例，实例的回调函数，就是 app 本身，这种写法也是非常骚了，把一个 app 函数玩弄于股掌之间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.listen = <span class="function"><span class="keyword">function</span> <span class="title">listen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> server = http.createServer(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> server.listen.apply(server, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从 <code>createApplication</code> 函数中可以看到，app 函数本身，就是调用了 <code>app.handle</code>,而 <code>app.handle</code> 又是调用了<code>router.handle</code> 囧。所以我们的每个请求，其实最终就是由 <code>router.handle</code> 来处理了，并且会在这里展开对所有中间件的调用。<br>这个代码很长，我们精简一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// express/lib/router/index.js</span></span><br><span class="line">proto.handle = <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">req, res, out</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> protohost = getProtohost(req.url) || <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">var</span> removed = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">var</span> slashAdded = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> paramcalled = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// store options for OPTIONS request</span></span><br><span class="line">  <span class="comment">// only used if OPTIONS request</span></span><br><span class="line">  <span class="keyword">var</span> options = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// middleware and routes</span></span><br><span class="line">  <span class="keyword">var</span> stack = self.stack;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// manage inter-router variables</span></span><br><span class="line">  <span class="keyword">var</span> done = restore(out, req, <span class="string">"baseUrl"</span>, <span class="string">"next"</span>, <span class="string">"params"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setup next layer</span></span><br><span class="line">  req.next = next;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> layerError = err === <span class="string">"route"</span> ? <span class="literal">null</span> : err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// signal to exit router</span></span><br><span class="line">    <span class="keyword">if</span> (layerError === <span class="string">"router"</span>) &#123;</span><br><span class="line">      setImmediate(done, <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no more matching layers</span></span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= stack.length) &#123;</span><br><span class="line">      setImmediate(done, layerError);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get pathname of request</span></span><br><span class="line">    <span class="keyword">var</span> path = getPathname(req);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (path == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> done(layerError);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find next matching layer</span></span><br><span class="line">    <span class="keyword">var</span> layer;</span><br><span class="line">    <span class="keyword">var</span> match;</span><br><span class="line">    <span class="keyword">var</span> route;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (match !== <span class="literal">true</span> &amp;&amp; idx &lt; stack.length) &#123;</span><br><span class="line">      layer = stack[idx++];</span><br><span class="line">      match = matchLayer(layer, path);</span><br><span class="line">      route = layer.route;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> match !== <span class="string">"boolean"</span>) &#123;</span><br><span class="line">        <span class="comment">// hold on to layerError</span></span><br><span class="line">        layerError = layerError || match;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (match !== <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!route) &#123;</span><br><span class="line">        <span class="comment">// process non-route handlers normally</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (layerError) &#123;</span><br><span class="line">        <span class="comment">// routes do not match with a pending error</span></span><br><span class="line">        match = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> method = req.method;</span><br><span class="line">      <span class="keyword">var</span> has_method = route._handles_method(method);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// build up automatic options response</span></span><br><span class="line">      <span class="keyword">if</span> (!has_method &amp;&amp; method === <span class="string">"OPTIONS"</span>) &#123;</span><br><span class="line">        appendMethods(options, route._options());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// don't even bother matching route</span></span><br><span class="line">      <span class="keyword">if</span> (!has_method &amp;&amp; method !== <span class="string">"HEAD"</span>) &#123;</span><br><span class="line">        match = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no match</span></span><br><span class="line">    <span class="keyword">if</span> (match !== <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> done(layerError);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// store route for dispatch on change</span></span><br><span class="line">    <span class="keyword">if</span> (route) &#123;</span><br><span class="line">      req.route = route;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Capture one-time layer values</span></span><br><span class="line">    req.params = self.mergeParams</span><br><span class="line">      ? mergeParams(layer.params, parentParams)</span><br><span class="line">      : layer.params;</span><br><span class="line">    <span class="keyword">var</span> layerPath = layer.path;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this should be done for the layer</span></span><br><span class="line">    self.process_params(layer, paramcalled, req, res, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> next(layerError || err);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (route) &#123;</span><br><span class="line">        <span class="keyword">return</span> layer.handle_request(req, res, next);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      trim_prefix(layer, layerError, layerPath, path);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (layerError) &#123;</span><br><span class="line">      layer.handle_error(layerError, req, res, next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      layer.handle_request(req, res, next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，关键的就是 next 函数了，next 函数引用了一个外部变量 idx ，形成了一个包含 idx 的闭包，next 函数每次执行，都会找到下一个需要执行的中间件(layer), 然后执行 <code>layer.handle_request(req, res, next);</code> , 在执行的过程中，将 next 函数本身作为参数传递，这样当中间件执行 next 的时候，又会重复上述过程。通过 next 的执行，串起了一个一个中间件。</p><h3 id="Express-中间件的总结"><a href="#Express-中间件的总结" class="headerlink" title="Express 中间件的总结"></a>Express 中间件的总结</h3><p>第一段代码的输出为 <code>1 3 4 2</code>, 其实也可以说 express 的中间件执行顺序类似与洋葱圈模型。但是，express 结束请求，返回响应的标志是 <code>res.send</code> ，也就是说一旦调用了 <code>res.send</code>,那么响应也就结束了，虽然后序的代码仍然会继续执行。但是已经影响不到响应了。这也是和 koa 的一个重要区别。</p><p>另一个要说明的就是，express 相对于 koa，内置了路由系统，甚至中间件也是挂载在路由上的，因此源代码比 koa 更加复杂。express 成型的时间比较早，内部的写法还都是函数，也没有明显的使用 promise async await 等先进的特性。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>[1] <a href="http://expressjs.com/en/guide/using-middleware.html" target="_blank" rel="noopener">express</a></li><li>[2] <a href="https://cloud.tencent.com/developer/article/1467268" target="_blank" rel="noopener">koa 和 express 中间件揭秘</a></li><li>[3] <a href="https://zhuanlan.zhihu.com/p/87079561" target="_blank" rel="noopener">express 和 koa 的区别</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最早接触中间件，是在第一次使用 express 框架的时候，那时对中间件的作用有了了解，后面再使用 Koa 框架时，也遇到了中间件，最大的使用感受就是中间件的参数不一样了，可以使用&lt;code&gt;await&lt;/code&gt;语法来执行&lt;code&gt;next()&lt;/code&gt;函数。几乎</summary>
      
    
    
    
    
    <category term="中间件" scheme="http://yoursite.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
    <category term="koa" scheme="http://yoursite.com/tags/koa/"/>
    
    <category term="redux" scheme="http://yoursite.com/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>二叉树系列</title>
    <link href="http://yoursite.com/2021/04/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%97/"/>
    <id>http://yoursite.com/2021/04/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%97/</id>
    <published>2021-04-07T09:51:15.000Z</published>
    <updated>2021-10-24T03:40:44.651Z</updated>
    
    <content type="html"><![CDATA[<p>(搜索)二叉树这种数据结构，操作和判断特别多，这篇文章归纳和整理一下它的常见操作。一个有趣的现象是，关于二叉树，有广度优先和深度优先两种搜索办法。如果是广度优先，常规做法是使用一个辅助队列 queue。如果是深度优先，常规做法是使用递归。</p><ul><li>验证二叉搜索树</li><li>对称二叉树</li><li>二叉树的前中后序遍历</li><li>二叉树的层次遍历/锯形层次遍历</li><li>二叉树最近公共祖先</li><li>二叉树最大/最小深度</li><li>删除二叉树中的节点</li><li>从中序遍历和后序遍历构造二叉树</li></ul><h2 id="验证二叉搜索树-98"><a href="#验证二叉搜索树-98" class="headerlink" title="验证二叉搜索树 98"></a>验证二叉搜索树 98</h2><p>验证一棵树是否为二叉搜索树，有两种方法。都是基于二叉搜索树的特征。</p><ul><li>基于二叉搜索树的中序遍历结果是升序序列。<ul><li>中序遍历整个二叉搜索树，遍历的过程中查验是否为升序。</li></ul></li><li>基于节点的左子树中所有的节点的值，均小于当前节点的值；节点的右子树中所有节点的值，均大于当前节点的值。<ul><li>根节点的值的范围为(-Infinity,Infinity)。其左子节点的值应该小于 root.val, 所以范围应该为(-Infinity,root.val)。同理，右子节点的范围应该为(root.val,Infinity)。树上的每个节点都应该满足上面的条件。</li></ul></li></ul><h3 id="递归代码"><a href="#递归代码" class="headerlink" title="递归代码"></a>递归代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helper</span>(<span class="params">root: TreeNode | <span class="literal">null</span>, min: <span class="built_in">number</span>, max: <span class="built_in">number</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 不满足条件</span></span><br><span class="line">  <span class="keyword">if</span> (root.val &lt;= min || root.val &gt;= max) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 递归验证左右孩子是否满足条件</span></span><br><span class="line">  <span class="keyword">return</span> helper(root.left, min, root.val) &amp;&amp; helper(root.right, root.val, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isValidBST</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="comment">// root节点的取值范围为(-Infinity,Infinity)</span></span><br><span class="line">  <span class="keyword">return</span> helper(root, -<span class="literal">Infinity</span>, <span class="literal">Infinity</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对称二叉树-剑指-offer28"><a href="#对称二叉树-剑指-offer28" class="headerlink" title="对称二叉树 剑指 offer28"></a>对称二叉树 剑指 offer28</h2><p>验证一个树是否为对称二叉树，优雅的方案还是递归，毕竟要一层一层的比较，而且每次比较的模式都是一样的。</p><h3 id="递归代码-1"><a href="#递归代码-1" class="headerlink" title="递归代码"></a>递归代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helper</span>(<span class="params">left: TreeNode | <span class="literal">null</span>, right: TreeNode | <span class="literal">null</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!left &amp;&amp; !right) &#123;</span><br><span class="line">    <span class="comment">// 都不存在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &amp;&amp; right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left.val === right.val) &#123;</span><br><span class="line">      <span class="comment">// 当前两个节点是对称的，继续去验证他们的孩子是否对称</span></span><br><span class="line">      <span class="keyword">return</span> helper(left.left, right.right) &amp;&amp; helper(left.right, right.left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不对称相等</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// left或者right，只存在一个</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSymmetric</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> helper(root, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的前中后序遍历-94"><a href="#二叉树的前中后序遍历-94" class="headerlink" title="二叉树的前中后序遍历 94"></a>二叉树的前中后序遍历 94</h2><p>这里以二叉树的中序遍历为例子。使用递归，中序遍历的实现很容易实现（代码简单）。比较难（或者说不容易记住和理解）的是使用迭代的方式来遍历。<br>不过话说回来，明明递归的代码看上去更简洁明了，可能是更符合人们的思维习惯。相反如果是使用迭代，确需要肯定的理解其执行过程 😖。</p><h3 id="递归代码-2"><a href="#递归代码-2" class="headerlink" title="递归代码"></a>递归代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helper</span>(<span class="params">root: TreeNode | <span class="literal">null</span>, res: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  helper(root.left, res);</span><br><span class="line">  res.push(root.val);</span><br><span class="line">  helper(root.right, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inorderTraversal</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res: <span class="built_in">number</span>[] = [];</span><br><span class="line">  helper(root, res);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代代码"><a href="#迭代代码" class="headerlink" title="迭代代码"></a>迭代代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inorderTraversal</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="comment">// 既然是递归，就要用栈来模拟咯</span></span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">while</span> (stack.length || root) &#123;</span><br><span class="line">    <span class="keyword">while</span> (root) &#123;</span><br><span class="line">      stack.push(root);</span><br><span class="line">      root = root.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时的root为null，栈顶元素就是最左边的叶子节点</span></span><br><span class="line">    <span class="comment">// 弹出并访问</span></span><br><span class="line">    <span class="keyword">const</span> node = stack.pop();</span><br><span class="line">    res.push(node.val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这一步很关键，开始准备遍历右子树</span></span><br><span class="line">    root = node.right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h2><ul><li>使用递归，也就是 dfs 深度优先搜索。</li><li>可以使用一个队列来保存被访问的节点，也就是广度优先搜索。</li></ul><h3 id="递归代码-3"><a href="#递归代码-3" class="headerlink" title="递归代码"></a>递归代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helper</span>(<span class="params">root: TreeNode | <span class="literal">null</span>, index: <span class="built_in">number</span>, res: <span class="built_in">number</span>[][]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  res[index] ? res[index].push(root.val) : (res[index] = [root.val]);</span><br><span class="line"></span><br><span class="line">  helper(root.left, index + <span class="number">1</span>, res);</span><br><span class="line">  helper(root.right, index + <span class="number">1</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">levelOrder</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="title">number</span>[][] </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  helper(root, <span class="number">0</span>, res);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代代码-1"><a href="#迭代代码-1" class="headerlink" title="迭代代码"></a>迭代代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">levelOrder</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="title">number</span>[][] </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">const</span> queue = [root];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> length = queue.length;</span><br><span class="line">    <span class="keyword">const</span> temp = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> node = queue.shift();</span><br><span class="line">      temp.push(node.val);</span><br><span class="line">      <span class="keyword">if</span> (node.left) queue.push(node.left);</span><br><span class="line">      <span class="keyword">if</span> (node.right) queue.push(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(temp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树最近公共祖先"><a href="#二叉树最近公共祖先" class="headerlink" title="二叉树最近公共祖先"></a>二叉树最近公共祖先</h2><p>前提条件是 p 和 q 都是树中的节点。</p><h3 id="递归代码-4"><a href="#递归代码-4" class="headerlink" title="递归代码"></a>递归代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lowestCommonAncestor</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: TreeNode | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  p: TreeNode | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  q: TreeNode | <span class="literal">null</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">TreeNode</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">  <span class="keyword">if</span> (root === p || root === q) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">  <span class="keyword">const</span> right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (left &amp;&amp; right) &#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left) &#123;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><p>递归求出左右子树深度的最大值，然后加 1。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxDepth</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minDepth</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!root.left &amp;&amp; !root.right) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> min = <span class="literal">Infinity</span>;</span><br><span class="line">  <span class="keyword">if</span> (root.left) &#123;</span><br><span class="line">    min = <span class="built_in">Math</span>.min(minDepth(root.left), min);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (root.right) &#123;</span><br><span class="line">    min = <span class="built_in">Math</span>.min(minDepth(root.right), min);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> min + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;(搜索)二叉树这种数据结构，操作和判断特别多，这篇文章归纳和整理一下它的常见操作。一个有趣的现象是，关于二叉树，有广度优先和深度优先两种搜索办法。如果是广度优先，常规做法是使用一个辅助队列 queue。如果是深度优先，常规做法是使用递归。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;验证二叉搜索</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="算法与数据结构" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>常用React hooks</title>
    <link href="http://yoursite.com/2021/04/05/%E5%B8%B8%E7%94%A8React-hooks/"/>
    <id>http://yoursite.com/2021/04/05/%E5%B8%B8%E7%94%A8React-hooks/</id>
    <published>2021-04-05T21:32:11.000Z</published>
    <updated>2021-10-24T03:40:44.651Z</updated>
    
    <content type="html"><![CDATA[<p>React hooks 已经很普及了。记录和整理一些比较通用的 hook。</p><h2 id="useMount"><a href="#useMount" class="headerlink" title="useMount"></a>useMount</h2><p>返回组件挂载的状态。可以在一些异步处理之后，判断组件是否已经被卸载。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mount = useRef(<span class="literal">false</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    mount.current = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      mount.current = <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> mount.current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="usePreProps"><a href="#usePreProps" class="headerlink" title="usePreProps"></a>usePreProps</h2><p>返回上一次的 props，也可以用来判断某个 props 是否改变。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">usePreProps</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef(props);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ref.current = props;</span><br><span class="line">  &#125;, [props]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return ref.current === props; // 判断属性是否改变</span></span><br><span class="line">  <span class="keyword">return</span> ref.current; <span class="comment">// 返回上一次的属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="useOnScreen"><a href="#useOnScreen" class="headerlink" title="useOnScreen"></a>useOnScreen</h2><p>返回组件是否曝光。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useOnScreen = <span class="function">(<span class="params">ref: React.RefObject&lt;<span class="built_in">any</span>&gt;, rootMargin = "0px"</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!ref || !ref.current) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [intersecting, setIntersecting] = useState(<span class="literal">false</span>); <span class="comment">// 是否已经曝光</span></span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ovserver = <span class="keyword">new</span> IntersectionObserver(</span><br><span class="line">      ([entry]) =&gt; &#123;</span><br><span class="line">        setIntersecting(entry.isIntersecting);</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; rootMargin &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    ovserver.observe(ref.current);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      observer.unobserve(ref.current);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [intersecting];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;React hooks 已经很普及了。记录和整理一些比较通用的 hook。&lt;/p&gt;&lt;h2 id=&quot;useMount&quot;&gt;&lt;a href=&quot;#useMount&quot; class=&quot;headerlink&quot; title=&quot;useMount&quot;&gt;&lt;/a&gt;useMount&lt;/h2&gt;&lt;p&gt;返回</summary>
      
    
    
    
    
    <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-n数之和系列</title>
    <link href="http://yoursite.com/2021/03/26/leetcode-N%E6%95%B0%E4%B9%8B%E5%92%8C%E7%B3%BB%E5%88%97/"/>
    <id>http://yoursite.com/2021/03/26/leetcode-N%E6%95%B0%E4%B9%8B%E5%92%8C%E7%B3%BB%E5%88%97/</id>
    <published>2021-03-26T09:17:51.000Z</published>
    <updated>2021-10-24T03:40:44.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="N-数之和系列"><a href="#N-数之和系列" class="headerlink" title="N 数之和系列"></a>N 数之和系列</h1><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>给定一个数组，一个 target，找到数组中所有两个数字之和为 target 的组合。这里为了后面 N 数之和做准备，不是返回一个组合。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">twoSum</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="title">number</span>[][] </span>&#123;</span><br><span class="line">  <span class="comment">// 先排序数组</span></span><br><span class="line">  nums.sorts(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 双指针遍历</span></span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">const</span> lVal = nums[left];</span><br><span class="line">    <span class="keyword">const</span> rVal = nums[right];</span><br><span class="line">    <span class="keyword">if</span> (lVal + rVal === target) &#123;</span><br><span class="line">      res.push([lVal, rVal]);</span><br><span class="line">      <span class="comment">// 排除重复的</span></span><br><span class="line">      <span class="keyword">while</span> (nums[left] === lVal) left++;</span><br><span class="line">      <span class="keyword">while</span> (nums[right] === rVal) right--;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lVal + rVal &lt; target) &#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p>有了两数之和，三数之和的计算就可以依赖现有的两数之和的函数，但是要稍微改造一下。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更加泛型（通用）的两数之和函数</span></span><br><span class="line"><span class="comment">// 默认数组已经排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">twoSum</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span>, start: <span class="built_in">number</span></span>): <span class="title">number</span>[][] </span>&#123;</span><br><span class="line">  <span class="comment">// 双指针遍历</span></span><br><span class="line">  <span class="keyword">let</span> left = start;</span><br><span class="line">  <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">const</span> lVal = nums[left];</span><br><span class="line">    <span class="keyword">const</span> rVal = nums[right];</span><br><span class="line">    <span class="keyword">if</span> (lVal + rVal === target) &#123;</span><br><span class="line">      res.push([lVal, rVal]);</span><br><span class="line">      <span class="comment">// 排除重复的</span></span><br><span class="line">      <span class="keyword">while</span> (nums[left] === lVal) left++;</span><br><span class="line">      <span class="keyword">while</span> (nums[right] === rVal) right--;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lVal + rVal &lt; target) &#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">threeSum</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="title">number</span>[][] </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.length &lt; <span class="number">3</span>) <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 遍历第一个数字，下面要求两数之和，和为target-nums[i]</span></span><br><span class="line">    <span class="keyword">const</span> newTarget = <span class="number">0</span> - nums[i];</span><br><span class="line">    <span class="keyword">const</span> newStart = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> temp = twoSum(nums, newTarget, newStart);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; temp.length; j++) &#123;</span><br><span class="line">      res.push([nums[i], ...temp[j]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去除重复的结果</span></span><br><span class="line">    <span class="keyword">while</span> (nums[i] === nums[i + <span class="number">1</span>]) i++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="N-数之和"><a href="#N-数之和" class="headerlink" title="N 数之和"></a>N 数之和</h2><p>有了上面的例子，继而推演出 N 数之和的通用方法，也就有了思路。每次确定一个数字，最终只剩两个数字的时候，就是调用两数之和的时候。需要注意的是，常规的想法是 N 是几，就进行 N-1 层遍历。这里 N 是未知的。不过可以使用递归，来一层一层的减少 N</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更加泛型（通用）的两数之和函数</span></span><br><span class="line"><span class="comment">// 默认数组已经排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">twoSum</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span>, start: <span class="built_in">number</span></span>): <span class="title">number</span>[][] </span>&#123;</span><br><span class="line">  <span class="comment">// 双指针遍历</span></span><br><span class="line">  <span class="keyword">let</span> left = start;</span><br><span class="line">  <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">const</span> lVal = nums[left];</span><br><span class="line">    <span class="keyword">const</span> rVal = nums[right];</span><br><span class="line">    <span class="keyword">if</span> (lVal + rVal === target) &#123;</span><br><span class="line">      res.push([lVal, rVal]);</span><br><span class="line">      <span class="comment">// 排除重复的</span></span><br><span class="line">      <span class="keyword">while</span> (nums[left] === lVal) left++;</span><br><span class="line">      <span class="keyword">while</span> (nums[right] === rVal) right--;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lVal + rVal &lt; target) &#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里数组已经排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nSum</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  nums: <span class="built_in">number</span>[][],</span></span></span><br><span class="line"><span class="function"><span class="params">  target: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  n: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  start: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  visited: <span class="built_in">number</span>[],</span></span></span><br><span class="line"><span class="function"><span class="params">  ans: <span class="built_in">number</span>[][] = []</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">number</span>[][] </span>&#123;</span><br><span class="line">  <span class="comment">// 注意这里是大于</span></span><br><span class="line">  <span class="keyword">if</span> (n + start &gt; nums.length) <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 可以调用两数之和</span></span><br><span class="line">    <span class="keyword">const</span> temp = twoSum(nums, target, start);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">      ans.push([...visited, ...temp[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// n大于2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> newTarget = target - nums[i];</span><br><span class="line">      <span class="keyword">const</span> newN = n - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">const</span> newStart = i + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">const</span> newVisited = [...visited, nums[i]];</span><br><span class="line">      nSum(nums, newTarget, newN, newStart, newVisited, ans);</span><br><span class="line">      <span class="comment">// 去除重复的</span></span><br><span class="line">      <span class="keyword">while</span> (nums[i] === nums[i + <span class="number">1</span>]) i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如求四数之和</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fourSum</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="title">number</span>[][] </span>&#123;</span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">return</span> nSum(nums, target, <span class="number">4</span>, <span class="number">0</span>, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;N-数之和系列&quot;&gt;&lt;a href=&quot;#N-数之和系列&quot; class=&quot;headerlink&quot; title=&quot;N 数之和系列&quot;&gt;&lt;/a&gt;N 数之和系列&lt;/h1&gt;&lt;h2 id=&quot;两数之和&quot;&gt;&lt;a href=&quot;#两数之和&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-买卖股票的最佳时机系列(121,122,123,188)</title>
    <link href="http://yoursite.com/2021/03/14/leetcode-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E7%B3%BB%E5%88%97/"/>
    <id>http://yoursite.com/2021/03/14/leetcode-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E7%B3%BB%E5%88%97/</id>
    <published>2021-03-14T18:32:46.000Z</published>
    <updated>2021-10-24T03:40:44.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="121-买卖股票的最佳时机-I"><a href="#121-买卖股票的最佳时机-I" class="headerlink" title="121 买卖股票的最佳时机 I"></a>121 买卖股票的最佳时机 I</h1><p>给定一只股票，但是只能买卖一次。</p><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>进行两层循环，第一层循环是买入的日子，第二层循环是卖出的日子，遍历左右的利润，求出最大值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxProfit</span>(<span class="params">prices: <span class="built_in">number</span>[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> length = prices.length;</span><br><span class="line">  <span class="keyword">let</span> profit = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">      profit = <span class="built_in">Math</span>.max(profit, prices[j] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>进行一次遍历，在遍历的过程中修改变量，一个是当前最低的价格，一个是当前的利润。<br>如果当前价格低于最低价格，则更新最低价格。用当前的价格减去最低价格，即是这一天能够获得的最大利润。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxProfit</span>(<span class="params">prices: <span class="built_in">number</span>[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> length = prices.length;</span><br><span class="line">  <span class="keyword">let</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> profit = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prices[i] &lt; minPrice) &#123;</span><br><span class="line">      minPrice = prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">    profit = <span class="built_in">Math</span>.max(profit, prices[i] - minPrice);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122 买卖股票的最佳时机 II"></a>122 买卖股票的最佳时机 II</h1><h2 id="暴力法-1"><a href="#暴力法-1" class="headerlink" title="暴力法"></a>暴力法</h2><p>对于每个股票交易日，都有两种选择，一种是按兵不动，即不进行任何操作。还有一种是根据当前股票的持有情况，进入买进或者卖出，比如当前持有股票就可以卖出，当前没有股票就进行买入。</p><p>每一个交日易都有不同的选择，一次一次的选择形成了一棵操作树，这是典型的 dfs 了。</p><h3 id="暴力法代码"><a href="#暴力法代码" class="headerlink" title="暴力法代码"></a>暴力法代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxProfit</span>(<span class="params">prices: <span class="built_in">number</span>[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> length = prices.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// status:0代表手上没有股票，可以买。1代表手上有股票，可以卖。</span></span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">count: <span class="built_in">number</span>, profit: <span class="built_in">number</span>, status: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count === length) &#123;</span><br><span class="line">      max = <span class="built_in">Math</span>.max(max, profit);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按兵不动</span></span><br><span class="line">    dfs(count + <span class="number">1</span>, profit, status);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行操作</span></span><br><span class="line">    <span class="keyword">if</span> (status === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 进行买入，利润要减掉当前价格</span></span><br><span class="line">      dfs(count + <span class="number">1</span>, profit - prices[count], <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 进行卖出，利润要加上当前价格</span></span><br><span class="line">      dfs(count + <span class="number">1</span>, profit + prices[count], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>这个问题，可以使用贪心算法，即根据当日的价格来决定上个交易日是否进行买入，只要今天的价格比昨天高，就昨天买日，今天卖出。当然现实情况下，是不可能买入昨天的股票的。</p><h3 id="贪心法代码"><a href="#贪心法代码" class="headerlink" title="贪心法代码"></a>贪心法代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxProfit</span>(<span class="params">prices: <span class="built_in">number</span>[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!prices || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> profit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      profit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>如果使用动态规划来解决这个问题，那么需要保存一个二维的状态，dp[i][j]。<br>dp[i][0] 代表第 i 天，手上没有股票时的收益。dp[i][1]代表第 i 天手上有股票的收益。<br>那么推导一下状态方程就是</p><ul><li>dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]+prices[i])<ul><li>也就是第 i 天手上没有股票时，可以是 i-1 天本来就没有股票，然后第 i 天不进行任何操作，或者是 i-1 天持有股票，然后将其卖出。取两者的最大值。</li></ul></li><li>dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i])<ul><li>也就是第 i 天手上有股票时，可以是 i-1 天本来就有股票，然后第 i 天按兵不动，或者第 i-1 天手上没有骨片，然后今天买进。取两者的最大值。</li></ul></li></ul><p>最后我们期望的结果就是 dp[n][0]。也就是最后一天手上没有股票时的金额。<br>可以看出第 n 天的最大收益，是根据之前的每一天的收益情况，一点一点推导出来的。非常经典的动态规划。</p><h3 id="动态规划代码"><a href="#动态规划代码" class="headerlink" title="动态规划代码"></a>动态规划代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxProfit</span>(<span class="params">prices: <span class="built_in">number</span>[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!prices || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dp = prices.map(<span class="function"><span class="params">()</span> =&gt;</span> [<span class="number">0</span>, <span class="number">0</span>]);</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123 买卖股票的最佳时机 III"></a>123 买卖股票的最佳时机 III</h1><p>不同于买卖股票的最佳时机 II。这次只能交易两次了。这次我们只选择动态规划来解决这个问题。我们把买进股票作为交易一次股票的标志。</p><h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><p>首先需要增加一个状态，来记录当前已经交易了几次。dp[i][j][k] ,j 代表了是第几次买进股票了。可以的取值为 0，1，2。k 还是代表当前手上是否持有股票，0 表示不持有，1 表示持有。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxProfit</span>(<span class="params">prices: <span class="built_in">number</span>[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> length = prices.length;</span><br><span class="line">  <span class="comment">// 初始化三维dp数组</span></span><br><span class="line">  <span class="keyword">const</span> dp = prices.map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Array</span>(<span class="number">2</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; j++) &#123;</span><br><span class="line">      dp[i][j] = [];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化状态</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第i天，没有交易股票，手上也没有股票</span></span><br><span class="line">    dp[i][<span class="number">0</span>][<span class="number">1</span>] = -<span class="literal">Infinity</span>; <span class="comment">// 第i天，没有交易股票，手上有一股，是不可能的。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第1天，买入了j次，手上没有股票</span></span><br><span class="line">    dp[<span class="number">0</span>][j][<span class="number">1</span>] = -pirces[<span class="number">0</span>]; <span class="comment">// 第一天，买入了j次，手上有股票</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span>; j++) &#123;</span><br><span class="line">      dp[i][j][<span class="number">0</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">      dp[i][j][<span class="number">1</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 求最后一天，手上没有股票时的最大利润</span></span><br><span class="line">  <span class="keyword">let</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; j++) &#123;</span><br><span class="line">    maxProfit = <span class="built_in">Math</span>.max(maxProfit, dp[length - <span class="number">1</span>][j][<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188 买卖股票的最佳时机 IV"></a>188 买卖股票的最佳时机 IV</h1><p>这一次又升级了，可以买卖 k 次</p><h2 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h2><p>状态方程可以参考买卖两次。其实已经将算法范型化，支持将 2 次变成 k 次就可以了。<br>需要注意的是，当 k&gt;=len/2 的时候，问题相当于变成了可以交易无数次，也就是 122，这时可以直接采用 122 的贪心算法。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greedy</span>(<span class="params">prices: <span class="built_in">number</span>[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!prices || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> profit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      profit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxProfit</span>(<span class="params">k: <span class="built_in">number</span>, prices: <span class="built_in">number</span>[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (k &gt;= prices.length / <span class="number">2</span>) <span class="keyword">return</span> greedy(prices);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> length = prices.length;</span><br><span class="line">  <span class="comment">// 初始化三维dp数组</span></span><br><span class="line">  <span class="keyword">const</span> dp = prices.map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Array</span>(k + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">      dp[i][j] = [];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化状态</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第i天，没有交易股票，手上也没有股票</span></span><br><span class="line">    dp[i][<span class="number">0</span>][<span class="number">1</span>] = -<span class="literal">Infinity</span>; <span class="comment">// 第i天，没有交易股票，手上有一股，是不可能的。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第1天，买入了j次，手上没有股票</span></span><br><span class="line">    dp[<span class="number">0</span>][j][<span class="number">1</span>] = -prices[<span class="number">0</span>]; <span class="comment">// 第一天，买入了j次，手上有股票</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">      dp[i][j][<span class="number">0</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">      dp[i][j][<span class="number">1</span>] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 求最后一天，手上没有股票时的最大利润</span></span><br><span class="line">  <span class="keyword">let</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">    maxProfit = <span class="built_in">Math</span>.max(maxProfit, dp[length - <span class="number">1</span>][j][<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;121-买卖股票的最佳时机-I&quot;&gt;&lt;a href=&quot;#121-买卖股票的最佳时机-I&quot; class=&quot;headerlink&quot; title=&quot;121 买卖股票的最佳时机 I&quot;&gt;&lt;/a&gt;121 买卖股票的最佳时机 I&lt;/h1&gt;&lt;p&gt;给定一只股票，但是只能买卖一次。&lt;/</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-142-环形链表</title>
    <link href="http://yoursite.com/2021/03/14/leetcode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2021/03/14/leetcode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</id>
    <published>2021-03-14T11:05:49.000Z</published>
    <updated>2021-10-24T03:40:44.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="142-环形链表"><a href="#142-环形链表" class="headerlink" title="142 环形链表"></a>142 环形链表</h1><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法 1"></a>解法 1</h2><p>遍历链表，同时使用一个 set 存储已经访问过的节点，如果当前正在访问的节点存在于 set 中，则说明找到了换的入口。返回该节点。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">detectCycle</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="title">ListNode</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">set</span> = <span class="keyword">new</span> Set&lt;ListNode&gt;();</span><br><span class="line">  <span class="keyword">let</span> node = head;</span><br><span class="line">  <span class="keyword">while</span> (node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">set</span>.has(node)) &#123;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">set</span>.add(node);</span><br><span class="line">      node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法-2"><a href="#解法-2" class="headerlink" title="解法 2"></a>解法 2</h2><p>假设起点到环的入口点的距离是 a，慢指针和快指针在环内相遇，慢指针在环内走过的距离是 b，环内剩下的距离是 c，则环的周长是 b+c。<br>快指针走过的距离是慢指针的 2 倍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">slow * 2 &#x3D; fast</span><br><span class="line">slow &#x3D; a + b</span><br><span class="line">fast &#x3D; a + b + (b + c)</span><br><span class="line">2 * (a + b) &#x3D; a + b + (b + c);</span><br><span class="line">a &#x3D; c</span><br></pre></td></tr></table></figure><p>可以推导出环内剩余路程 c，和 a 距离相等。因此定义一个指针从 head 出发，慢指针继续走，相遇点即为入口点。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">detectCycle</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="title">ListNode</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> slow = head;</span><br><span class="line">  <span class="keyword">let</span> fast = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (fast &amp;&amp; fast.next) &#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slow === fast) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有环</span></span><br><span class="line">  <span class="keyword">if</span> (!fast || !fast.next) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有环</span></span><br><span class="line">  <span class="keyword">let</span> p = head;</span><br><span class="line">  <span class="keyword">while</span> (p !== slow) &#123;</span><br><span class="line">    p = p.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;142-环形链表&quot;&gt;&lt;a href=&quot;#142-环形链表&quot; class=&quot;headerlink&quot; title=&quot;142 环形链表&quot;&gt;&lt;/a&gt;142 环形链表&lt;/h1&gt;&lt;h2 id=&quot;解法-1&quot;&gt;&lt;a href=&quot;#解法-1&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://yoursite.com/2021/03/13/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2021/03/13/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2021-03-13T22:30:17.000Z</published>
    <updated>2021-10-24T03:40:44.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集一种数据结构，可以用一个 Class 来实现。可以把一组数据关联起来，然后统计数量。<br>可以用来解决岛屿数量的问题。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>使用一个数组来保存每一项的父节点</li><li>使用一个数组来保存每一项的层级</li><li>一个 findRoot 方法，可以找到一项的根</li><li>一个 union 方法，如果两项的根不同，可以合并两项的根，使他们俩的根相同</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> UnionFind &#123;</span><br><span class="line">  parent: <span class="built_in">number</span>[] = [];</span><br><span class="line">  rank: <span class="built_in">number</span>[] = [];</span><br><span class="line">  count: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">nums: <span class="built_in">number</span>[][]</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> m = nums.length;</span><br><span class="line">    <span class="keyword">const</span> n = nums[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.rank[i * n + j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[i][j]) &#123;</span><br><span class="line">          <span class="keyword">this</span>.parent[i * n + j] = i * n + j;</span><br><span class="line">          <span class="keyword">this</span>.count++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  find(num: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parent[num] !== num) &#123;</span><br><span class="line">      <span class="keyword">this</span>.parent[num] = <span class="keyword">this</span>.find(<span class="keyword">this</span>.parent[num]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parent[num];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  union(x: <span class="built_in">number</span>, y: <span class="built_in">number</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> rootX = <span class="keyword">this</span>.find(x);</span><br><span class="line">    <span class="keyword">const</span> rootY = <span class="keyword">this</span>.find(y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rootX !== rootY) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.rank[rootX] &lt; <span class="keyword">this</span>.rank[rootY]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.parent[rootX] = rootY;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.rank[rootX] &gt; <span class="keyword">this</span>.rank[rootY]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.parent[rootY] = rootX;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// rank rootX 等于 rank rootY</span></span><br><span class="line">        <span class="keyword">this</span>.parent[rootX] = rootY;</span><br><span class="line">        <span class="keyword">this</span>.rank[rootY]++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.count--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;并查集&quot;&gt;&lt;a href=&quot;#并查集&quot; class=&quot;headerlink&quot; title=&quot;并查集&quot;&gt;&lt;/a&gt;并查集&lt;/h1&gt;&lt;p&gt;并查集一种数据结构，可以用一个 Class 来实现。可以把一组数据关联起来，然后统计数量。&lt;br&gt;可以用来解决岛屿数量的问题。&lt;/p</summary>
      
    
    
    
    
    <category term="算法与数据结构" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>省份数量和岛屿数量-两种DFS</title>
    <link href="http://yoursite.com/2021/03/13/%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F%E5%92%8C%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-%E4%B8%A4%E7%A7%8DDFS/"/>
    <id>http://yoursite.com/2021/03/13/%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F%E5%92%8C%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-%E4%B8%A4%E7%A7%8DDFS/</id>
    <published>2021-03-13T22:26:19.000Z</published>
    <updated>2021-10-24T03:40:44.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="省份数量和岛屿数量-两种-DFS"><a href="#省份数量和岛屿数量-两种-DFS" class="headerlink" title="省份数量和岛屿数量-两种 DFS"></a>省份数量和岛屿数量-两种 DFS</h1><h2 id="省份数量"><a href="#省份数量" class="headerlink" title="省份数量"></a>省份数量</h2><blockquote><p>计算省份数量，也可以是计算朋友圈的数量。从 1 到 n，一共有 n 个城市，他们的连接关系可以用一个二维数组来表示。</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isConnected = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// isConnected[i][j]=1 代表了i和j这两个连接，isConnected[i][j]=0则代表不直接连接。</span></span><br></pre></td></tr></table></figure><p>连接具有传递性。i-&gt;j 连接，j-&gt;k 连接，那么 i-&gt;k。<br>所有相连接的城市（朋友）构成了一个省份（朋友圈）。求所有省份的数量。</p><p>这里需要用到 DFS 去搜索，并且需要一个 visited 来记录哪些城市已经被访问过了。<br>遍历这 n 个城市，如果没有被 visited，省份就加 1。<br>比如搜索到了城市 i，那么就顺着把 i 这个链条都去访问一遍，并且记录在 visited 里面。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  isConnected: <span class="built_in">number</span>[][],</span></span></span><br><span class="line"><span class="function"><span class="params">  visited: <span class="built_in">boolean</span>[],</span></span></span><br><span class="line"><span class="function"><span class="params">  i: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  m: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (visited[i]) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  visited[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isConnected[i][j]) &#123;</span><br><span class="line">      dfs(isConnected, visited, j, m);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findCircleNum</span>(<span class="params">isConnected: <span class="built_in">number</span>[][]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isConnected.length || !isConnected[<span class="number">0</span>].length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> m = isConnected.length;</span><br><span class="line">  <span class="keyword">const</span> visited = <span class="built_in">Array</span>(m).fill(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">      count++;</span><br><span class="line">      dfs(isConnected, visited, i, m);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h2><p>使用二维矩阵代表一篇区域，如果 grid[i][j]为 1 代表陆地，如果 grid[i][j]为 0 代表海洋，所有连接的 1 构成一个岛屿，求岛屿的数量。</p><p>也是 dfs，遍历整个二维矩阵，如果当前是陆地，就 dfs 搜索这个点的周围区域，并且把周围区域标记为 0。需要向四个方向来进行 dfs。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bfs</span>(<span class="params">grid: <span class="built_in">string</span>[][], i: <span class="built_in">number</span>, j: <span class="built_in">number</span>, m: <span class="built_in">number</span>, n: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> queue = [[i, j]];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> [a, b] = queue.shift();</span><br><span class="line">    <span class="keyword">if</span> (grid[a][b] === <span class="string">"1"</span>) &#123;</span><br><span class="line">      grid[a][b] = <span class="string">"0"</span>;</span><br><span class="line">      <span class="keyword">if</span> (a - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[a - <span class="number">1</span>][b] === <span class="string">"1"</span>) queue.push([a - <span class="number">1</span>, b]);</span><br><span class="line">      <span class="keyword">if</span> (a + <span class="number">1</span> &lt; m &amp;&amp; grid[a + <span class="number">1</span>][b] === <span class="string">"1"</span>) queue.push([a + <span class="number">1</span>, b]);</span><br><span class="line">      <span class="keyword">if</span> (b - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[a][b - <span class="number">1</span>] === <span class="string">"1"</span>) queue.push([a, b - <span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">if</span> (b + <span class="number">1</span> &lt; n &amp;&amp; grid[a][b + <span class="number">1</span>] === <span class="string">"1"</span>) queue.push([a, b + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">grid: <span class="built_in">string</span>[][], i: <span class="built_in">number</span>, j: <span class="built_in">number</span>, m: <span class="built_in">number</span>, n: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || grid[i][j] == <span class="string">"0"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  grid[i][j] = <span class="string">"0"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dirs = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">-1</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [dx, dy] of dirs) &#123;</span><br><span class="line">    dfs(grid, dx + i, dy + j, m, n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numIslands</span>(<span class="params">grid: <span class="built_in">string</span>[][]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!grid.length || !grid[<span class="number">0</span>].length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> copy = grid.map(<span class="function">(<span class="params">item</span>) =&gt;</span> [...item]);</span><br><span class="line">  <span class="keyword">const</span> m = copy.length;</span><br><span class="line">  <span class="keyword">const</span> n = copy[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (copy[i][j] == <span class="string">"1"</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        dfs(copy, i, j, m, n);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ul><li>省份是沿着一个链接链条进行 dfs，并标记 visited</li><li>岛屿是沿着一个点，向四个方向进行 dfs，并将 grid 置为 0。<ul><li>也可以使用 bfs</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;省份数量和岛屿数量-两种-DFS&quot;&gt;&lt;a href=&quot;#省份数量和岛屿数量-两种-DFS&quot; class=&quot;headerlink&quot; title=&quot;省份数量和岛屿数量-两种 DFS&quot;&gt;&lt;/a&gt;省份数量和岛屿数量-两种 DFS&lt;/h1&gt;&lt;h2 id=&quot;省份数量&quot;&gt;&lt;a </summary>
      
    
    
    
    
    <category term="算法与数据结构" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-101-105-23-使用递归吧</title>
    <link href="http://yoursite.com/2021/01/14/leetcode-101-105-23-%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%90%A7/"/>
    <id>http://yoursite.com/2021/01/14/leetcode-101-105-23-%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%90%A7/</id>
    <published>2021-01-14T23:23:28.000Z</published>
    <updated>2021-10-24T03:40:44.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="101-105-23-使用递归吧"><a href="#101-105-23-使用递归吧" class="headerlink" title="101-105-23 使用递归吧"></a>101-105-23 使用递归吧</h1><ul><li>101 对称二叉树</li><li>105 根据中序遍历和先序遍历构造二叉树</li><li>23 合并 k 个升序链表</li></ul><p>这几个问题虽然情景各不一样，但是都可以使用递归的编程技巧来解决问题。</p><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101 对称二叉树"></a>101 对称二叉树</h2><h3 id="使用递归"><a href="#使用递归" class="headerlink" title="使用递归"></a>使用递归</h3><ol><li>使用两个指针 p 和 q，初始化都指向 root 节点。</li><li>判断 p.val===q.val，如果相等那么 p 和 q 同时移动，但是移动的方向是对称的，也就是 p 向左移动，那么 q 就要向右移动。</li><li>由于要比较和操作 p 和 q 两个指针，因此我们的函数也需要两个参数</li></ol><p>代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helper</span>(<span class="params">p: TreeNode | <span class="literal">null</span>, q: TreeNode | <span class="literal">null</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p.val !== q.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> inner = helper(p.left, q.right); <span class="comment">// 验证内对称</span></span><br><span class="line">  <span class="keyword">const</span> outer = helper(p.right, q.left); <span class="comment">// 验证外对称</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> inner &amp;&amp; outer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSymmetric</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> helper(root, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的为了验证对称性，内部调用了两次 helper，这也算是树的递归常见模式，针对不同的情况，分开递归调用。<br>其中 helper 还可以简写为如下形式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helper</span>(<span class="params">p: TreeNode | <span class="literal">null</span>, q: TreeNode | <span class="literal">null</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p.val === q.val &amp;&amp; helper(p.left, q.right) &amp;&amp; helper(p.right, q.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;101-105-23-使用递归吧&quot;&gt;&lt;a href=&quot;#101-105-23-使用递归吧&quot; class=&quot;headerlink&quot; title=&quot;101-105-23 使用递归吧&quot;&gt;&lt;/a&gt;101-105-23 使用递归吧&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;101 对称二叉树</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-71-简化路径</title>
    <link href="http://yoursite.com/2020/11/21/leetcode-71-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2020/11/21/leetcode-71-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/</id>
    <published>2020-11-21T22:57:38.000Z</published>
    <updated>2021-10-24T03:40:44.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="71-路径总和"><a href="#71-路径总和" class="headerlink" title="71 路径总和"></a>71 路径总和</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例 1：</p><p>输入：”/home/“<br>输出：”/home”<br>解释：注意，最后一个目录名后面没有斜杠。<br>示例 2：</p><p>输入：”/../“<br>输出：”/“<br>解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。<br>示例 3：</p><p>输入：”/home//foo/“<br>输出：”/home/foo”<br>解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。<br>示例 4：</p><p>输入：”/a/./b/../../c/“<br>输出：”/c”<br>示例 5：</p><p>输入：”/a/../../b/../c//.//“<br>输出：”/c”</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="Round-One"><a href="#Round-One" class="headerlink" title="Round One"></a>Round One</h3><p>一开始没有头绪，大概想到了依次读取字符串，然后利用栈。比如遇到<code>..</code>就 pop 一个元素。但是没有整理出完整的思路。</p><h3 id="Round-Two"><a href="#Round-Two" class="headerlink" title="Round Two"></a>Round Two</h3><p>不啰嗦，直接看 leetcode 上的 discussion 吧。果然人家的思路清晰又简单。</p><ul><li>使用’/‘将路径字符串分割为路径数组。准备一个栈</li><li>遍历数组<ul><li>遇到 ‘’ 直接 continue(分割了//)</li><li>遇到 ‘.’ 直接 continue(分割了/./)</li><li>遇到’..’ stack.pop() 需要返回上一级</li><li>遇到普通字符串 stack.push() 进入一级</li></ul></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simplifyPath</span>(<span class="params">path: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = path.split(<span class="string">"/"</span>);</span><br><span class="line">  <span class="keyword">const</span> stack: <span class="built_in">string</span>[] = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> str of arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="string">""</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str == <span class="string">"."</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str == <span class="string">".."</span>) &#123;</span><br><span class="line">      stack.pop();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      stack.push(str);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`/<span class="subst">$&#123;stack.join(<span class="string">"/"</span>)&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;71-路径总和&quot;&gt;&lt;a href=&quot;#71-路径总和&quot; class=&quot;headerlink&quot; title=&quot;71 路径总和&quot;&gt;&lt;/a&gt;71 路径总和&lt;/h1&gt;&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>浏览器登录态保存方案</title>
    <link href="http://yoursite.com/2020/11/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95%E6%80%81%E4%BF%9D%E5%AD%98%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2020/11/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95%E6%80%81%E4%BF%9D%E5%AD%98%E6%96%B9%E6%A1%88/</id>
    <published>2020-11-18T09:19:44.000Z</published>
    <updated>2021-10-24T03:40:44.659Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是-Cookie"><a href="#什么是-Cookie" class="headerlink" title="什么是 Cookie"></a>什么是 Cookie</h3><ul><li>Cookie 是由服务器发出，并由浏览器保存的一小块数据（大概 4kb 大小），浏览器再下一次请求同一个服务器时，会携带 cookie。</li><li>通过 cookie 可以使浏览器的访问变得有状态，但是由于数据只保存在浏览器中，因此状态是单向的，服务器无法验证。</li></ul><h3 id="什么是-session"><a href="#什么是-session" class="headerlink" title="什么是 session"></a>什么是 session</h3><ul><li>Session 是另一种记录服务器和浏览器会话状态的机制。Session 这种机制基于 Cookie 来实现</li><li>Session 的状态数据存储在服务器端，浏览器通过 Cookie 保存了一个 SessionId</li></ul><h4 id="Session-认证流程"><a href="#Session-认证流程" class="headerlink" title="Session 认证流程"></a>Session 认证流程</h4><ol><li>用户向服务器提交用户名和密码</li><li>服务器收到并验证成功后，生成一个 session（其实就是一段数据，比如包含 userId,userName 等）保存在内存或者数据库中</li><li>服务器返回给用户一个 session_id，写入用户的 cookie</li><li>用户后面的每一次访问，都会通过 Cookie 将 session_id 传回服务器</li><li>服务器收到 session_id 找到之前保存的数据，由此得知用户身份，继而执行操作</li><li>如果没有找到数据，则可以重定向至登陆页。</li></ol><h4 id="session-的问题"><a href="#session-的问题" class="headerlink" title="session 的问题"></a>session 的问题</h4><ul><li>如果是一个服务器集群，就需要共享 session 数据</li><li>如果 AB 网站需要单点登录共享登录态，也需要共享 session 数据</li></ul><h3 id="什么是-JWT-json-web-token"><a href="#什么是-JWT-json-web-token" class="headerlink" title="什么是 JWT json web token"></a>什么是 JWT json web token</h3><p>JWT 是另一种保存状态的方案，和 Session 的区别是，JWT 只需要浏览器保存就可以了，服务器不需要在维护 session 数据。<br>JWT 会在浏览器端保存哪些数据呢？其实还是类似 userId，userName 等数据。<br>但是直接保存明文数据肯定是不行的，需要保存加密之后的数据。</p><p>将数据加密成一个字符串。中间用<code>.</code>分割成 3 部分。分别为</p><ul><li><p>Header 头部<br>一个对象，描述 JWT 的元数据，也就是这个 JWT 是什么格式呀，用了什么加密算法（HS256）呀。比如<br><code>{ &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot; }</code><br>这个对象使用 Base64URL 算法转换成字符串</p></li><li><p>Payload 负载（数据）<br>也是一个对象保存各种数据。最后也是使用 Base64URL 算法转换成字符串</p></li><li><p>Signature 签名<br>签名的作用主要是验证 Header 和 Payload，防止它们被篡改，服务器会保存 Signature 的密钥，使用密钥对 Header 和 Payload 进行 SHA256 加密。<br>浏览器再次请求时，服务器通过密钥对 Header 和 Payload 解密，然后和 Signature 对比，验证数据是否被篡改。以及是否有效。</p></li></ul><p>最终组成 <code>Header.Payload.Signature</code>这样的一个字符串，类似于</p><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018072303.jpg" alt="JWT token"></p><p>客户端收到 JWT 后，可以保存在 cookie 里面，也可以保存在 localStorage 里面。<br>后面的请求时，可以随着 cookie 一起发送，但是会有跨域问题，所以也可以放在 Http 的 Header 里面。<br>例如：<code>Authorization: Bearer &lt;token&gt;</code></p><h4 id="JWT-的优点"><a href="#JWT-的优点" class="headerlink" title="JWT 的优点"></a>JWT 的优点</h4><ul><li>相比于 Session，JWT 不需要服务器在维护 session 数据了，全部的数据都放在了浏览器上。</li><li>但是验证的时候需要做解密的操作，牺牲了一定的 CPU 性能。</li></ul><h4 id="JWT-的缺点"><a href="#JWT-的缺点" class="headerlink" title="JWT 的缺点"></a>JWT 的缺点</h4><ul><li>一旦签发了某个 Token，服务器无法作废它，因为服务器只会验证它，除非还有额外的逻辑来处理。</li><li>由于不好作废它，那么一旦 Token 被盗用，就会一直有效，因此 token 的有效期最好不要太长。</li><li>应该使用 Https，保证 token 的安全性</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是-Cookie&quot;&gt;&lt;a href=&quot;#什么是-Cookie&quot; class=&quot;headerlink&quot; title=&quot;什么是 Cookie&quot;&gt;&lt;/a&gt;什么是 Cookie&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Cookie 是由服务器发出，并由浏览器保存的一小块数据（大概 4</summary>
      
    
    
    
    
    <category term="web开发" scheme="http://yoursite.com/tags/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 208 实现Trie树</title>
    <link href="http://yoursite.com/2020/11/15/leetcode-208-%E5%AE%9E%E7%8E%B0Trie%E6%A0%91/"/>
    <id>http://yoursite.com/2020/11/15/leetcode-208-%E5%AE%9E%E7%8E%B0Trie%E6%A0%91/</id>
    <published>2020-11-15T11:35:35.000Z</published>
    <updated>2021-10-24T03:40:44.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="208-实现前缀树"><a href="#208-实现前缀树" class="headerlink" title="208 实现前缀树"></a>208 实现前缀树</h1><p>前缀树其实就是字典树，实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Trie trie = <span class="keyword">new</span> Trie();</span><br><span class="line">trie.insert(<span class="string">"apple"</span>);</span><br><span class="line">trie.search(<span class="string">"apple"</span>);   <span class="comment">// 返回 true</span></span><br><span class="line">trie.search(<span class="string">"app"</span>);     <span class="comment">// 返回 false</span></span><br><span class="line">trie.startsWith(<span class="string">"app"</span>); <span class="comment">// 返回 true</span></span><br><span class="line">trie.insert(<span class="string">"app"</span>);</span><br><span class="line">trie.search(<span class="string">"app"</span>);     <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>这个数据结构直接看的极客时间上的课程学来的。但是使用数组来存储 children 的方式确实不错，主要字符集数量有限（26 个英文字母），如果是更大的字符集，使用 map 来存储也不错。</p><blockquote><p>可以用来解决路由表的最长前缀匹配问题，可以使用 trie 树来加快搜索匹配的速度。</p></blockquote><h3 id="Round-One"><a href="#Round-One" class="headerlink" title="Round One"></a>Round One</h3><ol><li>trie 树主要支持两个操作<ol><li>insert - 插入的过程，就是构建这个树的过程，需要动态的创建 children</li><li>search - 搜索的过程，需要验证单词是否完全匹配，因此节点上需要一个 isEndOfWord 的标记</li><li>starsWith - 验证是否是一个合格的前缀，简化版的 search</li></ol></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="children-是数组"><a href="#children-是数组" class="headerlink" title="children 是数组"></a>children 是数组</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> TrieNode &#123;</span><br><span class="line">  char: <span class="built_in">string</span>;</span><br><span class="line">  isEndOfWord: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">  children: TrieNode[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">char: <span class="built_in">string</span> = ""</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.char = char;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Trie &#123;</span><br><span class="line">  root: TrieNode;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  insert(word: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> char of word) &#123;</span><br><span class="line">      <span class="keyword">const</span> index = char.charCodeAt(<span class="number">0</span>) - <span class="number">97</span>;</span><br><span class="line">      <span class="keyword">if</span> (!node.children[index]) &#123;</span><br><span class="line">        <span class="comment">// 当前字符不再children中，需要创建</span></span><br><span class="line">        node.children[index] = <span class="keyword">new</span> TrieNode(char);</span><br><span class="line">      &#125;</span><br><span class="line">      node = node.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    node.isEndOfWord = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  search(word: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> char of word) &#123;</span><br><span class="line">      <span class="keyword">const</span> index = char.charCodeAt(<span class="number">0</span>) - <span class="number">97</span>;</span><br><span class="line">      <span class="keyword">if</span> (!node.children[index]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      node = node.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.isEndOfWord;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  startsWith(word: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> char of word) &#123;</span><br><span class="line">      <span class="keyword">const</span> index = char.charCodeAt(<span class="number">0</span>) - <span class="number">97</span>;</span><br><span class="line">      <span class="keyword">if</span> (!node.children[index]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      node = node.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="children-是-map"><a href="#children-是-map" class="headerlink" title="children 是 map"></a>children 是 map</h3><p>map 的方法在 leetcode 上更快，应该是因为数组方法里面 charCodeAt 比较耗时吧。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> TrieNode &#123;</span><br><span class="line">    char: <span class="built_in">string</span>;</span><br><span class="line">    isEndOfWord: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">    children: Map&lt;<span class="built_in">string</span>,TrieNode&gt; = <span class="keyword">new</span> Map()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">char:<span class="built_in">string</span> = ''</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.char = char;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Trie &#123;</span><br><span class="line">    root: TrieNode = <span class="keyword">new</span> TrieNode();</span><br><span class="line"></span><br><span class="line">    insert(word: <span class="built_in">string</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">this</span>.root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> char of word)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!node.children.has(char))&#123;</span><br><span class="line">                node.children.set(char, <span class="keyword">new</span> TrieNode(char));</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children.get(char);</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEndOfWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    search(word: <span class="built_in">string</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">this</span>.root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> char of word)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!node.children.has(char))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children.get(char);</span><br><span class="line">        &#125;</span><br><span class="line">        retur node.isEndOfWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    startsWith(word: <span class="built_in">string</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = <span class="keyword">this</span>.root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> char of word)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!node.children.has(char))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children.get(char);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;208-实现前缀树&quot;&gt;&lt;a href=&quot;#208-实现前缀树&quot; class=&quot;headerlink&quot; title=&quot;208 实现前缀树&quot;&gt;&lt;/a&gt;208 实现前缀树&lt;/h1&gt;&lt;p&gt;前缀树其实就是字典树，实现一个 Trie (前缀树)，包含 insert, sear</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
    <category term="算法与数据结构" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
