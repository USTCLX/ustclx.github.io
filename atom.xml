<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>herrycodelee blog</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-02-06T04:09:36.889Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Xiang Li</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ReactNode ReactElement ReactNode和Component</title>
    <link href="http://yoursite.com/2022/02/06/ReactElement-ReactNode%E5%92%8CComponent/"/>
    <id>http://yoursite.com/2022/02/06/ReactElement-ReactNode%E5%92%8CComponent/</id>
    <published>2022-02-06T11:18:45.000Z</published>
    <updated>2022-02-06T04:09:36.889Z</updated>
    
    <content type="html"><![CDATA[<p>本文尝试分析一下，ReactNode ReactElement 和 Component 之间的关系和区别。</p><h2 id="ReactNode"><a href="#ReactNode" class="headerlink" title="ReactNode"></a>ReactNode</h2><p><code>ReactNode</code>是一种 typescript 的类型。在使用 antd 这样的组件库的时候，可以看到某些 prop 的类型是<code>ReactNode</code>，比如<code>PageHeader</code>组件的 extra 属性的类型就是<code>ReactNode</code>。</p><p>使用 vscode 的代码追踪，可以进入到<code>@types/react</code>这个包，查看<code>ReactNode</code>的类型定义如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReactNode</span> =</span><br><span class="line">  | <span class="title class_">ReactChild</span></span><br><span class="line">  | <span class="title class_">ReactFragment</span></span><br><span class="line">  | <span class="title class_">ReactPortal</span></span><br><span class="line">  | <span class="built_in">boolean</span></span><br><span class="line">  | <span class="literal">null</span></span><br><span class="line">  | <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><p>可以发现，<code>ReactNode</code>是一个联合类型。比较符合我们平时写代码时的直觉。</p><p>其中的<code>ReactChild</code>可以继续跟踪，它的类型定义如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReactText</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReactChild</span> = <span class="title class_">ReactElement</span> | <span class="title class_">ReactText</span>;</span><br></pre></td></tr></table></figure><p>可以发现<code>ReactChild</code>也是一个联合类型，其中一个类型就是<code>ReactElement</code>。因此可以发现，<code>ReactNode</code> 包含了<code>ReactElement</code>。</p><h2 id="ReactElement"><a href="#ReactElement" class="headerlink" title="ReactElement"></a>ReactElement</h2><p><code>ReactElement</code>也是一种 typescript 类型。通常，我们在使用 typescript 书写<code>Function Component</code>的时候，如果加上了返回类型，会像这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>): <span class="variable constant_">JSX</span>.<span class="property">Element</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>App<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>追踪<code>JSX.Element</code>可以看到</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123;</span><br><span class="line">  <span class="keyword">namespace</span> JSX &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Element</span> <span class="keyword">extends</span> <span class="title class_">React</span>.<span class="title class_">ReactElement</span>&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt; &#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以<code>JSX.Element</code>就是继承自<code>ReactElement</code>。查看<code>ReactElement</code>的类型定义如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ReactElement</span>&lt;</span><br><span class="line">  P = <span class="built_in">any</span>,</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="title class_">JSXElementConstructor</span>&lt;<span class="built_in">any</span>&gt; =</span><br><span class="line">    | <span class="built_in">string</span></span><br><span class="line">    | <span class="title class_">JSXElementConstructor</span>&lt;<span class="built_in">any</span>&gt;</span><br><span class="line">&gt; &#123;</span><br><span class="line">  <span class="attr">type</span>: T;</span><br><span class="line">  <span class="attr">props</span>: P;</span><br><span class="line">  <span class="attr">key</span>: <span class="title class_">Key</span> | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以本质上<code>ReactElement</code>就是一个对象,包含三个属性<code>type</code>,<code>props</code>,<code>key</code>。</p><p>其中最特别的就是<code>type</code>这个属性，它是一个范型，可以是<code>string</code>或者<code>JSXElementConstructor</code>。<br>多说一句，type 如果是<code>string</code>，那么它可能就是类似于<code>div</code>这样的字符串，代表 HTML 的原生标签。再来看<code>JSXElementConstructor</code>，它的定义如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">JSXElementConstructor</span>&lt;P&gt; =</span><br><span class="line">  | (<span class="function">(<span class="params">props: P</span>) =&gt;</span> <span class="title class_">ReactElement</span>&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt; | <span class="literal">null</span>)</span><br><span class="line">  | (<span class="keyword">new</span> (<span class="attr">props</span>: P) =&gt; <span class="title class_">Component</span>&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt;);</span><br></pre></td></tr></table></figure><p>这也是一个联合类型，一个是函数，返回<code>ReactElement</code>。一个类，可以实例化为一个<code>Component</code>，也就是一个类组件。</p><p>其实<code>ReactElement</code>这个类型，就是代表了 React 中<a href="https://reactjs.org/docs/glossary.html#elements">Element</a>这个概念。官方解释如下：</p><blockquote><p>React elements are the building blocks of React applications. One might confuse elements with a more widely known concept of “components”. An element describes what you want to see on the screen. React elements are immutable.Typically, elements are not used directly, but get returned from components.</p></blockquote><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><p>这里直接引用 <a href="https://reactjs.org/docs/glossary.html#components">React 的官方文档</a></p><blockquote><p>React components are small, reusable pieces of code that return a React element to be rendered to the page. The simplest version of React component is a plain JavaScript function that returns a React element:</p></blockquote><p>只看函数组件，简而言之，函数组件就是可以返回一个<code>ReactElement</code>的函数。</p><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>我们平时书写<code>Element</code>使用的是 JSX 语法，但是这种含有标签的语法（比如 <code>&lt;h1&gt;Hello, world&lt;h1&gt;</code>）并不是 js 语法的一部分。因此我们熟悉的 JSX 语句会被编译为标准的 js 代码。</p><blockquote><p>JSX is a syntax extension to JavaScript. It is similar to a template language, but it has full power of JavaScript. JSX gets compiled to React.createElement() calls which return plain JavaScript objects called “React elements”. To get a basic introduction to JSX see the docs here and find a more in-depth tutorial on JSX here.</p></blockquote><p>使用 <a href="https://babeljs.io/repl/">Babel</a> 可以让我们看到 JSX 编译后的代码。如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Button</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Button</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="comment">/*#__PURE__*/</span> <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;button&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;click&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="comment">/*#__PURE__*/</span> <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">    <span class="string">&quot;div&quot;</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">/*#__PURE__*/</span> <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;h1&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Hello World&quot;</span>),</span><br><span class="line">    <span class="comment">/*#__PURE__*/</span> <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="title class_">Button</span>, <span class="literal">null</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文尝试分析一下，ReactNode ReactElement 和 Component 之间的关系和区别。&lt;/p&gt;
&lt;h2 id=&quot;ReactNode&quot;&gt;&lt;a href=&quot;#ReactNode&quot; class=&quot;headerlink&quot; title=&quot;ReactNode&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>精读《Airbnb CSS / Sass Styleguide》</title>
    <link href="http://yoursite.com/2022/02/05/%E7%B2%BE%E8%AF%BB%E3%80%8AAirbnb-CSS-Sass-Styleguide%E3%80%8B/"/>
    <id>http://yoursite.com/2022/02/05/%E7%B2%BE%E8%AF%BB%E3%80%8AAirbnb-CSS-Sass-Styleguide%E3%80%8B/</id>
    <published>2022-02-05T14:57:34.000Z</published>
    <updated>2022-02-06T04:09:36.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="精读《Airbnb-CSS-x2F-Sass-Styleguide》"><a href="#精读《Airbnb-CSS-x2F-Sass-Styleguide》" class="headerlink" title="精读《Airbnb CSS &#x2F; Sass Styleguide》"></a>精读《Airbnb CSS &#x2F; Sass Styleguide》</h1><h2 id="Formatting"><a href="#Formatting" class="headerlink" title="Formatting"></a>Formatting</h2><ul><li>Prefer dashes over camelCasing in class names.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- bad --&gt;</span><br><span class="line">.avatar&#123;</span><br><span class="line">    border-radius:50%;</span><br><span class="line">    border:2px solid white; &#125;</span><br><span class="line">.no, .nope, .not_good &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">#lol-no &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- good --&gt;</span><br><span class="line">.avatar &#123;</span><br><span class="line">  border-radius: 50%;</span><br><span class="line">  border: 2px solid white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.one,</span><br><span class="line">.selector,</span><br><span class="line">.per-line &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h2><p><strong>BEM</strong>, or “Block-Element-Modifier”, is a naming convention for classes in HTML and CSS. It was originally developed by Yandex with large codebases and scalability in mind, and can serve as a solid set of guidelines for implementing OOCSS.</p><h2 id="Border"><a href="#Border" class="headerlink" title="Border"></a>Border</h2><p>Use 0 instead of none to specify that a style has no border.</p><h2 id="SASS"><a href="#SASS" class="headerlink" title="SASS"></a>SASS</h2><h3 id="Ordering-of-property-declarations"><a href="#Ordering-of-property-declarations" class="headerlink" title="Ordering of property declarations"></a>Ordering of property declarations</h3><h4 id="1-Property-declarations"><a href="#1-Property-declarations" class="headerlink" title="1. Property declarations"></a>1. Property declarations</h4><p>List all standard property declarations, anything that isn’t an @include or a nested selector.</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn-green</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-include-declarations"><a href="#2-include-declarations" class="headerlink" title="2. @include declarations"></a>2. <code>@include</code> declarations</h4><p>Grouping @includes at the end makes it easier to read the entire selector.</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn-green</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="keyword">@include</span> transition(background <span class="number">0.5s</span> ease);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Nested-selectors"><a href="#3-Nested-selectors" class="headerlink" title="3. Nested selectors"></a>3. Nested selectors</h4><p>Nested selectors, if necessary, go last, and nothing goes after them. Add whitespace between your rule declarations and nested selectors, as well as between adjacent nested selectors. Apply the same guidelines as above to your nested selectors.</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="keyword">@include</span> transition(background <span class="number">0.5s</span> ease);</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.icon</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h3><p>Prefer dash-cased variable names (e.g. $my-variable) over camelCased or snake_cased variable names. It is acceptable to prefix variable names that are intended to be used only within the same file with an underscore (e.g. $_my-variable).</p><h3 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h3><p>Mixins should be used to DRY up your code, add clarity, or abstract complexity–in much the same way as well-named functions. Mixins that accept no arguments can be useful for this, but note that if you are not compressing your payload (e.g. gzip), this may contribute to unnecessary code duplication in the resulting styles.</p><h3 id="Extend-directive"><a href="#Extend-directive" class="headerlink" title="Extend directive"></a>Extend directive</h3><p>@extend should be avoided because it has unintuitive and potentially dangerous behavior, especially when used with nested selectors. Even extending top-level placeholder selectors can cause problems if the order of selectors ends up changing later (e.g. if they are in other files and the order the files are loaded shifts). Gzipping should handle most of the savings you would have gained by using @extend, and you can DRY up your stylesheets nicely with mixins.</p><h3 id="Nested-selectors"><a href="#Nested-selectors" class="headerlink" title="Nested selectors"></a>Nested selectors</h3><p>Do not nest selectors more than three levels deep!</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.page-container</span> &#123;</span><br><span class="line">  <span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="selector-class">.profile</span> &#123;</span><br><span class="line">      <span class="comment">// STOP!</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When selectors become this long, you’re likely writing CSS that is:</p><ul><li>Strongly coupled to the HTML (fragile) —OR—</li><li>Overly specific (powerful) —OR—</li><li>Not reusable</li></ul><p><strong>Again: never nest ID selectors!</strong></p><p>If you must use an ID selector in the first place (and you should really try not to), they should never be nested. If you find yourself doing this, you need to revisit your markup, or figure out why such strong specificity is needed. If you are writing well formed HTML and CSS, you should never need to do this.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;精读《Airbnb-CSS-x2F-Sass-Styleguide》&quot;&gt;&lt;a href=&quot;#精读《Airbnb-CSS-x2F-Sass-Styleguide》&quot; class=&quot;headerlink&quot; title=&quot;精读《Airbnb CSS &amp;#x2F; Sas</summary>
      
    
    
    
    
    <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
    <category term="sass" scheme="http://yoursite.com/tags/sass/"/>
    
    <category term="style guide" scheme="http://yoursite.com/tags/style-guide/"/>
    
  </entry>
  
  <entry>
    <title>精读《Airbnb JavaScript Style Guide》</title>
    <link href="http://yoursite.com/2022/02/04/%E7%B2%BE%E8%AF%BB%E3%80%8AAirbnb-JavaScript-Style-Guide%E3%80%8B/"/>
    <id>http://yoursite.com/2022/02/04/%E7%B2%BE%E8%AF%BB%E3%80%8AAirbnb-JavaScript-Style-Guide%E3%80%8B/</id>
    <published>2022-02-04T17:42:14.000Z</published>
    <updated>2022-02-06T04:09:36.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="精读《Airbnb-JavaScript-Style-Guide》"><a href="#精读《Airbnb-JavaScript-Style-Guide》" class="headerlink" title="精读《Airbnb JavaScript Style Guide》"></a>精读《Airbnb JavaScript Style Guide》</h1><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><ul><li>To convert an iterable object to an array, use spreads … instead of Array.from.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;.foo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> nodes = <span class="title class_">Array</span>.<span class="title function_">from</span>(foo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// best</span></span><br><span class="line"><span class="keyword">const</span> nodes = [...foo];</span><br></pre></td></tr></table></figure><ul><li>Use Array.from for converting an array-like object to an array.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrLike = &#123; <span class="number">0</span>: <span class="string">&quot;foo&quot;</span>, <span class="number">1</span>: <span class="string">&quot;bar&quot;</span>, <span class="number">2</span>: <span class="string">&quot;baz&quot;</span>, <span class="attr">length</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(arrLike);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(arrLike);</span><br></pre></td></tr></table></figure><ul><li>Use Array.from instead of spread … for mapping over iterables, because it avoids creating an intermediate array.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> baz = [...foo].<span class="title function_">map</span>(bar);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> baz = <span class="title class_">Array</span>.<span class="title function_">from</span>(foo, bar);</span><br></pre></td></tr></table></figure><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><ul><li>Use exponentiation operator ** when calculating exponentiations. eslint: no-restricted-properties</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> binary = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> binary = <span class="number">2</span> ** <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h2 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h2><ul><li>Group all your consts and then group all your lets.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> i,</span><br><span class="line">  len,</span><br><span class="line">  dragonball,</span><br><span class="line">  items = <span class="title function_">getItems</span>(),</span><br><span class="line">  goSportsTeam = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> i;</span><br><span class="line"><span class="keyword">const</span> items = <span class="title function_">getItems</span>();</span><br><span class="line"><span class="keyword">let</span> dragonball;</span><br><span class="line"><span class="keyword">const</span> goSportsTeam = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> len;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> goSportsTeam = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> items = <span class="title function_">getItems</span>();</span><br><span class="line"><span class="keyword">let</span> dragonball;</span><br><span class="line"><span class="keyword">let</span> i;</span><br><span class="line"><span class="keyword">let</span> length;</span><br></pre></td></tr></table></figure><h2 id="Type-Casting-amp-Coercion"><a href="#Type-Casting-amp-Coercion" class="headerlink" title="Type Casting &amp; Coercion"></a>Type Casting &amp; Coercion</h2><ul><li>Strings: eslint: no-new-wrappers</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// =&gt; this.reviewScore = 9;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> totalScore = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="variable language_">this</span>.<span class="property">reviewScore</span>); <span class="comment">// typeof totalScore is &quot;object&quot; not &quot;string&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> totalScore = <span class="variable language_">this</span>.<span class="property">reviewScore</span> + <span class="string">&quot;&quot;</span>; <span class="comment">// invokes this.reviewScore.valueOf()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> totalScore = <span class="variable language_">this</span>.<span class="property">reviewScore</span>.<span class="title function_">toString</span>(); <span class="comment">// isn’t guaranteed to return a string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> totalScore = <span class="title class_">String</span>(<span class="variable language_">this</span>.<span class="property">reviewScore</span>);</span><br></pre></td></tr></table></figure><ul><li>Numbers: Use Number for type casting and parseInt always with a radix for parsing strings. eslint: radix no-new-wrappers</li></ul><blockquote><p>Why? The parseInt function produces an integer value dictated by interpretation of the contents of the string argument according to the specified radix. Leading whitespace in string is ignored. If radix is undefined or 0, it is assumed to be 10 except when the number begins with the character pairs 0x or 0X, in which case a radix of 16 is assumed. This differs from ECMAScript 3, which merely discouraged (but allowed) octal interpretation. Many implementations have not adopted this behavior as of 2013. And, because older browsers must be supported, always specify a radix.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inputValue = <span class="string">&quot;4&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> val = <span class="keyword">new</span> <span class="title class_">Number</span>(inputValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> val = +inputValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> val = inputValue &gt;&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> val = <span class="built_in">parseInt</span>(inputValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> val = <span class="title class_">Number</span>(inputValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> val = <span class="built_in">parseInt</span>(inputValue, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><ul><li>If for whatever reason you are doing something wild and parseInt is your bottleneck and need to use Bitshift for performance reasons, leave a comment explaining why and what you’re doing.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * parseInt was the reason my code was slow.</span></span><br><span class="line"><span class="comment"> * Bitshifting the String to coerce it to a</span></span><br><span class="line"><span class="comment"> * Number made it a lot faster.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> val = inputValue &gt;&gt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ul><li>Booleans</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> hasAge = <span class="keyword">new</span> <span class="title class_">Boolean</span>(age);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> hasAge = <span class="title class_">Boolean</span>(age);</span><br><span class="line"></span><br><span class="line"><span class="comment">// best</span></span><br><span class="line"><span class="keyword">const</span> hasAge = !!age;</span><br></pre></td></tr></table></figure><h2 id="Naming-Conventions"><a href="#Naming-Conventions" class="headerlink" title="Naming Conventions"></a>Naming Conventions</h2><ul><li>Don’t save references to this. Use arrow functions or Function#bind.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(self);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> that = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(that);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>You may optionally uppercase a constant only if it (1) is exported, (2) is a const (it can not be reassigned), and (3) the programmer can trust it (and its nested properties) to never change.<ul><li>What about all const variables? - This is unnecessary, so uppercasing should not be used for constants within a file. It should be used for exported constants however.</li><li>What about exported objects? - Uppercase at the top level of export (e.g. EXPORTED_OBJECT.key) and maintain that all nested properties do not change.</li></ul></li></ul><blockquote><p>Why? This is an additional tool to assist in situations where the programmer would be unsure if a variable might ever change. UPPERCASE_VARIABLES are letting the programmer know that they can trust the variable (and its properties) not to change.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PRIVATE_VARIABLE</span> = <span class="string">&quot;should not be unnecessarily uppercased within a file&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">THING_TO_BE_CHANGED</span> = <span class="string">&quot;should obviously not be uppercased&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> <span class="variable constant_">REASSIGNABLE_VARIABLE</span> = <span class="string">&quot;do not use let with uppercase variables&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// allowed but does not supply semantic value</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> apiKey = <span class="string">&quot;SOMEKEY&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// better in most cases</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">API_KEY</span> = <span class="string">&quot;SOMEKEY&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bad - unnecessarily uppercases key while adding no semantic value</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">MAPPING</span> = &#123;</span><br><span class="line">  <span class="attr">KEY</span>: <span class="string">&quot;value&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">MAPPING</span> = &#123;</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&quot;value&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;精读《Airbnb-JavaScript-Style-Guide》&quot;&gt;&lt;a href=&quot;#精读《Airbnb-JavaScript-Style-Guide》&quot; class=&quot;headerlink&quot; title=&quot;精读《Airbnb JavaScript Style</summary>
      
    
    
    
    
    <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>vscode extension 开发debug时卡在building的原因和解决</title>
    <link href="http://yoursite.com/2021/11/06/vscode%20extension%20%E5%BC%80%E5%8F%91debug%E6%97%B6%E5%8D%A1%E5%9C%A8building%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2021/11/06/vscode%20extension%20%E5%BC%80%E5%8F%91debug%E6%97%B6%E5%8D%A1%E5%9C%A8building%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3/</id>
    <published>2021-11-06T12:28:36.000Z</published>
    <updated>2022-02-06T04:09:36.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在开发一款 vscode 插件，遇到了一个问题。特此记录。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ol><li>使用 vscode extension 官方的 cli 生成项目模版</li><li>开始 debugger 开发，一切正常，按 F5 自动弹出一个新的 vscode</li><li>升级项目中使用的 webpack 版本</li><li>使用 debugger 开发，按 F5 不会在自动弹出新的 vscode，卡在了 build 阶段，如下图</li></ol><p><img src="/images/vscode_extension.png" alt="vscode_extension_debug_problem"></p><h2 id="问题原因和解决"><a href="#问题原因和解决" class="headerlink" title="问题原因和解决"></a>问题原因和解决</h2><p>在 google 了很久之后，总算确定了问题的原因 😳。</p><p>vscode extension 在 debug 的 watch 模式下，会监听控制台 webpack 的输出。上图的截图，控制台中显示的家就是 webpack 的输出。<br>然后在项目的 task.json 中的 endsPattern 字段，会去匹配这个输出的字符串，如果匹配上了，就认为构建 ok 了，然后弹出一个新的 vscode。</p><p>问题的根据就在于升级 webpack 之后，webpack 的输出变了，因此需要重写一下。如下图。</p><p><img src="/images/vscode_extension_fix.png" alt="vscode_extension_debug_fix"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在开发一款 vscode 插件，遇到了一个问题。特此记录。&lt;/p&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; clas</summary>
      
    
    
    
    
    <category term="vscode extension" scheme="http://yoursite.com/tags/vscode-extension/"/>
    
  </entry>
  
  <entry>
    <title>TrieTree在前端TreeSelect中的应用</title>
    <link href="http://yoursite.com/2021/10/26/TrieTree%E5%9C%A8%E5%89%8D%E7%AB%AFTreeSelector%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2021/10/26/TrieTree%E5%9C%A8%E5%89%8D%E7%AB%AFTreeSelector%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2021-10-26T03:32:52.000Z</published>
    <updated>2022-02-06T04:09:36.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TreeSelect"><a href="#TreeSelect" class="headerlink" title="TreeSelect"></a>TreeSelect</h2><p>Antd 作为最有最优秀的 React 开源组件库之一，被广泛的使用。最近笔者在工作中使用<code>TreeSelect</code>组件。它的使用非常简单，可以接收下面这样的数据结构，来生成一个<a href="https://ant.design/components/tree-select-cn/">树型选择器</a>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> treeData = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;Node1&quot;</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;0-0&quot;</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&quot;Child Node1&quot;</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&quot;0-0-1&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&quot;Child Node2&quot;</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&quot;0-0-2&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;Node2&quot;</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;0-1&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>比如后端吐出给前端的数据如下。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rawData = [<span class="string">&quot;a.bb&quot;</span>, <span class="string">&quot;a.cc&quot;</span>, <span class="string">&quot;a.dd.eee&quot;</span>, <span class="string">&quot;h.ff.llll&quot;</span>];</span><br></pre></td></tr></table></figure><p>要求根据<code>.</code>作为分层级隔符，将数据展示为树形选择器。因此需要将数据转为如下形式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> treeData = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&quot;a.*&quot;</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&quot;bb&quot;</span>,</span><br><span class="line">            <span class="attr">value</span>: <span class="string">&quot;a.bb&quot;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">            <span class="attr">value</span>: <span class="string">&quot;a.cc&quot;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&quot;dd&quot;</span>,</span><br><span class="line">            <span class="attr">value</span>: <span class="string">&quot;a.dd.*&quot;</span>,</span><br><span class="line">            <span class="attr">children</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">title</span>: <span class="string">&quot;eee&quot;</span>,</span><br><span class="line">                <span class="attr">value</span>: <span class="string">&quot;a.dd.eee&quot;</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            ],</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&quot;h&quot;</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&quot;h.*&quot;</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&quot;ff&quot;</span>,</span><br><span class="line">            <span class="attr">value</span>: <span class="string">&quot;h.ff.*&quot;</span>,</span><br><span class="line">            <span class="attr">children</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">title</span>: <span class="string">&quot;llll&quot;</span>,</span><br><span class="line">                <span class="attr">value</span>: <span class="string">&quot;h.ff.llll&quot;</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            ],</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="前缀树（字典树）"><a href="#前缀树（字典树）" class="headerlink" title="前缀树（字典树）"></a>前缀树（字典树）</h2><p>关于前缀树的文章可以参考<a href="https://ustclx.github.io/2020/11/15/leetcode-208-%E5%AE%9E%E7%8E%B0Trie%E6%A0%91/">leetcode 208 实现 Trie 树</a>。</p><p>这种 case，根据共同的前缀，层层递进形成的数据结构，正是前缀树的应用场景了。那么我们如何将<code>rawData</code> 转换为<code>treeData</code>呢？笔者给了一个自己实现，如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">TreeData</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">string</span>;</span><br><span class="line">  children?: <span class="title class_">TreeData</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> value: <span class="built_in">string</span> = <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> path: <span class="built_in">string</span> = <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> isLeaf: <span class="built_in">boolean</span> = <span class="literal">false</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> isRoot: <span class="built_in">boolean</span> = <span class="literal">false</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> children: TrieNode[]</span></span><br><span class="line"><span class="params">  </span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">TrieTree</span> &#123;</span><br><span class="line">  <span class="attr">root</span>: <span class="title class_">TrieNode</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">data: <span class="built_in">string</span>[] = []</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="keyword">new</span> <span class="title class_">TrieNode</span>(<span class="string">&quot;*&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="literal">false</span>, <span class="literal">true</span>, []);</span><br><span class="line"></span><br><span class="line">    data.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">insert</span>(item.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">findNode</span>(<span class="params">node: TrieNode, key: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!node || !node.<span class="property">children</span>?.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node.<span class="property">children</span>.<span class="title function_">find</span>(<span class="function">(<span class="params">child</span>) =&gt;</span> child.<span class="property">value</span> === key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">insert</span>(<span class="params">keys: <span class="built_in">string</span>[]</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">const</span> paths = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> keys) &#123;</span><br><span class="line">      paths.<span class="title function_">push</span>(key);</span><br><span class="line">      <span class="keyword">let</span> child = <span class="variable language_">this</span>.<span class="title function_">findNode</span>(node, key);</span><br><span class="line">      <span class="keyword">if</span> (!child) &#123;</span><br><span class="line">        child = <span class="keyword">new</span> <span class="title class_">TrieNode</span>(key, paths.<span class="title function_">join</span>(<span class="string">&quot;.&quot;</span>), <span class="literal">false</span>, <span class="literal">false</span>, []);</span><br><span class="line">        node.<span class="property">children</span>.<span class="title function_">push</span>(child);</span><br><span class="line">      &#125;</span><br><span class="line">      node = child;</span><br><span class="line">    &#125;</span><br><span class="line">    node.<span class="property">isLeaf</span> = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">treeData</span>: <span class="title class_">TreeData</span>[] = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">node: TrieNode, treeData: TreeData[]</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="attr">data</span>: <span class="title class_">TreeData</span> = &#123;</span><br><span class="line">        <span class="attr">title</span>: node.<span class="property">value</span>,</span><br><span class="line">        <span class="attr">value</span>: node.<span class="property">isRoot</span></span><br><span class="line">          ? node.<span class="property">value</span></span><br><span class="line">          : node.<span class="property">isLeaf</span></span><br><span class="line">          ? node.<span class="property">path</span></span><br><span class="line">          : node.<span class="property">path</span> + <span class="string">&quot;.*&quot;</span>,</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">children</span>?.<span class="property">length</span>) data.<span class="property">children</span> = [];</span><br><span class="line"></span><br><span class="line">      treeData.<span class="title function_">push</span>(data);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> child <span class="keyword">of</span> node.<span class="property">children</span>) &#123;</span><br><span class="line">        <span class="title function_">dfs</span>(child, data.<span class="property">children</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">dfs</span>(<span class="variable language_">this</span>.<span class="property">root</span>, treeData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> treeData;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结合-Antd-来使用"><a href="#结合-Antd-来使用" class="headerlink" title="结合 Antd 来使用"></a>结合 Antd 来使用</h2><p><a href="https://codesandbox.io/s/quizzical-yonath-sbrns">codesandbox</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TreeSelect&quot;&gt;&lt;a href=&quot;#TreeSelect&quot; class=&quot;headerlink&quot; title=&quot;TreeSelect&quot;&gt;&lt;/a&gt;TreeSelect&lt;/h2&gt;&lt;p&gt;Antd 作为最有最优秀的 React 开源组件库之一，被广泛的使用。最近笔</summary>
      
    
    
    
    
    <category term="算法与数据结构" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="前端开发中的算法" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>英语语法整理</title>
    <link href="http://yoursite.com/2021/10/24/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2021/10/24/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86/</id>
    <published>2021-10-24T12:12:14.000Z</published>
    <updated>2022-02-06T04:09:36.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单句语法"><a href="#简单句语法" class="headerlink" title="简单句语法"></a>简单句语法</h2><p>一般英语句子的结构，可以总结为<code>主语+谓语+（东西）</code>。</p><ul><li>主语：人或者物品</li><li>谓语：动作</li></ul><h3 id="主语-谓语"><a href="#主语-谓语" class="headerlink" title="主语+谓语"></a>主语+谓语</h3><ul><li>I swim</li></ul><p>swim 是不及物动词</p><h3 id="主语-谓语-宾语"><a href="#主语-谓语-宾语" class="headerlink" title="主语+谓语+宾语"></a>主语+谓语+宾语</h3><ul><li>I like her</li></ul><p>like 是及物动词</p><h3 id="主语-谓语-间接宾语-直接宾语-双宾"><a href="#主语-谓语-间接宾语-直接宾语-双宾" class="headerlink" title="主语+谓语+间接宾语+直接宾语 (双宾)"></a>主语+谓语+间接宾语+直接宾语 (双宾)</h3><p>谓语后面跟着两个动作的承受者。</p><ul><li>Dabai teaches you English</li></ul><h3 id="主语-谓语-宾语-宾语补充"><a href="#主语-谓语-宾语-宾语补充" class="headerlink" title="主语+谓语+宾语+宾语补充"></a>主语+谓语+宾语+宾语补充</h3><p>谓语后面跟着一个动作的承受者和他的补充说明。</p><ul><li>Dabai makes you happy</li></ul><h3 id="主语-系动词-表语"><a href="#主语-系动词-表语" class="headerlink" title="主语+系动词+表语"></a>主语+系动词+表语</h3><ul><li>Dabai is smart</li></ul><h2 id="三种起修饰成分的句子结构"><a href="#三种起修饰成分的句子结构" class="headerlink" title="三种起修饰成分的句子结构"></a>三种起修饰成分的句子结构</h2><h3 id="定语，定语是广义的形容词"><a href="#定语，定语是广义的形容词" class="headerlink" title="定语，定语是广义的形容词"></a>定语，定语是广义的形容词</h3><ul><li>The <code>cute</code> boy speaks English</li><li>The boy <code>in red</code> speaks English</li><li>The boy <code>when I played withe</code> speaks English;</li></ul><h3 id="状语，状语是广义的副词"><a href="#状语，状语是广义的副词" class="headerlink" title="状语，状语是广义的副词"></a>状语，状语是广义的副词</h3><p>副词是用来修饰形容词和动词的词。</p><ul><li>Dabai answered <code>quickly</code></li><li>Dabai answerd <code>in English</code></li></ul><h3 id="同位语，把主语换个说法再说一遍"><a href="#同位语，把主语换个说法再说一遍" class="headerlink" title="同位语，把主语换个说法再说一遍"></a>同位语，把主语换个说法再说一遍</h3><ul><li>Shabai’s brother,<code>BigShaBai</code>,is a teacher</li><li>We <code>Chinese People</code> are hardworking</li></ul><h2 id="复杂句"><a href="#复杂句" class="headerlink" title="复杂句"></a>复杂句</h2><h3 id="并列关系的复合句"><a href="#并列关系的复合句" class="headerlink" title="并列关系的复合句"></a>并列关系的复合句</h3><ul><li>I washed my hands, <code>and</code> I ate breakfast</li></ul><h3 id="嵌套关系的复杂句"><a href="#嵌套关系的复杂句" class="headerlink" title="嵌套关系的复杂句"></a>嵌套关系的复杂句</h3><ul><li>The boy said that he was very hungry</li><li>The boy <code>who was crying</code> said <code>when I spoke to him</code> that he was very hungry <code>because he had had no food for two days</code></li></ul><h2 id="词类"><a href="#词类" class="headerlink" title="词类"></a>词类</h2><ul><li>名词，可数+不可数</li><li>代词，you I she he it</li><li>形容词，happy</li><li>副词，quickly</li><li>动词，run</li><li>数次，one two</li><li>冠词，the a this</li><li>介词，in at on</li><li>连词，and but</li><li>叹词，oh oops shit</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简单句语法&quot;&gt;&lt;a href=&quot;#简单句语法&quot; class=&quot;headerlink&quot; title=&quot;简单句语法&quot;&gt;&lt;/a&gt;简单句语法&lt;/h2&gt;&lt;p&gt;一般英语句子的结构，可以总结为&lt;code&gt;主语+谓语+（东西）&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主语：人或</summary>
      
    
    
    
    
    <category term="英语学习" scheme="http://yoursite.com/tags/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>如何克服精神内耗</title>
    <link href="http://yoursite.com/2021/10/24/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E7%B2%BE%E7%A5%9E%E5%86%85%E8%80%97/"/>
    <id>http://yoursite.com/2021/10/24/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E7%B2%BE%E7%A5%9E%E5%86%85%E8%80%97/</id>
    <published>2021-10-24T11:39:28.000Z</published>
    <updated>2022-02-06T04:09:36.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="精神内耗"><a href="#精神内耗" class="headerlink" title="精神内耗"></a>精神内耗</h2><p>今天再次阅读<code>精神内耗</code>这篇知乎文章以及他的姐妹篇<code>高效管理时间的秘诀，在于这三个清单</code>。</p><h3 id="理想的精神状态"><a href="#理想的精神状态" class="headerlink" title="理想的精神状态"></a>理想的精神状态</h3><p>理想的精神状态应该是，可以全神贯注的专注在你当前正在做的事情上，不论是学习，工作，思考，还是娱乐。</p><h3 id="我的精神状态"><a href="#我的精神状态" class="headerlink" title="我的精神状态"></a>我的精神状态</h3><p>但是目前的我是做不到的，脑袋中存在着各种各样的纠结，推演各种各样的情况，处理各种各样的信息。导致我总是精神不振，每天精神都不充沛和兴奋。</p><p>这种情况导致的结果就是，我的大脑无时无刻都在处理信息，有事甚至是不同的信息，比如我在写这篇文章的时候，就想到了还要写一篇关于头油的文章。强制转换注意力，导致注意力不集中。这里面的大量信息是无用的，空耗我大脑的 CPU 资源。</p><p>而想法多的另一个坏处是，导致想的多，做的少，比如我想学习 flutter，我想买个瑜伽垫健身，我想读《编码》这本书，我想读完我微信收藏的文章，我想看完我极客时间的课程（那个想了很久的网络协议课程），都还只停留在想想的阶段。（这个问题也许可以通过指定合理的 todo 清单来解决）</p><p>真的非常痛苦 😖。</p><h3 id="过度思虑（精神内耗），为什么会有精神内耗"><a href="#过度思虑（精神内耗），为什么会有精神内耗" class="headerlink" title="过度思虑（精神内耗），为什么会有精神内耗"></a>过度思虑（精神内耗），为什么会有精神内耗</h3><p>我的状态有个专业名词来描述，就是过度思虑，也就是通俗的精神内耗。</p><p>为什么会有这种情况呢？有以下几个原因</p><h4 id="过度活跃的-DMN"><a href="#过度活跃的-DMN" class="headerlink" title="过度活跃的 DMN"></a>过度活跃的 DMN</h4><p>DMN 就是 <code>Default Mode Network</code>，默认模式网络。它是把大脑后台零碎的信息进行梳理，把可能被遗忘的重新进行激活。哪怕什么都不做，大脑也有大约 20%的耗能任务在执行。<br>TPN，<code>Task Positive Network</code> 专注网络。</p><h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ul><li>长时记忆能力、想象力、创造力更好一些。</li><li>DMN 涉及的脑部区域和负责<code>自我与他人</code>以及<code>情感判断</code>的网络所涉及的部分，是高度重叠的。因此更容易考虑别人的感受，以及注意到不好的地方。也就是有更好的共情能力。</li></ul><h5 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h5><ul><li>DMN 过度的活跃，会在我专注工作时，和争夺大脑的 CPU 资源，导致无法持续专注。（这点我感觉我还挺明显的，比如刚才我就突然想到了 Grab 上的麦当劳是不是可以 pick up，然后打开手机看了一下）</li><li>当 DMN 不受 TPN 的钳制时，会更加放飞自我，把很多负面的情绪和想法输送到意识里。</li></ul><h4 id="由威胁识别带来的恐惧"><a href="#由威胁识别带来的恐惧" class="headerlink" title="由威胁识别带来的恐惧"></a>由威胁识别带来的恐惧</h4><p>威胁识别。我们的大脑在加工各种信息时，有一个功能，叫做威胁识别，它往往会夸大和凸显一个事物中的威胁的细节，忽视安全的细节，从而看不清事物的全貌，继而导致我去逃避该事物。</p><h5 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h5><ul><li>自我保护</li></ul><h5 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h5><ul><li>让我们害怕去做一些事，比如我总是不敢探寻新的餐厅，担心里面价格很贵，买到很坑的东西，亦或是担心不卫生。</li></ul><p>大脑还有一种机制叫做“延伸记忆”，也就是我过去付出行动、获得成功、获得经验的经历，比如我鼓起勇气成功探寻了某个餐厅，某个景点，某个理发店，我就会发现它没什么大不了，它就会成为我下次做决定的一个选项。比如我在平时不敢说话的群里面，问了一个问题，我后面就不会再认为在这个群里问问题会有什么困难。</p><p>当大脑进行”威胁识别“时，会使用”延伸记忆“里面的信息，来进行对抗和抵消。</p><h4 id="形成精神内耗"><a href="#形成精神内耗" class="headerlink" title="形成精神内耗"></a>形成精神内耗</h4><ol><li>我遇到问题，决定先审视一下再说</li><li>这种“审视一下”，导致我过度夸大了它的威胁，从而形成恐惧</li><li>这种恐惧使我的行动的意向进一步被削弱，我需要更多的精力跟它对抗，才能采取行动，于是造成了拖延</li><li>而大多数问题在拖延之下，会变得越来越糟，最终逼我不得不去行动，于是我会感觉“做出了一个错误的决定”</li><li>久而久之，这种感觉就会加重我的自我怀疑，削弱我的自信，而从削弱我的“延伸记忆”，使得我更没有办法对抗恐惧。。。</li></ol><p>最终，我的幸福感会下降。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>过度的精神内耗，会让我自我怀疑，缺乏自我的价值感和意义感觉。并且肯定会让我的幸福感降低，觉得很多事情没有意思，失去了生活的激情，我现在基本就有这种感觉，很多事情提不起兴趣。</p><p>当我专注时，更容易获得“绞尽脑汁”解决问题的快感。当我被 DMN 主宰时，我会分心，无法专注，因此也无法获得“绞尽脑汁”的快感，反而还会想起负面、不快乐的事情。</p><p>精神内耗会</p><ul><li>消耗精力</li><li>降低行动力</li><li>降低幸福感</li></ul><h3 id="克服精神内耗"><a href="#克服精神内耗" class="headerlink" title="克服精神内耗"></a>克服精神内耗</h3><h4 id="掌控自己的想法"><a href="#掌控自己的想法" class="headerlink" title="掌控自己的想法"></a>掌控自己的想法</h4><p>这个方法其实很困难，想法如果可以轻易被我掌控，那也就不会有那么多问题了。如何掌控，可以试试以下几种形式</p><ul><li>当我产生负面情绪，或者乱七八糟的想法时，对它说：我知道了，退下吧，我会等有空的时候处理。</li><li>用一个笔记本来记录我的负面的想法。产生负面想法时，先记下来，然后就不要想了（这一步很难）</li><li>定期查看笔记本中的负面想法，问自己<ul><li>他是真实的吗？</li><li>他发生的可能性大吗？</li><li>我有没有方法可以应对它？</li></ul></li><li>一旦把这三个问题想清楚，就划掉他</li></ul><p>上面的做法，可以强化我的“主动性”，让我感受到，我是可以掌控我的想法的，我有能力那么做。</p><h4 id="锻炼专注和感知能力"><a href="#锻炼专注和感知能力" class="headerlink" title="锻炼专注和感知能力"></a>锻炼专注和感知能力</h4><p>DMN 就是在我的大脑空闲时的信马由缰，因此如果我可以把大脑专注在某件事上，我就能降低 DMN 的活跃性。有以下两个方法可以帮我提高专注力。我需要把他们加到我的小习惯里面。</p><ul><li>冥想&#x2F;正念。这个方法在《自控力》这本书中也提到过，看来方法的有效性形成了共识。找一个舒适的位置，闭上眼睛，采取 10s 左右的呼吸，把注意力放在呼吸上面，体会呼吸的过程，不要去管脑海中来来回回的想法，也不要抑制它。持续 10 ～ 15 分钟。</li><li>停下手头的事，找个舒适的位置，先深呼吸一到两次，然后按顺序问自己<ul><li>我看到了什么</li><li>听到了什么</li><li>嗅到了什么</li><li>手和脚触碰到了什么</li><li>感觉是怎样的</li></ul></li><li>或者闭上眼睛，依靠感官走几步，专注感受感官传来的信息。</li></ul><h4 id="注意力转换和饱和"><a href="#注意力转换和饱和" class="headerlink" title="注意力转换和饱和"></a>注意力转换和饱和</h4><p>我工作的时候为什么会分心呢？就是因为当前的事情无法百分之百的吸引我的兴趣了，使我的注意力“不饱和”，然后产生了闲置资源，发生 DMN。</p><p>一个解决方法是分段工作模式，就是把同时打开多个项目（事情），项目一工作一段时间，转换到项目二，然后项目三，以此类推。这样的好处是，在同一个任务长时间之行后，开始无法集中注意力，大脑产生闲置，这时为了不让闲置的大脑专向 DMN，于是开启项目二来吸引我的注意力和大脑资源。</p><p>也就是说，我们无力控制自己分心，但是我们可以把分心引导到一个更有意义，更符合我们需求的方向。</p><p>可以结合后文的 Todo 清单来实践。</p><h4 id="把行动变成默认模式"><a href="#把行动变成默认模式" class="headerlink" title="把行动变成默认模式"></a>把行动变成默认模式</h4><p>如果一件事，我想不到特别有力的<strong>不去做</strong>的原因，那么，优先选择去做。</p><p>应该把这句话当成一个信条，指导我生活中的行动。</p><p>这些不确定的事情，因为害怕麻烦，权衡得失等原因，如果不得到解决，会一残留在我的记忆里，随着 DMN 的激活而挤占我的认知资源。</p><p>只有去行动了，才能把未知变成已知，把不确定变成确定，让它们得到安置，不再干扰我的思考。</p><p>另外，行动也会带给我正向的反馈。我所恐惧的东西，其实没有那么可怕，我对他的猜测，担忧和焦虑，很多都是不必要的。</p><h2 id="高效管理时间"><a href="#高效管理时间" class="headerlink" title="高效管理时间"></a>高效管理时间</h2><p>为了合理的安排自己的时间和需要做的事情，我之前制定了 Todo List，但是我之前制定的 Todo List，虽然看上去分门别类，但是最后执行力不行，很多都成了摆设，应该是失败了 😂。</p><p>因此决定学习“L 先生说” 公众号里推荐的 Todo List 管理方案。</p><h3 id="拖延症"><a href="#拖延症" class="headerlink" title="拖延症"></a>拖延症</h3><p>为啥我有拖延的毛病呢？<br>一个可能的原因来自“认知负担”，它让我产生了这么一个潜意识“这是一个复杂的任务，我没法立刻开工，我需要先理清思路”。比如我很早就计划了上 b 站搜索健身教程，并尝试在家里做简单的运动，但是却一直没有开始 😂。<br>实际上，我的大脑逻辑非常简单，他倾向于去做简单的，不需要太多思考的事情，而排斥复杂的，需要大量投入的事情。<br>这就为我们制定 Todo List 提供了一种指导。</p><h3 id="AFD-TodoList"><a href="#AFD-TodoList" class="headerlink" title="AFD TodoList"></a>AFD TodoList</h3><p>“L 先生说”实行的是名叫 AFD 的方法，也就是 Action、Focused、Dessert</p><h4 id="Action-执行清单"><a href="#Action-执行清单" class="headerlink" title="Action 执行清单"></a>Action 执行清单</h4><p>执行清单，就是自己计划需要完成的，但是这里不能简单的罗列，需要把粒度尽量的变小。</p><p>比如“到超市买苹果”，就是一个非常明确简单的行动，不需要思考，它所占用的认知资源非常少。</p><p>再比如“完成 Policy 改版”，就不行，颗粒度太大，并不是一步可以完成的，这样的 todo 很容易产生迷惑</p><ul><li>我做到了哪里</li><li>我的思路是什么</li><li>我还需要做些什么</li></ul><p>这些就会带给我认知负担。因此需要对这样的 item，做详细的分解。明确需要做什么，而且越具体，行动起来越容易，比如数量、目的、关键词等等。</p><p>这样当我看到任务的时候，可以毫不犹豫的去执行，不会产生拖延情绪。</p><p>但是话说回来，能够把任务拆的细，也是需要时间精力的，但是这种应该是值得的。</p><h4 id="Focused-聚焦清单"><a href="#Focused-聚焦清单" class="headerlink" title="Focused 聚焦清单"></a>Focused 聚焦清单</h4><p>“休息”并不一定是要睡个觉。对于体力劳动，睡觉时最好的休息方式，可以让肌肉得到放松。但是对于脑力劳动，却不是这样。</p><p>大脑处理不同的任务，使用的是不同的区域，当长时间执行一个任务时，大脑的耗能和平时其实不会差太多，但是对他的“新鲜感”会降低很多，这种“新鲜感”的降低，是我们脑力劳动疲劳的主要原因，有时我会觉得自己困了，其实是长时间思考同样的内容，会抑制大脑的活动，让人感到厌倦、昏昏欲睡无法集中注意力。</p><p>因此脑力疲惫更好的方式时，调整聚焦点，切换到不同的工作上，激活大脑的另一个区域。</p><p>因此这个清单中，可以存放两类东西</p><ul><li>重要的亟待解决的问题</li><li>正在研读和学习的书籍等</li></ul><p>每当工作累了，就可以站起来走走，喝点东西，散步，然后再脑袋里思考这些问题。比如：</p><ul><li>今晚吃什么</li><li>需要买些什么东西了</li><li>调研一下周末去哪里玩</li></ul><p>或者打开没有阅读完的书籍，阅读一会儿。等到这个清单的里的事情疲惫了，就可以去接着做之前的事情了。</p><h4 id="Dessert-成就感清单"><a href="#Dessert-成就感清单" class="headerlink" title="Dessert 成就感清单"></a>Dessert 成就感清单</h4><p>如果是在觉得厌烦、无聊，提不起精神，不想动脑子，无论是 Action、还是 Focused 里面的事情，都不想干，这就是精神低谷的时候，就可以准备一个“Dessert”清单，里面放一些非常简单，无需动脑、没有时间限制的小事，比如</p><ul><li>整理书桌</li><li>整理电脑文件夹</li><li>下载资源</li></ul><p>这样可以积累成就感，帮助我的精神状态回归。通过在做完 2-3 项 Dessert 之后，状态应该可以回归。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;精神内耗&quot;&gt;&lt;a href=&quot;#精神内耗&quot; class=&quot;headerlink&quot; title=&quot;精神内耗&quot;&gt;&lt;/a&gt;精神内耗&lt;/h2&gt;&lt;p&gt;今天再次阅读&lt;code&gt;精神内耗&lt;/code&gt;这篇知乎文章以及他的姐妹篇&lt;code&gt;高效管理时间的秘诀，在于这三个清单&lt;/c</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>整理英语学习资源</title>
    <link href="http://yoursite.com/2021/10/23/%E6%95%B4%E7%90%86%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    <id>http://yoursite.com/2021/10/23/%E6%95%B4%E7%90%86%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/</id>
    <published>2021-10-23T04:20:18.000Z</published>
    <updated>2022-02-06T04:09:36.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="资源整理"><a href="#资源整理" class="headerlink" title="资源整理"></a>资源整理</h2><p>目前收集了很多的英语学习资源，在国内的时候更多的是单纯的学习，而来到新加坡后有了很多的实战场景，除了日常的积累外，还是需要一些系统性的学些 lah！🤪</p><ul><li>方法论<ul><li><a href="https://github.com/byoungd/English-level-up-tips-for-Chinese">English leval up tips for chinese</a></li></ul></li><li>APP<ul><li><a href="">开言英语</a></li><li><a href="">英语流利说</a></li></ul></li><li>视频<ul><li><a href="https://www.bilibili.com/video/BV1wM4y137kP">五分钟英语基础语法</a></li><li><a href="https://www.bilibili.com/video/BV1aM4y1g7mj">外教 Gill 英语精品课</a></li><li><a href="https://www.bilibili.com/video/BV1cM4y1V7t1">说一口流利标准英语</a></li><li><a href="https://bilibili.com/video/BV1zy4y1b7jZ">English with Lucy</a></li></ul></li><li>B 站 UP 主<ul><li><a href="https://space.bilibili.com/454755309">Youtobe 口语精选</a></li><li><a href="https://space.bilibili.com/483301783">Youtobe 英语精选</a></li><li><a href="https://space.bilibili.com/6926237/">Youtobe 听力精选</a></li><li><a href="https://space.bilibili.com/1589382178">Bigshot 英语</a></li></ul></li><li>Youtobe<ul><li><a href="https://www.youtube.com/c/EnglishwithLucy/featured">English with Lucy</a></li><li><a href="https://www.youtube.com/user/theteachervanessa">Speak English With Vanessa</a></li></ul></li><li>公众号<ul><li><a href="">英语资源学习中心</a></li></ul></li><li>Podcast<ul><li><a href="">潘吉 JENNY 告诉你</a></li><li><a href="">ALL EARS ENGLISH</a></li><li><a href="">英文小酒馆 LHH</a></li><li><a href="">一席英语</a></li><li><a href="">6 Minute English</a></li></ul></li></ul><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>某次偶然的机会听到了<code>潘吉 JENNY 告诉你</code>这款播客，感觉这种中英对话聊天的形式很有意思，每期一个话题，除了学习英语，还可以知道一些有趣的事情。<br>继而开始使用他们公司开发的<code>开言英语</code>App，使用了外交视频课，感觉还不错，根据具体的场景来学习英语。</p><p>其他资源自然是屯起来才有安全感 lah！还都没开始看 🤪。</p><p>播客打算额外选择一个<code>一席英语</code>，再从视频里选择<code>说一口流利标准英语</code>把它办了 💪！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;资源整理&quot;&gt;&lt;a href=&quot;#资源整理&quot; class=&quot;headerlink&quot; title=&quot;资源整理&quot;&gt;&lt;/a&gt;资源整理&lt;/h2&gt;&lt;p&gt;目前收集了很多的英语学习资源，在国内的时候更多的是单纯的学习，而来到新加坡后有了很多的实战场景，除了日常的积累外，还是需要一</summary>
      
    
    
    
    
    <category term="英语学习" scheme="http://yoursite.com/tags/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>算法资源整理</title>
    <link href="http://yoursite.com/2021/10/20/%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%E8%B5%84%E6%BA%90/"/>
    <id>http://yoursite.com/2021/10/20/%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%E8%B5%84%E6%BA%90/</id>
    <published>2021-10-20T11:18:43.000Z</published>
    <updated>2022-02-06T04:09:36.889Z</updated>
    
    <content type="html"><![CDATA[<p>最近打算再一次系统的学习数据结构与算法，并再次开始有节奏的刷 leetcode。功在平时，有备无患，在还没有熟练掌握之前，学习数据结构与算法和刷题必然是一个长期的过程。</p><h2 id="资源整理"><a href="#资源整理" class="headerlink" title="资源整理"></a>资源整理</h2><p>目前手头上掌握的资源挺多，可真正耐下心看完的没有几个。很多都是看到之后，随手就丢进了收藏夹里吃灰（众所周知，收藏就等于学会了 🤪）。</p><ul><li>在线书籍<ul><li><a href="https://labuladong.github.io/algo">labuladong 算法小抄</a></li><li><a href="https://www.pzijun.cn/algorithms">瓶子君的算法小书</a></li><li><a href="https://github.com/chefyuan/algorithm-base">程序厨的动画算法</a></li><li><a href="https://books.halfrost.com/leetcode">leetcode cookbook</a></li></ul></li><li>极客时间<ul><li><a href="https://time.geekbang.org/course/detail/100019701-67635">算法面试通过 40 讲</a></li><li><a href="https://time.geekbang.org/column/article/76207">数据结构与算法之美</a></li><li><a href="https://time.geekbang.org/opencourse/intro/100057601">常用算法 25 讲</a></li></ul></li><li>视频<ul><li><a href="">百度云-算法训练营</a></li><li><a href="https://space.bilibili.com/525438321/video">代码随想录</a></li><li><a href="https://www.bilibili.com/video/BV1E741157bP">清华大学数据结构精品课-邓俊辉</a></li><li><a href="https://www.bilibili.com/video/BV1m54y1t7F7/">左程云 LeetCode 刷题笔记</a></li></ul></li><li>github<ul><li><a href="https://github.com/yuanguangxin/LeetCode">LeetCode 题目分类与面试问题整理</a></li><li><a href="https://github.com/labuladong/fucking-algorithm">Fucking Algorithm(同 labuladong 算法小抄)</a></li><li><a href="https://github.com/dongxiaohuang/leetcode_solutions">LeetCode Classify</a></li><li><a href="https://github.com/imarvinle/awesome-cs-books">Awesome CS Books</a></li><li><a href="https://github.com/jwasham/coding-interview-university">Coding Interview University</a></li><li><a href="https://github.com/MisterBooo/LeetCodeAnimation">LeetCode Animation</a></li><li><a href="https://github.com/doocs/leetcode">LeetCode 全解</a></li></ul></li><li>书籍<ul><li><a href="">剑指 offer</a></li><li><a href="">编程之美</a></li></ul></li></ul><h2 id="挑选"><a href="#挑选" class="headerlink" title="挑选"></a>挑选</h2><p>资料整理了好多，但是之前没有系统的钻研过。除了面试前看的《算法面试通关 40 讲》和《数据结构与算法之美》,前者属于视频类，后者属于小册类。</p><p>资料太多，不可能一次全部搞完，没有计划，很容易他们就集体吃灰了，还是需要逐个击破。这次决定从众多资料中，挑出两个，一个文字阅读类，一个视频类，互为补充的来学习。</p><ul><li>labuladong 算法小抄</li><li>百度云-算法训练营</li></ul><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>从 labuladong 算法小抄中，从头到尾，按照专题，每两天做一道题目，如果遇到简单的做过的，就顺势做到下一题。遇到复杂的概念和困难的题目，可以结合算法训练营视频来消化。</p><p>2021&#x2F;10&#x2F;20 星期三</p><h2 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h2><p>这里等待反馈，如果 labuladong 算法小抄过了一遍，再来这篇 blog 记录下成功的时间。</p><p>未完待续。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近打算再一次系统的学习数据结构与算法，并再次开始有节奏的刷 leetcode。功在平时，有备无患，在还没有熟练掌握之前，学习数据结构与算法和刷题必然是一个长期的过程。&lt;/p&gt;
&lt;h2 id=&quot;资源整理&quot;&gt;&lt;a href=&quot;#资源整理&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    
    <category term="算法与数据结构" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Mac 安装和启动MySQL数据库</title>
    <link href="http://yoursite.com/2021/10/19/Mac-%E5%AE%89%E8%A3%85%E5%92%8C%E5%90%AF%E5%8A%A8MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2021/10/19/Mac-%E5%AE%89%E8%A3%85%E5%92%8C%E5%90%AF%E5%8A%A8MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2021-10-19T11:05:29.000Z</published>
    <updated>2022-02-06T04:09:36.889Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习 NestJS 框架，需要使用 MySQL 数据库来配合完成一些功能，以前只使用过 MongoDB，第一次使用 MySQL，在安装和使用时踩了一些坑，记录下来。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>MySQL 分为商业版和社区版，社区版我理解就是开源免费的。但是在官网想要找到下载入口比较费劲，个人感觉不是清晰。下载社区版可以直接使用下面这个链接。<br><a href="https://dev.mysql.com/downloads/mysql/">MySQL Community Download</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载完成后，直接双击 dmg 文件进行安装。安装过程中需要输入输入 root 的密码，这里需要记下来。后面链接数据库的时候需要使用。</p><p><img src="/images/mysql_install.png" alt="mysql_install"></p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>为了启动 MySQL 我走了不少弯路，一开始使用命令行来启动，结果很麻烦，也没有成功启动。后来发现其实 MySQL 很人性化，它会在 System Perference 里面生成一个图标，点击图标后就可进行一些基本操作，包括</p><ul><li>start</li><li>stop</li><li>initialize</li></ul><p><img src="/images/mysql_perference_1.png" alt="mysql_perference_1"><br><img src="/images/mysql_perference_2.png" alt="mysql_perference_2"></p><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>建议直接使用图形化界面来操作，使用命令行太麻烦了。图形化界面有两个选择一个是收费的<code>Navicat</code>，一个是开源免费的<code>Sequel Pro</code>。<br>笔者一开始试用过<code>Navicat</code>，确实非常好用，鉴于平时需求不是很大，所以暂时没有打算付费使用。于是选择了<code>Sequel Pro</code>。</p><p>在使用<code>Sequel Pro</code>的过程中遇到了一些问题。最开始下载的是<code>v1.1.2</code>正式版，但是使用过程中无法连接数据库，还总是闪退。尝试重装也没有解决。搜索后发现很多人都遇到了这个问题。解决方案是下载<code>test build</code>版本。可以完美解决。</p><p>下载地址: <a href="https://sequelpro.com/test-builds">Sequel Pro test build</a></p><p><img src="/images/sequel_pro_1.png" alt="sequel_pro_1"><br><img src="/images/sequel_pro_2.png" alt="sequel_pro_2"></p><p>如此依赖就可以快乐的使用 MySQL 数据库了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在学习 NestJS 框架，需要使用 MySQL 数据库来配合完成一些功能，以前只使用过 MongoDB，第一次使用 MySQL，在安装和使用时踩了一些坑，记录下来。&lt;/p&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
    <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>使用React设计一个Form表单组件</title>
    <link href="http://yoursite.com/2021/07/18/%E4%BD%BF%E7%94%A8React%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AAForm%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2021/07/18/%E4%BD%BF%E7%94%A8React%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AAForm%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6/</id>
    <published>2021-07-18T17:18:44.000Z</published>
    <updated>2022-02-06T04:09:36.889Z</updated>
    
    <content type="html"><![CDATA[<p>通过设计一个 Form 组件，学习 React 中，<code>React.Children.forEach</code> 和 <code>React.CloneElement</code> 以及 <code>React.isValidElement</code> 这三个 API 的用法。</p><h1 id="组件-API-设计"><a href="#组件-API-设计" class="headerlink" title="组件 API 设计"></a>组件 API 设计</h1><p>组件用法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Form</span>, <span class="title class_">FormItem</span>, <span class="title class_">Input</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./Form&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> form = <span class="title function_">useRef</span>();</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onSubmit</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    form.<span class="property">current</span>.<span class="title function_">submit</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;data&quot;</span>, data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onReset</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    form.<span class="property">current</span>.<span class="title function_">reset</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Form</span> <span class="attr">ref</span>=<span class="string">&#123;form&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">FormItem</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">label</span>=<span class="string">&quot;姓名&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Input</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">FormItem</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">label</span>=<span class="string">&quot;年龄&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Input</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">FormItem</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">label</span>=<span class="string">&quot;性别&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Input</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onSubmit&#125;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onReset&#125;</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组件实现"><a href="#组件实现" class="headerlink" title="组件实现"></a>组件实现</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Form</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">formData</span>: &#123;&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  submit = <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">    cb &amp;&amp; <span class="title function_">cb</span>(&#123; ...<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">formData</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  reset = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; formData &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(formData).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">      formData[key] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; formData &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  setValue = <span class="function">(<span class="params">name, value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; formData &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">    formData[name] = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; formData &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; children &#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line">    <span class="keyword">const</span> &#123; formData &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">    <span class="keyword">const</span> renderChildren = [];</span><br><span class="line"></span><br><span class="line">    <span class="title class_">React</span>.<span class="property">Children</span>.<span class="title function_">forEach</span>(children, <span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (child.<span class="property">type</span>.<span class="property">displayName</span> === <span class="string">&quot;FormItem&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; name &#125; = child.<span class="property">props</span>;</span><br><span class="line">        renderChildren.<span class="title function_">push</span>(</span><br><span class="line">          <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(</span><br><span class="line">            child,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">key</span>: name,</span><br><span class="line">              <span class="attr">value</span>: formData[name] || <span class="string">&quot;&quot;</span>,</span><br><span class="line">              <span class="attr">handleChange</span>: <span class="variable language_">this</span>.<span class="property">setValue</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            child.<span class="property">props</span>.<span class="property">children</span></span><br><span class="line">          )</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> renderChildren;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">FormItem</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> displayName = <span class="string">&quot;FormItem&quot;</span>;</span><br><span class="line"></span><br><span class="line">  onChange = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, handleChange &#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line">    handleChange &amp;&amp; <span class="title function_">handleChange</span>(name, value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; label, value, children &#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;label&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;React.isValidElement(children) &amp;&amp;</span></span><br><span class="line"><span class="language-xml">        children.type.displayName === &quot;FormItem-Input&quot;</span></span><br><span class="line"><span class="language-xml">          ? React.cloneElement(children, &#123; onChange: this.onChange, value &#125;)</span></span><br><span class="line"><span class="language-xml">          : null&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Input</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> displayName = <span class="string">&quot;FormItem-Input&quot;</span>;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value, onChange &#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;value&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">          onChange &amp;&amp; onChange(e.target.value);</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      /&gt;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;通过设计一个 Form 组件，学习 React 中，&lt;code&gt;React.Children.forEach&lt;/code&gt; 和 &lt;code&gt;React.CloneElement&lt;/code&gt; 以及 &lt;code&gt;React.isValidElement&lt;/code&gt; 这三个 </summary>
      
    
    
    
    
    <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>数组排序系列</title>
    <link href="http://yoursite.com/2021/04/18/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%B3%BB%E5%88%97/"/>
    <id>http://yoursite.com/2021/04/18/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%B3%BB%E5%88%97/</id>
    <published>2021-04-18T15:52:57.000Z</published>
    <updated>2022-02-06T04:09:36.889Z</updated>
    
    <content type="html"><![CDATA[<p>数组的排序应该是基本中的基本了。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title=" 冒泡排序"></a> 冒泡排序</h2><p>冒泡排序的思想是，通过一次遍历，通过比较，将一个最大的元素，调整到数组的末尾，进行 n 次之后，数组就有序了。<br>因此时间复杂度是 O(n^2)</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sortArray</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.<span class="property">length</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="title function_">swap</span>(nums, j, j + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的思想是，将数组分成两部分，左半部分是有序的，右半部分是无序的，每次从右半部分取出第一个元素，插入到左半部分。<br>插入的过程是，把待插入元素和左半部分的元素比较，如果小于就交换，如果大于等于就停止。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sortArray</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="comment">// nums[i] 是待插入的元素</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j] &lt; nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="title function_">swap</span>(nums, j - <span class="number">1</span>, j);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序的思想是，每次将数组分为左右两部分，左半部分的所有值都小于右半部分，然后对左右部分再进行这样的操作。最终整个数组有序。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">partition</span>(<span class="params">nums: <span class="built_in">number</span>[], left: <span class="built_in">number</span>, right: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> right;</span><br><span class="line">  <span class="keyword">const</span> pvoit = nums[left];</span><br><span class="line">  <span class="keyword">const</span> start = left;</span><br><span class="line">  left = left + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[left] &gt; pvoit &amp;&amp; nums[right] &lt; pvoit) &#123;</span><br><span class="line">      <span class="title function_">swap</span>(nums, left++, right--);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt;= pvoit) &#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">swap</span>(nums, start, right);</span><br><span class="line">  <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">nums: <span class="built_in">number</span>[], left: <span class="built_in">number</span>, right: <span class="built_in">number</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> p = <span class="title function_">partition</span>(nums, left, right);</span><br><span class="line">  <span class="title function_">quickSort</span>(nums, left, p - <span class="number">1</span>);</span><br><span class="line">  <span class="title function_">quickSort</span>(nums, p + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sortArray</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">quickSort</span>(nums, <span class="number">0</span>, nums.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数组的排序应该是基本中的基本了。&lt;/p&gt;
&lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot; 冒泡排序&quot;&gt;&lt;/a&gt; 冒泡排序&lt;/h2&gt;&lt;p&gt;冒泡排序的思想是，通过一次遍历，通过比较，将一个最大的元素，调整到数</summary>
      
    
    
    
    
    <category term="算法与数据结构" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>前缀和系列</title>
    <link href="http://yoursite.com/2021/04/17/%E5%89%8D%E7%BC%80%E5%92%8C%E7%B3%BB%E5%88%97/"/>
    <id>http://yoursite.com/2021/04/17/%E5%89%8D%E7%BC%80%E5%92%8C%E7%B3%BB%E5%88%97/</id>
    <published>2021-04-17T10:44:29.000Z</published>
    <updated>2022-02-06T04:09:36.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><p>前缀和，简单说就是数组的前 n 项的和。不过需要注意，在代码里面，presum[i] 代表前 i 项的和，也就是 nums[0]~nums[i-1]的和。<br>比如 presum[2] &#x3D; nums[0] + nums[1]。</p><p>通过前缀和的思想和 map，可以优化很多问题解法。</p><p>同时前缀和不一定真的就是前缀的和，也可以是前缀中奇数数字的个数等。总之就前缀的一个统计信息，可以是和，也可以是其他。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">presum</span>(<span class="params">nums: <span class="built_in">number</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">let</span> presum = [<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    presum[i + <span class="number">1</span>] = presum[i] + nums[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="724-寻找数组的中心下标"><a href="#724-寻找数组的中心下标" class="headerlink" title="724. 寻找数组的中心下标"></a>724. 寻找数组的中心下标</h2><p>给你一个整数数组  nums，请编写一个能够返回数组 “中心下标” 的方法。数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。如果数组不存在中心下标，返回 -1 。如果数组有多个中心下标，应该返回最靠近左边的那一个。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先求出总和</span></span><br><span class="line"><span class="comment">// 遍历求出左边的和，然后用总和减去左边的和以及当前值，就是右边的和</span></span><br><span class="line"><span class="comment">// 判断左右的和是否相等</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pivotIndex</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> presum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    presum += nums[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> leftsum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> rightsum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    rightsum = presum - leftsum - nums[i];</span><br><span class="line">    <span class="keyword">if</span> (leftsum === rightsum) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    leftsum += nums[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p>给定一个整数数组 nums  和一个整数目标值 target，请你在该数组中找出 和为目标值 的那   两个   整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用一个map，记录已经访问过的值</span></span><br><span class="line"><span class="comment">// 遍历数组，判断map中是否已经存在一个值，和当前值相加的和是target</span></span><br><span class="line"><span class="comment">// 如果不是，就把当前值加入到map中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">twoSum</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.<span class="title function_">has</span>(target - nums[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span> [map.<span class="title function_">get</span>(target - nums[i]), i];</span><br><span class="line">    &#125;</span><br><span class="line">    map.<span class="title function_">set</span>(nums[i], i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a>560. 和为 K 的子数组</h2><p>给定一个整数数组和一个整数  k，你需要找到该数组中和为  k  的连续的子数组的个数。</p><blockquote><p>示例 1 : 输入:nums &#x3D; [1,1,1], k &#x3D; 2; 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力法，求出了所有子数组的和</span></span><br><span class="line"><span class="comment">// 有可能会超时</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">subarraySum</span>(<span class="params">nums: <span class="built_in">number</span>[], k: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; nums.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      sum += nums[j];</span><br><span class="line">      <span class="keyword">if</span> (sum === k) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与两数之和类似，使用map节省时间</span></span><br><span class="line"><span class="comment">// map 中记录前缀和，以及该前缀和出现的次数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">subarraySum</span>(<span class="params">nums: <span class="built_in">number</span>[], k: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> presum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  map.<span class="title function_">set</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    presum += nums[i];</span><br><span class="line">    <span class="keyword">if</span> (map.<span class="title function_">has</span>(presum - k)) &#123;</span><br><span class="line">      cnt += map.<span class="title function_">get</span>(presum - k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> curVal = map.<span class="title function_">has</span>(presum) ? map.<span class="title function_">get</span>(presum) : <span class="number">0</span>;</span><br><span class="line">    map.<span class="title function_">set</span>(presum, curVal + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1248-统计优美子数组"><a href="#1248-统计优美子数组" class="headerlink" title="1248. 统计优美子数组"></a>1248. 统计优美子数组</h2><p>给你一个整数数组  nums 和一个整数 k。如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。请返回这个数组中「优美子数组」的数目。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用位运算判断数字的奇偶性</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isOdd</span>(<span class="params">num: <span class="built_in">number</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (num &amp; <span class="number">1</span>) === <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴力法，遍历所有的子数组，计算子数组奇数的个数，判断个数是否为k</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">numberOfSubarrays</span>(<span class="params">nums: <span class="built_in">number</span>[], k: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> oddCnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    oddCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; nums.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isOdd</span>(nums[j])) oddCnt++;</span><br><span class="line">      <span class="keyword">if</span> (oddCnt === k) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// presum 记录的是当前前缀中的奇数的个数</span></span><br><span class="line"><span class="comment">// map记录前缀中奇数个数，以及该种case出现的次数</span></span><br><span class="line"><span class="comment">// 比如map(5,2) 代表，该前缀中有5个奇数，它出现了2次</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">numberOfSubarrays</span>(<span class="params">nums: <span class="built_in">number</span>[], k: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> presum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  map.<span class="title function_">set</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    presum += <span class="title function_">isOdd</span>(nums[i]) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (map.<span class="title function_">has</span>(presum - k)) &#123;</span><br><span class="line">      cnt += map.<span class="title function_">get</span>(presum - k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> curVal = map.<span class="title function_">has</span>(presum) ? map.<span class="title function_">get</span>(presum) : <span class="number">0</span>;</span><br><span class="line">    map.<span class="title function_">set</span>(presum, curVal + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="974-和可被-K-整除的子数组"><a href="#974-和可被-K-整除的子数组" class="headerlink" title="974. 和可被 K 整除的子数组"></a>974. 和可被 K 整除的子数组</h2><p>给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。</p><ul><li>这里的 k 大于 2</li><li>数组 A 中有负数。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力法</span></span><br><span class="line"><span class="comment">// 求出所有子数组的和，验证是否可以被K整除</span></span><br><span class="line"><span class="comment">// 超时了</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">subarraysDivByK</span>(<span class="params">A: <span class="built_in">number</span>[], K: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; A.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; A.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      sum += A[j];</span><br><span class="line">      <span class="keyword">if</span> (sum % K === <span class="number">0</span>) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// presum 还是前缀和</span></span><br><span class="line"><span class="comment">// map记录前缀和对K的余数，以及次数</span></span><br><span class="line"><span class="comment">// (presum[i]-presum[j]) % K = 0 --&gt; presum[i] % K = presum[j] % K</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">subarraysDivByK</span>(<span class="params">A: <span class="built_in">number</span>[], K: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> presum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> remainder = <span class="number">0</span>; <span class="comment">// 余数</span></span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  <span class="comment">// map记录前缀和对K的余数，以及次数</span></span><br><span class="line">  map.<span class="title function_">set</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; A.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    presum += A[i];</span><br><span class="line">    <span class="comment">// 这里需要把负数的余数转成正数</span></span><br><span class="line">    remainder = ((presum % K) + K) % K;</span><br><span class="line">    <span class="keyword">if</span> (map.<span class="title function_">has</span>(remainder)) &#123;</span><br><span class="line">      cnt += map.<span class="title function_">get</span>(remainder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> curVal = map.<span class="title function_">has</span>(remainder) ? map.<span class="title function_">get</span>(remainder) : <span class="number">0</span>;</span><br><span class="line">    map.<span class="title function_">set</span>(remainder, curVal + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="523-连续的子数组和"><a href="#523-连续的子数组和" class="headerlink" title="523. 连续的子数组和"></a>523. 连续的子数组和</h2><p>给定一个包含 非负数 的数组和一个目标 整数  k ，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，且总和为 k 的倍数，即总和为 n * k ，其中 n 也是一个整数。</p><ul><li>k 是整数，可能为 0</li><li>子数组长度至少为 2</li><li>返回 bool 值，判断这个值是否存在</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map的key为余数，val不再是余数出现的次数，而是该余数最早出现的位置</span></span><br><span class="line"><span class="comment">// 通过这个位置来判断，子树组长度是否大于等于2</span></span><br><span class="line"><span class="comment">// k为0的时候，余数就是presum本身，也就变成了是否有两个前缀和是相等的。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkSubarraySum</span>(<span class="params">nums: <span class="built_in">number</span>[], k: <span class="built_in">number</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> presum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> remainder = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  map.<span class="title function_">set</span>(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    presum += nums[i];</span><br><span class="line">    remainder = k === <span class="number">0</span> ? presum : ((presum % k) + k) % k;</span><br><span class="line">    <span class="keyword">if</span> (map.<span class="title function_">has</span>(remainder)) &#123;</span><br><span class="line">      <span class="keyword">const</span> index = map.<span class="title function_">get</span>(remainder);</span><br><span class="line">      <span class="keyword">if</span> (i - index &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map.<span class="title function_">set</span>(remainder, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="930-和相同的二元子数组"><a href="#930-和相同的二元子数组" class="headerlink" title="930. 和相同的二元子数组"></a>930. 和相同的二元子数组</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前缀和&quot;&gt;&lt;a href=&quot;#前缀和&quot; class=&quot;headerlink&quot; title=&quot;前缀和&quot;&gt;&lt;/a&gt;前缀和&lt;/h2&gt;&lt;p&gt;前缀和，简单说就是数组的前 n 项的和。不过需要注意，在代码里面，presum[i] 代表前 i 项的和，也就是 nums[0]~n</summary>
      
    
    
    
    
    <category term="算法与数据结构" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序-课程表系列</title>
    <link href="http://yoursite.com/2021/04/12/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-%E8%AF%BE%E7%A8%8B%E8%A1%A8%E7%B3%BB%E5%88%97/"/>
    <id>http://yoursite.com/2021/04/12/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-%E8%AF%BE%E7%A8%8B%E8%A1%A8%E7%B3%BB%E5%88%97/</id>
    <published>2021-04-12T21:24:21.000Z</published>
    <updated>2022-02-06T04:09:36.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="leetcode-207-课程表"><a href="#leetcode-207-课程表" class="headerlink" title="leetcode 207 课程表"></a>leetcode 207 课程表</h2><p>你这个学期必须选修 numCourses 门课程，记为  0  到  numCourses - 1 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组  prerequisites 给出，其中  prerequisites[i] &#x3D; [ai, bi] ，表示如果要学习课程  ai 则 必须 先学习课程   bi 。</p><p>例如，先修课程对  [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。<br>请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。</p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>这种在一个图中，互相有依赖关系，需要按照依赖顺序排序输出的问题，就是拓扑排序。拓扑排序除了排序输出之外，还可以验证图中是否有环。比如下面常见的拓扑排序的应用。</p><ul><li>课程学习的先后顺序</li><li>相互依赖的文件的编译顺序</li></ul><h3 id="拓扑排序的方法"><a href="#拓扑排序的方法" class="headerlink" title="拓扑排序的方法"></a>拓扑排序的方法</h3><p>一是 Kahn 算法。二是深度优先遍历</p><h4 id="Kahn-算法"><a href="#Kahn-算法" class="headerlink" title="Kahn 算法"></a>Kahn 算法</h4><p>个人认为 Kahn 算法还是比较好理解的。首先需要定义 b 依赖与 a，a 要先与 b 执行，那么就是 a-&gt;b。<br>此时 b 的入度是 1，a 的入度是 0。</p><ol><li>算法的思路就是首先统计出所有的点的入度，还需要统计所有点的 next 点</li><li>然后找到入度为 0 的点，访问它，随后，将该点的所有 next 点的入度都减 1</li><li>然后重复 2 这个步骤</li><li>直到没有入度为 0 的点为止</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">canFinish</span>(<span class="params">numCourses: <span class="built_in">number</span>, prerequisites: <span class="built_in">number</span>[][]</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> inDegree = <span class="title class_">Array</span>(numCourses).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> adjacent = inDegree.<span class="title function_">map</span>(<span class="function">() =&gt;</span> []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [cur, pre] <span class="keyword">of</span> prerequisites) &#123;</span><br><span class="line">    <span class="comment">// pre -&gt; cur</span></span><br><span class="line">    inDegree[cur] += <span class="number">1</span>;</span><br><span class="line">    adjacent[pre].<span class="title function_">push</span>(cur);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到所有入度为0的课程</span></span><br><span class="line">  <span class="keyword">const</span> queue = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; inDegree.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inDegree[i] === <span class="number">0</span>) &#123;</span><br><span class="line">      queue.<span class="title function_">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> list = [];</span><br><span class="line">  <span class="comment">// 遍历入度为0的课程，入度为0，则加入list, 并将它的临接课程入度-1</span></span><br><span class="line">  <span class="keyword">while</span> (queue.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cur = queue.<span class="title function_">shift</span>();</span><br><span class="line">    list.<span class="title function_">push</span>(cur);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前课程的所有后序课程的入度减1，如果后序课程的入度为0，则加入list</span></span><br><span class="line">    adjacent[cur].<span class="title function_">forEach</span>(<span class="function">(<span class="params">next</span>) =&gt;</span> &#123;</span><br><span class="line">      inDegree[next]--;</span><br><span class="line">      <span class="keyword">if</span> (inDegree[next] === <span class="number">0</span>) &#123;</span><br><span class="line">        queue.<span class="title function_">push</span>(next);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后验证一下，是否所有的课程都学完了</span></span><br><span class="line">  <span class="keyword">return</span> list.<span class="property">length</span> === numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dfs-深度优先遍历"><a href="#dfs-深度优先遍历" class="headerlink" title="dfs 深度优先遍历"></a>dfs 深度优先遍历</h4><p>深度优先遍历，也是解决拓扑排序的常用办法。其思路就是沿着一个点，一直往前找它的前置点，直到没有前置的点了，就是找到头了。此时就可以回溯访问了（从外到内探索，从内到外回溯访问）。<br>需要注意的是，需要记录点的状态，未访问｜访问中｜已经访问。</p><ul><li>如果未访问需要标记未访问中</li><li>如果是访问中，则说明又访问了一次，存在环</li><li>如果是已经访问，那么直接返回就可以了;比如(这里和 Kahn 算法是反的，a-&gt;b 代表 b 先于 a 执行。a 依赖 b)<ul><li>a-&gt;b-&gt;c</li><li>d-&gt;b-&gt;c</li><li>访问完 a 这条链路，b 和 c 就已经访问了。因此再访问 d 这条链路时，就不需要访问 b 和 c 了</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params"></span></span><br><span class="line"><span class="params">  cur: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  pres: <span class="built_in">number</span>[][],</span></span><br><span class="line"><span class="params">  visited: <span class="built_in">number</span>[],</span></span><br><span class="line"><span class="params">  res: <span class="built_in">number</span>[]</span></span><br><span class="line"><span class="params"></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (visited[cur] === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 已经访问过了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (visited[cur] === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 正在访问中，结果又来访问了。出现了环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 设为访问中</span></span><br><span class="line">    visited[cur] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pres[cur].<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// 访问前置节点</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">dfs</span>(pres[cur][i], pres, visited, res)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[cur] = <span class="number">2</span>;</span><br><span class="line">    res.<span class="title function_">push</span>(cur);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findOrder</span>(<span class="params">numCourses: <span class="built_in">number</span>, prerequisites: <span class="built_in">number</span>[][]</span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> visited = <span class="title class_">Array</span>(numCourses).<span class="title function_">fill</span>(<span class="number">0</span>); <span class="comment">// 0-未访问；1-访问中；2-已经访问</span></span><br><span class="line">  <span class="keyword">const</span> pres = visited.<span class="title function_">map</span>(<span class="function">() =&gt;</span> []); <span class="comment">// 记录节点的前置节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 统计节点的前置节点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [cur, pre] <span class="keyword">of</span> prerequisites) &#123;</span><br><span class="line">    pres[cur].<span class="title function_">push</span>(pre);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">dfs</span>(i, pres, visited, res)) &#123;</span><br><span class="line">      <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;leetcode-207-课程表&quot;&gt;&lt;a href=&quot;#leetcode-207-课程表&quot; class=&quot;headerlink&quot; title=&quot;leetcode 207 课程表&quot;&gt;&lt;/a&gt;leetcode 207 课程表&lt;/h2&gt;&lt;p&gt;你这个学期必须选修 numC</summary>
      
    
    
    
    
    <category term="算法与数据结构" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>完全二叉树、堆和优先队列</title>
    <link href="http://yoursite.com/2021/04/11/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2021/04/11/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</id>
    <published>2021-04-11T14:10:04.000Z</published>
    <updated>2022-02-06T04:09:36.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>完全二叉树是满二叉树的一种退化。它只缺少最后一排最右边的一些元素。如下图所示。</p><p><img src="/images/bianary-tree.png" alt="bianary-tree"></p><h3 id="完全二叉树的特性"><a href="#完全二叉树的特性" class="headerlink" title="完全二叉树的特性"></a>完全二叉树的特性</h3><p>完全二叉树有一个优秀的特性。就是它可以保存在一个数组中，而不需要使用链表的方式来存储。<br>如果对完全二叉树中的节点编号，那么可以总结出一个规律。<br>如果父节点的编号是 i，那么它的左子节点的编号就是 2<em>i，右子节点的编号就是 2</em>i+1</p><blockquote><p>实际上，在计算机中，我们会把数组作为完全二叉树的实际存储结构，而完全二叉树，则是我们重新看待这段数组信息的思维逻辑结构。因此，数据结构最大的价值，就是对我们思维逻辑结构的改造。</p></blockquote><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><blockquote><p>堆（Heap）是一个可以被看成近似完全二叉树的数组。树上的每一个结点对应数组的一个元素。除了最底层外，该树是完全充满的，而且是从左到右填充。—— 来自：《算法导论》</p></blockquote><p>堆其实就是使用完全二叉树实现的一种数据结构。分为大顶堆和小顶堆。</p><ul><li>小顶堆；如果一个完全二叉树的每一个父节点的值都小于其子节点的值，那么就是一个小顶堆。</li><li>大顶堆；如果一个完全二叉树的每一个父节点的值都大于其子节点的值，那么就是一个大顶堆。</li></ul><blockquote><p>为了让你更好地学习堆这种数据结构，我要和你分享一个学习数据结构的公式：数据结构 &#x3D; 结构定义 + 结构操作。结构定义和结构操作是组成数据结构最重要的两个部分，也是你之后在学任何一种数据结构时的重点内容。结构定义就是定义一种性质，结构操作就是维护这种性质。</p></blockquote><h3 id="堆的结构定义"><a href="#堆的结构定义" class="headerlink" title="堆的结构定义"></a>堆的结构定义</h3><ul><li>大顶堆可以维护一个集合中的最大值。</li><li>小顶堆可以维护一个集合中的最小值。</li></ul><h3 id="堆的结构操作"><a href="#堆的结构操作" class="headerlink" title="堆的结构操作"></a>堆的结构操作</h3><ul><li>插入新元素<ul><li>插入到最后面（数组的最后）</li><li>向上调整，维护堆的特性</li></ul></li><li>删除最值元素<ul><li>将最后一个元素覆盖堆顶元素（数组尾元素覆盖数组头元素）</li><li>向下调整，维护堆的特性</li></ul></li></ul><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ol><li>对数组建立一个大顶堆</li><li>每次将堆顶元素和堆尾元素调换位置（相当于把最大值放在了最后），然后减小堆的 size，从上到下维护堆</li><li>执行 n 次之后，得到一个从小到达排序的数组</li></ol><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><blockquote><p>优先队列好像就是堆的别名啊？其实不然。你可以把优先队列当成是一种概念，那它的定义就是一种可以实现根据优先级出队的结构。而堆只是实现优先队列的其中一种方式，当然也是最普遍的方式。</p></blockquote><h2 id="实现一个最-小-大堆"><a href="#实现一个最-小-大堆" class="headerlink" title="实现一个最(小)大堆"></a>实现一个最(小)大堆</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Heap</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">heap</span>: T[] = [];</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">getNumberForCompare</span>: <span class="function">(<span class="params">val: T</span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="title function_">compare</span>(<span class="attr">indexA</span>: <span class="built_in">number</span>, <span class="attr">indexB</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">getNumberForCompare: (val: T) =&gt; <span class="built_in">number</span>, values: T[] = []</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getNumberForCompare</span> = getNumberForCompare;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">heapify</span>(values);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 交换堆内元素</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">swap</span>(<span class="params">indexA: <span class="built_in">number</span>, indexB: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> temp = <span class="variable language_">this</span>.<span class="property">heap</span>[indexA];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">heap</span>[indexA] = <span class="variable language_">this</span>.<span class="property">heap</span>[indexB];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">heap</span>[indexB] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取左孩子的索引</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">getLeftChildIndex</span>(<span class="params">index: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取右孩子的索引</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">getRightChildIndex</span>(<span class="params">index: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取父亲节点的索引</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">getParentIndex</span>(<span class="params">index: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> (index - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化建堆</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">heapify</span>(<span class="params">values: T[]</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">heap</span> = values;</span><br><span class="line">    <span class="comment">// 完全二叉树的叶子节点的个数是总节点个数的一半。</span></span><br><span class="line">    <span class="comment">// 叶子节点本身不需要堆化。只需要等待后面的节点堆化。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span> &gt;&gt;&gt; <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">heapifyDown</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向上维护堆</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">heapifyUp</span>(<span class="params">index: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentIndex = index;</span><br><span class="line">    <span class="keyword">let</span> parentIndex = <span class="variable language_">this</span>.<span class="title function_">getParentIndex</span>(currentIndex);</span><br><span class="line">    <span class="keyword">while</span> (parentIndex &gt;= <span class="number">0</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">compare</span>(currentIndex, parentIndex)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">swap</span>(currentIndex, parentIndex);</span><br><span class="line">      currentIndex = parentIndex;</span><br><span class="line">      parentIndex = <span class="variable language_">this</span>.<span class="title function_">getParentIndex</span>(parentIndex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向下维护堆</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">heapifyDown</span>(<span class="params">index: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentIndex = index;</span><br><span class="line">    <span class="keyword">let</span> lChildIndex = <span class="variable language_">this</span>.<span class="title function_">getLeftChildIndex</span>(currentIndex);</span><br><span class="line">    <span class="keyword">let</span> rChildIndex = <span class="variable language_">this</span>.<span class="title function_">getRightChildIndex</span>(currentIndex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> size = <span class="variable language_">this</span>.<span class="title function_">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前值大于左孩子</span></span><br><span class="line">    <span class="keyword">if</span> (lChildIndex &lt; size &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">compare</span>(lChildIndex, currentIndex)) &#123;</span><br><span class="line">      currentIndex = lChildIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前值大于右孩子</span></span><br><span class="line">    <span class="keyword">if</span> (rChildIndex &lt; size &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">compare</span>(rChildIndex, currentIndex)) &#123;</span><br><span class="line">      currentIndex = rChildIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前索引被替换</span></span><br><span class="line">    <span class="keyword">if</span> (currentIndex !== index) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">swap</span>(currentIndex, index);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">heapifyDown</span>(currentIndex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取堆的大小</span></span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断堆是否为空</span></span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插入元素</span></span><br><span class="line">  <span class="title function_">insert</span>(<span class="attr">value</span>: T): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">push</span>(value);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">heapifyUp</span>(<span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除堆顶元素</span></span><br><span class="line">  <span class="title function_">extract</span>(): T &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">size</span>() === <span class="number">1</span>) <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">shift</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换堆顶和堆尾元素</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">swap</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 剔除最小元素</span></span><br><span class="line">    <span class="keyword">const</span> top = <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="comment">// 重新堆化</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">heapifyDown</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取堆顶元素</span></span><br><span class="line">  <span class="title function_">top</span>(): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">isEmpty</span>() ? <span class="literal">null</span> : <span class="variable language_">this</span>.<span class="property">heap</span>[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取堆内元素</span></span><br><span class="line">  <span class="title function_">values</span>(): T[] &#123;</span><br><span class="line">    <span class="keyword">return</span> [...<span class="variable language_">this</span>.<span class="property">heap</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小顶堆</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">MinHeap</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Heap</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">compare</span>(<span class="attr">indexA</span>: <span class="built_in">number</span>, <span class="attr">indexB</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">getNumberForCompare</span>(<span class="variable language_">this</span>.<span class="property">heap</span>[indexA]) &lt;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">getNumberForCompare</span>(<span class="variable language_">this</span>.<span class="property">heap</span>[indexB])</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大顶堆</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">MaxHeap</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Heap</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">compare</span>(<span class="attr">indexA</span>: <span class="built_in">number</span>, <span class="attr">indexB</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">getNumberForCompare</span>(<span class="variable language_">this</span>.<span class="property">heap</span>[indexA]) &gt;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">getNumberForCompare</span>(<span class="variable language_">this</span>.<span class="property">heap</span>[indexB])</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.davideaversa.it/blog/typescript-binary-heap/">Typescript binary heap</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;完全二叉树&quot;&gt;&lt;a href=&quot;#完全二叉树&quot; class=&quot;headerlink&quot; title=&quot;完全二叉树&quot;&gt;&lt;/a&gt;完全二叉树&lt;/h2&gt;&lt;p&gt;完全二叉树是满二叉树的一种退化。它只缺少最后一排最右边的一些元素。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/</summary>
      
    
    
    
    
    <category term="算法与数据结构" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Express Koa Redux 中间件原理分析</title>
    <link href="http://yoursite.com/2021/04/10/Express-Koa-Redux%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2021/04/10/Express-Koa-Redux%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2021-04-10T12:23:57.000Z</published>
    <updated>2022-02-06T04:09:36.889Z</updated>
    
    <content type="html"><![CDATA[<p>最早接触中间件，是在第一次使用 express 框架的时候，那时对中间件的作用有了了解，后面再使用 Koa 框架时，也遇到了中间件，最大的使用感受就是中间件的参数不一样了，可以使用<code>await</code>语法来执行<code>next()</code>函数。几乎于此同时，使用的 Redux 也提出了中间件的概念。中间件的概念被广泛的采用，一定有其优势所在。<br>本篇文章尝试分析和比较 Express Koa2 Redux 这三个框架的实现原理。</p><p>调试这三个框架的源码其实非常简单。</p><ol><li>书写一个 js 文件，编写代码。</li><li>使用 vscode 的 debug 功能启动代码。</li><li>使用 curl 请求 localhost。</li></ol><h2 id="Express-的中间件"><a href="#Express-的中间件" class="headerlink" title="Express 的中间件"></a>Express 的中间件</h2><p>express 是内置路由功能的，并且同时内置了<code>static</code>,<code>json</code>,<code>urlencoded</code> 这三个中间件。</p><p>下面是启动一个 express app 并注册 App-Level middleware 的代码。通过这段代码来分析 express 启动和中间件运行流程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// express相当于一个工厂函数，它会返回一个函数，也就是app</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span> <span class="title function_">middlewareA</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span> <span class="title function_">middlewareB</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span> <span class="title function_">middlewareC</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>以上代码返回了一个 express 实例，不过这个实例，是一个挂载了很多属性的函数。下面是<code>express()</code>的调用，在源码中就是<code>createApplication()</code>的调用。如下是源码部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// express/lib/express.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createApplication</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 定义app是一个函数。</span></span><br><span class="line">  <span class="keyword">var</span> app = <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    <span class="comment">// app.handle 是通过mixin的方式组合进来的</span></span><br><span class="line">    app.<span class="title function_">handle</span>(req, res, next);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用组合的方式，给app这个函数上挂载通用方法。</span></span><br><span class="line">  <span class="title function_">mixin</span>(app, <span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="literal">false</span>);</span><br><span class="line">  <span class="title function_">mixin</span>(app, proto, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// expose the prototype that will get set on requests</span></span><br><span class="line">  app.<span class="property">request</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(req, &#123;</span><br><span class="line">    <span class="attr">app</span>: &#123; <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">value</span>: app &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// expose the prototype that will get set on responses</span></span><br><span class="line">  app.<span class="property">response</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(res, &#123;</span><br><span class="line">    <span class="attr">app</span>: &#123; <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">value</span>: app &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  app.<span class="title function_">init</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回app函数</span></span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>app 通过 mixin 的方式挂载了很多的方法，其中就包含了 <code>use</code> 和 <code>listen</code> 方法。他们的源码如下。精简了一下代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// express/lib/application.js</span></span><br><span class="line">app.<span class="property">use</span> = <span class="keyword">function</span> <span class="title function_">use</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> path = <span class="string">&quot;/&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setup router</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">lazyrouter</span>();</span><br><span class="line">  <span class="keyword">var</span> router = <span class="variable language_">this</span>.<span class="property">_router</span>;</span><br><span class="line"></span><br><span class="line">  fns.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断当前的中间件函数不是express app</span></span><br><span class="line">    <span class="keyword">if</span> (!fn || !fn.<span class="property">handle</span> || !fn.<span class="property">set</span>) &#123;</span><br><span class="line">      <span class="comment">// 把中间件挂载到路由的跟路径下。</span></span><br><span class="line">      <span class="keyword">return</span> router.<span class="title function_">use</span>(path, fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面可以看到，router 很重要，即使是 App-Level 中间件，也是挂载到 router 上的。下面看一下 router 的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// express/lib/router/index.js</span></span><br><span class="line">proto.<span class="property">use</span> = <span class="keyword">function</span> <span class="title function_">use</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> offset = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> path = <span class="string">&quot;/&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// default path to &#x27;/&#x27;</span></span><br><span class="line">  <span class="comment">// disambiguate router.use([fn])</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> arg = fn;</span><br><span class="line">    <span class="keyword">while</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arg) &amp;&amp; arg.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">      arg = arg[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// first arg is the path</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      offset = <span class="number">1</span>;</span><br><span class="line">      path = fn;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> callbacks = <span class="title function_">flatten</span>(slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, offset));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; callbacks.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> fn = callbacks[i];</span><br><span class="line">    <span class="comment">// 根据path和中间件函数生成一个layer实例</span></span><br><span class="line">    <span class="comment">// 这里layer大概就是，根据path将处理流程分为一个一个层。</span></span><br><span class="line">    <span class="keyword">var</span> layer = <span class="keyword">new</span> <span class="title class_">Layer</span>(</span><br><span class="line">      path,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">sensitive</span>: <span class="variable language_">this</span>.<span class="property">caseSensitive</span>,</span><br><span class="line">        <span class="attr">strict</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">end</span>: <span class="literal">false</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      fn</span><br><span class="line">    );</span><br><span class="line">    layer.<span class="property">route</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 最后将layer推入一个栈中。相当于把中间件保存了起来。</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">push</span>(layer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面 router 的代码，就是最终实现了 <code>app.use</code> 方法保存中间件函数的逻辑。如果断点调试，会发现一个有趣的事实，就是在我们的 <code>middlewareA</code> 中间件之前，express 已经加入了两个默认的 layer。如下图<br><img src="/images/image-20210410135049145.png" alt="image-20210410135049145"></p><p>下面再来看下程序运行并收到请求后的执行流程。首先是 <code>app.listen</code>，通过 http.createServer 构造了一个 server 实例，实例的回调函数，就是 app 本身，这种写法也是非常骚了，把一个 app 函数玩弄于股掌之间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="property">listen</span> = <span class="keyword">function</span> <span class="title function_">listen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> server = http.<span class="title function_">createServer</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">return</span> server.<span class="property">listen</span>.<span class="title function_">apply</span>(server, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从 <code>createApplication</code> 函数中可以看到，app 函数本身，就是调用了 <code>app.handle</code>,而 <code>app.handle</code> 又是调用了<code>router.handle</code> 囧。所以我们的每个请求，其实最终就是由 <code>router.handle</code> 来处理了，并且会在这里展开对所有中间件的调用。<br>这个代码很长，我们精简一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// express/lib/router/index.js</span></span><br><span class="line">proto.<span class="property">handle</span> = <span class="keyword">function</span> <span class="title function_">handle</span>(<span class="params">req, res, out</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> protohost = <span class="title function_">getProtohost</span>(req.<span class="property">url</span>) || <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> removed = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> slashAdded = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> paramcalled = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// store options for OPTIONS request</span></span><br><span class="line">  <span class="comment">// only used if OPTIONS request</span></span><br><span class="line">  <span class="keyword">var</span> options = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// middleware and routes</span></span><br><span class="line">  <span class="keyword">var</span> stack = self.<span class="property">stack</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// manage inter-router variables</span></span><br><span class="line">  <span class="keyword">var</span> done = <span class="title function_">restore</span>(out, req, <span class="string">&quot;baseUrl&quot;</span>, <span class="string">&quot;next&quot;</span>, <span class="string">&quot;params&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setup next layer</span></span><br><span class="line">  req.<span class="property">next</span> = next;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> layerError = err === <span class="string">&quot;route&quot;</span> ? <span class="literal">null</span> : err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// signal to exit router</span></span><br><span class="line">    <span class="keyword">if</span> (layerError === <span class="string">&quot;router&quot;</span>) &#123;</span><br><span class="line">      <span class="title function_">setImmediate</span>(done, <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no more matching layers</span></span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= stack.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="title function_">setImmediate</span>(done, layerError);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get pathname of request</span></span><br><span class="line">    <span class="keyword">var</span> path = <span class="title function_">getPathname</span>(req);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (path == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">done</span>(layerError);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find next matching layer</span></span><br><span class="line">    <span class="keyword">var</span> layer;</span><br><span class="line">    <span class="keyword">var</span> match;</span><br><span class="line">    <span class="keyword">var</span> route;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (match !== <span class="literal">true</span> &amp;&amp; idx &lt; stack.<span class="property">length</span>) &#123;</span><br><span class="line">      layer = stack[idx++];</span><br><span class="line">      match = <span class="title function_">matchLayer</span>(layer, path);</span><br><span class="line">      route = layer.<span class="property">route</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> match !== <span class="string">&quot;boolean&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// hold on to layerError</span></span><br><span class="line">        layerError = layerError || match;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (match !== <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!route) &#123;</span><br><span class="line">        <span class="comment">// process non-route handlers normally</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (layerError) &#123;</span><br><span class="line">        <span class="comment">// routes do not match with a pending error</span></span><br><span class="line">        match = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> method = req.<span class="property">method</span>;</span><br><span class="line">      <span class="keyword">var</span> has_method = route.<span class="title function_">_handles_method</span>(method);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// build up automatic options response</span></span><br><span class="line">      <span class="keyword">if</span> (!has_method &amp;&amp; method === <span class="string">&quot;OPTIONS&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_">appendMethods</span>(options, route.<span class="title function_">_options</span>());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// don&#x27;t even bother matching route</span></span><br><span class="line">      <span class="keyword">if</span> (!has_method &amp;&amp; method !== <span class="string">&quot;HEAD&quot;</span>) &#123;</span><br><span class="line">        match = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no match</span></span><br><span class="line">    <span class="keyword">if</span> (match !== <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">done</span>(layerError);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// store route for dispatch on change</span></span><br><span class="line">    <span class="keyword">if</span> (route) &#123;</span><br><span class="line">      req.<span class="property">route</span> = route;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Capture one-time layer values</span></span><br><span class="line">    req.<span class="property">params</span> = self.<span class="property">mergeParams</span></span><br><span class="line">      ? <span class="title function_">mergeParams</span>(layer.<span class="property">params</span>, parentParams)</span><br><span class="line">      : layer.<span class="property">params</span>;</span><br><span class="line">    <span class="keyword">var</span> layerPath = layer.<span class="property">path</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this should be done for the layer</span></span><br><span class="line">    self.<span class="title function_">process_params</span>(layer, paramcalled, req, res, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">next</span>(layerError || err);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (route) &#123;</span><br><span class="line">        <span class="keyword">return</span> layer.<span class="title function_">handle_request</span>(req, res, next);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="title function_">trim_prefix</span>(layer, layerError, layerPath, path);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (layerError) &#123;</span><br><span class="line">      layer.<span class="title function_">handle_error</span>(layerError, req, res, next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      layer.<span class="title function_">handle_request</span>(req, res, next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，关键的就是 next 函数了，next 函数引用了一个外部变量 idx ，形成了一个包含 idx 的闭包，next 函数每次执行，都会找到下一个需要执行的中间件(layer), 然后执行 <code>layer.handle_request(req, res, next);</code> , 在执行的过程中，将 next 函数本身作为参数传递，这样当中间件执行 next 的时候，又会重复上述过程。通过 next 的执行，串起了一个一个中间件。</p><h3 id="Express-中间件的总结"><a href="#Express-中间件的总结" class="headerlink" title="Express 中间件的总结"></a>Express 中间件的总结</h3><p>第一段代码的输出为 <code>1 3 4 2</code>, 其实也可以说 express 的中间件执行顺序类似与洋葱圈模型。但是，express 结束请求，返回响应的标志是 <code>res.send</code> ，也就是说一旦调用了 <code>res.send</code>,那么响应也就结束了，虽然后序的代码仍然会继续执行。但是已经影响不到响应了。这也是和 koa 的一个重要区别。</p><p>另一个要说明的就是，express 相对于 koa，内置了路由系统，甚至中间件也是挂载在路由上的，因此源代码比 koa 更加复杂。express 成型的时间比较早，内部的写法还都是函数，也没有明显的使用 promise async await 等先进的特性。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>[1] <a href="http://expressjs.com/en/guide/using-middleware.html">express</a></li><li>[2] <a href="https://cloud.tencent.com/developer/article/1467268">koa 和 express 中间件揭秘</a></li><li>[3] <a href="https://zhuanlan.zhihu.com/p/87079561">express 和 koa 的区别</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最早接触中间件，是在第一次使用 express 框架的时候，那时对中间件的作用有了了解，后面再使用 Koa 框架时，也遇到了中间件，最大的使用感受就是中间件的参数不一样了，可以使用&lt;code&gt;await&lt;/code&gt;语法来执行&lt;code&gt;next()&lt;/code&gt;函数。几乎</summary>
      
    
    
    
    
    <category term="中间件" scheme="http://yoursite.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
    <category term="koa" scheme="http://yoursite.com/tags/koa/"/>
    
    <category term="redux" scheme="http://yoursite.com/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>二叉树系列</title>
    <link href="http://yoursite.com/2021/04/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%97/"/>
    <id>http://yoursite.com/2021/04/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%97/</id>
    <published>2021-04-07T09:51:15.000Z</published>
    <updated>2022-02-06T04:09:36.889Z</updated>
    
    <content type="html"><![CDATA[<p>(搜索)二叉树这种数据结构，操作和判断特别多，这篇文章归纳和整理一下它的常见操作。一个有趣的现象是，关于二叉树，有广度优先和深度优先两种搜索办法。如果是广度优先，常规做法是使用一个辅助队列 queue。如果是深度优先，常规做法是使用递归。</p><ul><li>验证二叉搜索树</li><li>对称二叉树</li><li>二叉树的前中后序遍历</li><li>二叉树的层次遍历&#x2F;锯形层次遍历</li><li>二叉树最近公共祖先</li><li>二叉树最大&#x2F;最小深度</li><li>删除二叉树中的节点</li><li>从中序遍历和后序遍历构造二叉树</li></ul><h2 id="验证二叉搜索树-98"><a href="#验证二叉搜索树-98" class="headerlink" title="验证二叉搜索树 98"></a>验证二叉搜索树 98</h2><p>验证一棵树是否为二叉搜索树，有两种方法。都是基于二叉搜索树的特征。</p><ul><li>基于二叉搜索树的中序遍历结果是升序序列。<ul><li>中序遍历整个二叉搜索树，遍历的过程中查验是否为升序。</li></ul></li><li>基于节点的左子树中所有的节点的值，均小于当前节点的值；节点的右子树中所有节点的值，均大于当前节点的值。<ul><li>根节点的值的范围为(-Infinity,Infinity)。其左子节点的值应该小于 root.val, 所以范围应该为(-Infinity,root.val)。同理，右子节点的范围应该为(root.val,Infinity)。树上的每个节点都应该满足上面的条件。</li></ul></li></ul><h3 id="递归代码"><a href="#递归代码" class="headerlink" title="递归代码"></a>递归代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">helper</span>(<span class="params">root: TreeNode | <span class="literal">null</span>, min: <span class="built_in">number</span>, max: <span class="built_in">number</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 不满足条件</span></span><br><span class="line">  <span class="keyword">if</span> (root.<span class="property">val</span> &lt;= min || root.<span class="property">val</span> &gt;= max) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 递归验证左右孩子是否满足条件</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">helper</span>(root.<span class="property">left</span>, min, root.<span class="property">val</span>) &amp;&amp; <span class="title function_">helper</span>(root.<span class="property">right</span>, root.<span class="property">val</span>, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isValidBST</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="comment">// root节点的取值范围为(-Infinity,Infinity)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">helper</span>(root, -<span class="title class_">Infinity</span>, <span class="title class_">Infinity</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对称二叉树-剑指-offer28"><a href="#对称二叉树-剑指-offer28" class="headerlink" title="对称二叉树 剑指 offer28"></a>对称二叉树 剑指 offer28</h2><p>验证一个树是否为对称二叉树，优雅的方案还是递归，毕竟要一层一层的比较，而且每次比较的模式都是一样的。</p><h3 id="递归代码-1"><a href="#递归代码-1" class="headerlink" title="递归代码"></a>递归代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">helper</span>(<span class="params">left: TreeNode | <span class="literal">null</span>, right: TreeNode | <span class="literal">null</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!left &amp;&amp; !right) &#123;</span><br><span class="line">    <span class="comment">// 都不存在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &amp;&amp; right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left.<span class="property">val</span> === right.<span class="property">val</span>) &#123;</span><br><span class="line">      <span class="comment">// 当前两个节点是对称的，继续去验证他们的孩子是否对称</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">helper</span>(left.<span class="property">left</span>, right.<span class="property">right</span>) &amp;&amp; <span class="title function_">helper</span>(left.<span class="property">right</span>, right.<span class="property">left</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不对称相等</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// left或者right，只存在一个</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isSymmetric</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">helper</span>(root, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的前中后序遍历-94"><a href="#二叉树的前中后序遍历-94" class="headerlink" title="二叉树的前中后序遍历 94"></a>二叉树的前中后序遍历 94</h2><p>这里以二叉树的中序遍历为例子。使用递归，中序遍历的实现很容易实现（代码简单）。比较难（或者说不容易记住和理解）的是使用迭代的方式来遍历。<br>不过话说回来，明明递归的代码看上去更简洁明了，可能是更符合人们的思维习惯。相反如果是使用迭代，确需要肯定的理解其执行过程 😖。</p><h3 id="递归代码-2"><a href="#递归代码-2" class="headerlink" title="递归代码"></a>递归代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">helper</span>(<span class="params">root: TreeNode | <span class="literal">null</span>, res: <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">helper</span>(root.<span class="property">left</span>, res);</span><br><span class="line">  res.<span class="title function_">push</span>(root.<span class="property">val</span>);</span><br><span class="line">  <span class="title function_">helper</span>(root.<span class="property">right</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inorderTraversal</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">res</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line">  <span class="title function_">helper</span>(root, res);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代代码"><a href="#迭代代码" class="headerlink" title="迭代代码"></a>迭代代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inorderTraversal</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="comment">// 既然是递归，就要用栈来模拟咯</span></span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">while</span> (stack.<span class="property">length</span> || root) &#123;</span><br><span class="line">    <span class="keyword">while</span> (root) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(root);</span><br><span class="line">      root = root.<span class="property">left</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时的root为null，栈顶元素就是最左边的叶子节点</span></span><br><span class="line">    <span class="comment">// 弹出并访问</span></span><br><span class="line">    <span class="keyword">const</span> node = stack.<span class="title function_">pop</span>();</span><br><span class="line">    res.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这一步很关键，开始准备遍历右子树</span></span><br><span class="line">    root = node.<span class="property">right</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h2><ul><li>使用递归，也就是 dfs 深度优先搜索。</li><li>可以使用一个队列来保存被访问的节点，也就是广度优先搜索。</li></ul><h3 id="递归代码-3"><a href="#递归代码-3" class="headerlink" title="递归代码"></a>递归代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">helper</span>(<span class="params">root: TreeNode | <span class="literal">null</span>, index: <span class="built_in">number</span>, res: <span class="built_in">number</span>[][]</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  res[index] ? res[index].<span class="title function_">push</span>(root.<span class="property">val</span>) : (res[index] = [root.<span class="property">val</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">helper</span>(root.<span class="property">left</span>, index + <span class="number">1</span>, res);</span><br><span class="line">  <span class="title function_">helper</span>(root.<span class="property">right</span>, index + <span class="number">1</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">levelOrder</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">number</span>[][] &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="title function_">helper</span>(root, <span class="number">0</span>, res);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代代码-1"><a href="#迭代代码-1" class="headerlink" title="迭代代码"></a>迭代代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">levelOrder</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">number</span>[][] &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">const</span> queue = [root];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">while</span> (queue.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> length = queue.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> temp = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> node = queue.<span class="title function_">shift</span>();</span><br><span class="line">      temp.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">left</span>) queue.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">right</span>) queue.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">push</span>(temp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树最近公共祖先"><a href="#二叉树最近公共祖先" class="headerlink" title="二叉树最近公共祖先"></a>二叉树最近公共祖先</h2><p>前提条件是 p 和 q 都是树中的节点。</p><h3 id="递归代码-4"><a href="#递归代码-4" class="headerlink" title="递归代码"></a>递归代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params"></span></span><br><span class="line"><span class="params">  root: TreeNode | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  p: TreeNode | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  q: TreeNode | <span class="literal">null</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">TreeNode</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">  <span class="keyword">if</span> (root === p || root === q) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> left = <span class="title function_">lowestCommonAncestor</span>(root.<span class="property">left</span>, p, q);</span><br><span class="line">  <span class="keyword">const</span> right = <span class="title function_">lowestCommonAncestor</span>(root.<span class="property">right</span>, p, q);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (left &amp;&amp; right) &#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left) &#123;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><p>递归求出左右子树深度的最大值，然后加 1。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">maxDepth</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="title function_">maxDepth</span>(root.<span class="property">left</span>), <span class="title function_">maxDepth</span>(root.<span class="property">right</span>)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">minDepth</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!root.<span class="property">left</span> &amp;&amp; !root.<span class="property">right</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> min = <span class="title class_">Infinity</span>;</span><br><span class="line">  <span class="keyword">if</span> (root.<span class="property">left</span>) &#123;</span><br><span class="line">    min = <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="title function_">minDepth</span>(root.<span class="property">left</span>), min);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (root.<span class="property">right</span>) &#123;</span><br><span class="line">    min = <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="title function_">minDepth</span>(root.<span class="property">right</span>), min);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> min + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;(搜索)二叉树这种数据结构，操作和判断特别多，这篇文章归纳和整理一下它的常见操作。一个有趣的现象是，关于二叉树，有广度优先和深度优先两种搜索办法。如果是广度优先，常规做法是使用一个辅助队列 queue。如果是深度优先，常规做法是使用递归。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;验证二叉</summary>
      
    
    
    
    
    <category term="算法与数据结构" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>常用React hooks</title>
    <link href="http://yoursite.com/2021/04/05/%E5%B8%B8%E7%94%A8React-hooks/"/>
    <id>http://yoursite.com/2021/04/05/%E5%B8%B8%E7%94%A8React-hooks/</id>
    <published>2021-04-05T21:32:11.000Z</published>
    <updated>2022-02-06T04:09:36.889Z</updated>
    
    <content type="html"><![CDATA[<p>React hooks 已经很普及了。记录和整理一些比较通用的 hook。</p><h2 id="useMount"><a href="#useMount" class="headerlink" title="useMount"></a>useMount</h2><p>返回组件挂载的状态。可以在一些异步处理之后，判断组件是否已经被卸载。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> mount = <span class="title function_">useRef</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    mount.<span class="property">current</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      mount.<span class="property">current</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> mount.<span class="property">current</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="usePreProps"><a href="#usePreProps" class="headerlink" title="usePreProps"></a>usePreProps</h2><p>返回上一次的 props，也可以用来判断某个 props 是否改变。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">usePreProps</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = <span class="title function_">useRef</span>(props);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    ref.<span class="property">current</span> = props;</span><br><span class="line">  &#125;, [props]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return ref.current === props; // 判断属性是否改变</span></span><br><span class="line">  <span class="keyword">return</span> ref.<span class="property">current</span>; <span class="comment">// 返回上一次的属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="useOnScreen"><a href="#useOnScreen" class="headerlink" title="useOnScreen"></a>useOnScreen</h2><p>返回组件是否曝光。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">useOnScreen</span> = (<span class="params">ref: React.RefObject&lt;<span class="built_in">any</span>&gt;, rootMargin = <span class="string">&quot;0px&quot;</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!ref || !ref.<span class="property">current</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [intersecting, setIntersecting] = <span class="title function_">useState</span>(<span class="literal">false</span>); <span class="comment">// 是否已经曝光</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ovserver = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(</span><br><span class="line">      <span class="function">(<span class="params">[entry]</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setIntersecting</span>(entry.<span class="property">isIntersecting</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123; rootMargin &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    ovserver.<span class="title function_">observe</span>(ref.<span class="property">current</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      observer.<span class="title function_">unobserve</span>(ref.<span class="property">current</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [intersecting];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;React hooks 已经很普及了。记录和整理一些比较通用的 hook。&lt;/p&gt;
&lt;h2 id=&quot;useMount&quot;&gt;&lt;a href=&quot;#useMount&quot; class=&quot;headerlink&quot; title=&quot;useMount&quot;&gt;&lt;/a&gt;useMount&lt;/h2&gt;&lt;p&gt;返</summary>
      
    
    
    
    
    <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-n数之和系列</title>
    <link href="http://yoursite.com/2021/03/26/leetcode-N%E6%95%B0%E4%B9%8B%E5%92%8C%E7%B3%BB%E5%88%97/"/>
    <id>http://yoursite.com/2021/03/26/leetcode-N%E6%95%B0%E4%B9%8B%E5%92%8C%E7%B3%BB%E5%88%97/</id>
    <published>2021-03-26T09:17:51.000Z</published>
    <updated>2022-02-06T04:09:36.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="N-数之和系列"><a href="#N-数之和系列" class="headerlink" title="N 数之和系列"></a>N 数之和系列</h1><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>给定一个数组，一个 target，找到数组中所有两个数字之和为 target 的组合。这里为了后面 N 数之和做准备，不是返回一个组合。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">twoSum</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="built_in">number</span>[][] &#123;</span><br><span class="line">  <span class="comment">// 先排序数组</span></span><br><span class="line">  nums.<span class="title function_">sorts</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 双指针遍历</span></span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">const</span> lVal = nums[left];</span><br><span class="line">    <span class="keyword">const</span> rVal = nums[right];</span><br><span class="line">    <span class="keyword">if</span> (lVal + rVal === target) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>([lVal, rVal]);</span><br><span class="line">      <span class="comment">// 排除重复的</span></span><br><span class="line">      <span class="keyword">while</span> (nums[left] === lVal) left++;</span><br><span class="line">      <span class="keyword">while</span> (nums[right] === rVal) right--;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lVal + rVal &lt; target) &#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p>有了两数之和，三数之和的计算就可以依赖现有的两数之和的函数，但是要稍微改造一下。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更加泛型（通用）的两数之和函数</span></span><br><span class="line"><span class="comment">// 默认数组已经排序</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">twoSum</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span>, start: <span class="built_in">number</span></span>): <span class="built_in">number</span>[][] &#123;</span><br><span class="line">  <span class="comment">// 双指针遍历</span></span><br><span class="line">  <span class="keyword">let</span> left = start;</span><br><span class="line">  <span class="keyword">let</span> right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">const</span> lVal = nums[left];</span><br><span class="line">    <span class="keyword">const</span> rVal = nums[right];</span><br><span class="line">    <span class="keyword">if</span> (lVal + rVal === target) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>([lVal, rVal]);</span><br><span class="line">      <span class="comment">// 排除重复的</span></span><br><span class="line">      <span class="keyword">while</span> (nums[left] === lVal) left++;</span><br><span class="line">      <span class="keyword">while</span> (nums[right] === rVal) right--;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lVal + rVal &lt; target) &#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">threeSum</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span>[][] &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> &lt; <span class="number">3</span>) <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">  nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 遍历第一个数字，下面要求两数之和，和为target-nums[i]</span></span><br><span class="line">    <span class="keyword">const</span> newTarget = <span class="number">0</span> - nums[i];</span><br><span class="line">    <span class="keyword">const</span> newStart = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> temp = <span class="title function_">twoSum</span>(nums, newTarget, newStart);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; temp.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>([nums[i], ...temp[j]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去除重复的结果</span></span><br><span class="line">    <span class="keyword">while</span> (nums[i] === nums[i + <span class="number">1</span>]) i++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="N-数之和"><a href="#N-数之和" class="headerlink" title="N 数之和"></a>N 数之和</h2><p>有了上面的例子，继而推演出 N 数之和的通用方法，也就有了思路。每次确定一个数字，最终只剩两个数字的时候，就是调用两数之和的时候。需要注意的是，常规的想法是 N 是几，就进行 N-1 层遍历。这里 N 是未知的。不过可以使用递归，来一层一层的减少 N</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更加泛型（通用）的两数之和函数</span></span><br><span class="line"><span class="comment">// 默认数组已经排序</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">twoSum</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span>, start: <span class="built_in">number</span></span>): <span class="built_in">number</span>[][] &#123;</span><br><span class="line">  <span class="comment">// 双指针遍历</span></span><br><span class="line">  <span class="keyword">let</span> left = start;</span><br><span class="line">  <span class="keyword">let</span> right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">const</span> lVal = nums[left];</span><br><span class="line">    <span class="keyword">const</span> rVal = nums[right];</span><br><span class="line">    <span class="keyword">if</span> (lVal + rVal === target) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>([lVal, rVal]);</span><br><span class="line">      <span class="comment">// 排除重复的</span></span><br><span class="line">      <span class="keyword">while</span> (nums[left] === lVal) left++;</span><br><span class="line">      <span class="keyword">while</span> (nums[right] === rVal) right--;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lVal + rVal &lt; target) &#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里数组已经排序</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">nSum</span>(<span class="params"></span></span><br><span class="line"><span class="params">  nums: <span class="built_in">number</span>[][],</span></span><br><span class="line"><span class="params">  target: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  n: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  start: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  visited: <span class="built_in">number</span>[],</span></span><br><span class="line"><span class="params">  ans: <span class="built_in">number</span>[][] = []</span></span><br><span class="line"><span class="params"></span>): <span class="built_in">number</span>[][] &#123;</span><br><span class="line">  <span class="comment">// 注意这里是大于</span></span><br><span class="line">  <span class="keyword">if</span> (n + start &gt; nums.<span class="property">length</span>) <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 可以调用两数之和</span></span><br><span class="line">    <span class="keyword">const</span> temp = <span class="title function_">twoSum</span>(nums, target, start);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; temp.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      ans.<span class="title function_">push</span>([...visited, ...temp[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// n大于2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> newTarget = target - nums[i];</span><br><span class="line">      <span class="keyword">const</span> newN = n - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">const</span> newStart = i + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">const</span> newVisited = [...visited, nums[i]];</span><br><span class="line">      <span class="title function_">nSum</span>(nums, newTarget, newN, newStart, newVisited, ans);</span><br><span class="line">      <span class="comment">// 去除重复的</span></span><br><span class="line">      <span class="keyword">while</span> (nums[i] === nums[i + <span class="number">1</span>]) i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如求四数之和</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fourSum</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="built_in">number</span>[][] &#123;</span><br><span class="line">  nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">nSum</span>(nums, target, <span class="number">4</span>, <span class="number">0</span>, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;N-数之和系列&quot;&gt;&lt;a href=&quot;#N-数之和系列&quot; class=&quot;headerlink&quot; title=&quot;N 数之和系列&quot;&gt;&lt;/a&gt;N 数之和系列&lt;/h1&gt;&lt;h2 id=&quot;两数之和&quot;&gt;&lt;a href=&quot;#两数之和&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-买卖股票的最佳时机系列(121,122,123,188)</title>
    <link href="http://yoursite.com/2021/03/14/leetcode-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E7%B3%BB%E5%88%97/"/>
    <id>http://yoursite.com/2021/03/14/leetcode-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E7%B3%BB%E5%88%97/</id>
    <published>2021-03-14T18:32:46.000Z</published>
    <updated>2022-02-06T04:09:36.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="121-买卖股票的最佳时机-I"><a href="#121-买卖股票的最佳时机-I" class="headerlink" title="121 买卖股票的最佳时机 I"></a>121 买卖股票的最佳时机 I</h1><p>给定一只股票，但是只能买卖一次。</p><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>进行两层循环，第一层循环是买入的日子，第二层循环是卖出的日子，遍历左右的利润，求出最大值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">maxProfit</span>(<span class="params">prices: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (prices.<span class="property">length</span> &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> length = prices.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> profit = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">      profit = <span class="title class_">Math</span>.<span class="title function_">max</span>(profit, prices[j] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>进行一次遍历，在遍历的过程中修改变量，一个是当前最低的价格，一个是当前的利润。<br>如果当前价格低于最低价格，则更新最低价格。用当前的价格减去最低价格，即是这一天能够获得的最大利润。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">maxProfit</span>(<span class="params">prices: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (prices.<span class="property">length</span> &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> length = prices.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> profit = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prices[i] &lt; minPrice) &#123;</span><br><span class="line">      minPrice = prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">    profit = <span class="title class_">Math</span>.<span class="title function_">max</span>(profit, prices[i] - minPrice);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122 买卖股票的最佳时机 II"></a>122 买卖股票的最佳时机 II</h1><h2 id="暴力法-1"><a href="#暴力法-1" class="headerlink" title="暴力法"></a>暴力法</h2><p>对于每个股票交易日，都有两种选择，一种是按兵不动，即不进行任何操作。还有一种是根据当前股票的持有情况，进入买进或者卖出，比如当前持有股票就可以卖出，当前没有股票就进行买入。</p><p>每一个交日易都有不同的选择，一次一次的选择形成了一棵操作树，这是典型的 dfs 了。</p><h3 id="暴力法代码"><a href="#暴力法代码" class="headerlink" title="暴力法代码"></a>暴力法代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">maxProfit</span>(<span class="params">prices: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> length = prices.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// status:0代表手上没有股票，可以买。1代表手上有股票，可以卖。</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">count: <span class="built_in">number</span>, profit: <span class="built_in">number</span>, status: <span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (count === length) &#123;</span><br><span class="line">      max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, profit);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按兵不动</span></span><br><span class="line">    <span class="title function_">dfs</span>(count + <span class="number">1</span>, profit, status);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行操作</span></span><br><span class="line">    <span class="keyword">if</span> (status === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 进行买入，利润要减掉当前价格</span></span><br><span class="line">      <span class="title function_">dfs</span>(count + <span class="number">1</span>, profit - prices[count], <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 进行卖出，利润要加上当前价格</span></span><br><span class="line">      <span class="title function_">dfs</span>(count + <span class="number">1</span>, profit + prices[count], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>这个问题，可以使用贪心算法，即根据当日的价格来决定上个交易日是否进行买入，只要今天的价格比昨天高，就昨天买日，今天卖出。当然现实情况下，是不可能买入昨天的股票的。</p><h3 id="贪心法代码"><a href="#贪心法代码" class="headerlink" title="贪心法代码"></a>贪心法代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">maxProfit</span>(<span class="params">prices: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!prices || prices.<span class="property">length</span> &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> profit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      profit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>如果使用动态规划来解决这个问题，那么需要保存一个二维的状态，dp[i][j]。<br>dp[i][0] 代表第 i 天，手上没有股票时的收益。dp[i][1]代表第 i 天手上有股票的收益。<br>那么推导一下状态方程就是</p><ul><li>dp[i][0] &#x3D; Math.max(dp[i-1][0],dp[i-1][1]+prices[i])<ul><li>也就是第 i 天手上没有股票时，可以是 i-1 天本来就没有股票，然后第 i 天不进行任何操作，或者是 i-1 天持有股票，然后将其卖出。取两者的最大值。</li></ul></li><li>dp[i][1] &#x3D; Math.max(dp[i-1][1],dp[i-1][0]-prices[i])<ul><li>也就是第 i 天手上有股票时，可以是 i-1 天本来就有股票，然后第 i 天按兵不动，或者第 i-1 天手上没有骨片，然后今天买进。取两者的最大值。</li></ul></li></ul><p>最后我们期望的结果就是 dp[n][0]。也就是最后一天手上没有股票时的金额。<br>可以看出第 n 天的最大收益，是根据之前的每一天的收益情况，一点一点推导出来的。非常经典的动态规划。</p><h3 id="动态规划代码"><a href="#动态规划代码" class="headerlink" title="动态规划代码"></a>动态规划代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">maxProfit</span>(<span class="params">prices: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!prices || prices.<span class="property">length</span> &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dp = prices.<span class="title function_">map</span>(<span class="function">() =&gt;</span> [<span class="number">0</span>, <span class="number">0</span>]);</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dp[prices.<span class="property">length</span> - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123 买卖股票的最佳时机 III"></a>123 买卖股票的最佳时机 III</h1><p>不同于买卖股票的最佳时机 II。这次只能交易两次了。这次我们只选择动态规划来解决这个问题。我们把买进股票作为交易一次股票的标志。</p><h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><p>首先需要增加一个状态，来记录当前已经交易了几次。dp[i][j][k] ,j 代表了是第几次买进股票了。可以的取值为 0，1，2。k 还是代表当前手上是否持有股票，0 表示不持有，1 表示持有。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">maxProfit</span>(<span class="params">prices: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (prices.<span class="property">length</span> &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> length = prices.<span class="property">length</span>;</span><br><span class="line">  <span class="comment">// 初始化三维dp数组</span></span><br><span class="line">  <span class="keyword">const</span> dp = prices.<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="title class_">Array</span>(<span class="number">2</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; j++) &#123;</span><br><span class="line">      dp[i][j] = [];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化状态</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第i天，没有交易股票，手上也没有股票</span></span><br><span class="line">    dp[i][<span class="number">0</span>][<span class="number">1</span>] = -<span class="title class_">Infinity</span>; <span class="comment">// 第i天，没有交易股票，手上有一股，是不可能的。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第1天，买入了j次，手上没有股票</span></span><br><span class="line">    dp[<span class="number">0</span>][j][<span class="number">1</span>] = -pirces[<span class="number">0</span>]; <span class="comment">// 第一天，买入了j次，手上有股票</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span>; j++) &#123;</span><br><span class="line">      dp[i][j][<span class="number">0</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">      dp[i][j][<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 求最后一天，手上没有股票时的最大利润</span></span><br><span class="line">  <span class="keyword">let</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; j++) &#123;</span><br><span class="line">    maxProfit = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxProfit, dp[length - <span class="number">1</span>][j][<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188 买卖股票的最佳时机 IV"></a>188 买卖股票的最佳时机 IV</h1><p>这一次又升级了，可以买卖 k 次</p><h2 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h2><p>状态方程可以参考买卖两次。其实已经将算法范型化，支持将 2 次变成 k 次就可以了。<br>需要注意的是，当 k&gt;&#x3D;len&#x2F;2 的时候，问题相当于变成了可以交易无数次，也就是 122，这时可以直接采用 122 的贪心算法。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greedy</span>(<span class="params">prices: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!prices || prices.<span class="property">length</span> &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> profit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      profit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">maxProfit</span>(<span class="params">k: <span class="built_in">number</span>, prices: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (prices.<span class="property">length</span> &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (k &gt;= prices.<span class="property">length</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="title function_">greedy</span>(prices);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> length = prices.<span class="property">length</span>;</span><br><span class="line">  <span class="comment">// 初始化三维dp数组</span></span><br><span class="line">  <span class="keyword">const</span> dp = prices.<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="title class_">Array</span>(k + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">      dp[i][j] = [];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化状态</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第i天，没有交易股票，手上也没有股票</span></span><br><span class="line">    dp[i][<span class="number">0</span>][<span class="number">1</span>] = -<span class="title class_">Infinity</span>; <span class="comment">// 第i天，没有交易股票，手上有一股，是不可能的。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第1天，买入了j次，手上没有股票</span></span><br><span class="line">    dp[<span class="number">0</span>][j][<span class="number">1</span>] = -prices[<span class="number">0</span>]; <span class="comment">// 第一天，买入了j次，手上有股票</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">      dp[i][j][<span class="number">0</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">      dp[i][j][<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 求最后一天，手上没有股票时的最大利润</span></span><br><span class="line">  <span class="keyword">let</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">    maxProfit = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxProfit, dp[length - <span class="number">1</span>][j][<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;121-买卖股票的最佳时机-I&quot;&gt;&lt;a href=&quot;#121-买卖股票的最佳时机-I&quot; class=&quot;headerlink&quot; title=&quot;121 买卖股票的最佳时机 I&quot;&gt;&lt;/a&gt;121 买卖股票的最佳时机 I&lt;/h1&gt;&lt;p&gt;给定一只股票，但是只能买卖一次。&lt;/</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
