{"meta":{"title":"herrycodelee blog","subtitle":"","description":"","author":"Xiang Li","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2021-04-05T18:46:54.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"进阶中的 web 开发者 ｜ 热爱生活 ｜ 不断学习"},{"title":"书单","date":"2022-05-03T13:54:35.981Z","updated":"2022-05-03T13:54:35.981Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-05-03T13:54:35.981Z","updated":"2022-05-03T13:54:35.981Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-05-03T13:54:36.005Z","updated":"2022-05-03T13:54:36.005Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"极简代码构建用于级联选择器的TreeData数据结构","slug":"两步构建用于级联选择器的TreeData数据结构","date":"2022-05-03T20:05:43.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2022/05/03/两步构建用于级联选择器的TreeData数据结构/","link":"","permalink":"http://yoursite.com/2022/05/03/%E4%B8%A4%E6%AD%A5%E6%9E%84%E5%BB%BA%E7%94%A8%E4%BA%8E%E7%BA%A7%E8%81%94%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84TreeData%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"背景工作中遇到了一个需求，使用 Antd 的 TreeSelect 组件实现一个 gitlab 仓库文件级联选择器。 后端返回的数据结构如下，这是一种扁平的数据结构，每个节点有三个属性。 1234567891011121314151617181920212223242526272829&#123; &quot;tree_nodes&quot;: [ &#123; &quot;name&quot;: &quot;admin&quot;, &quot;type&quot;: &quot;tree&quot;, &quot;path&quot;: &quot;ansible/plays/admin&quot; &#125;, &#123; &quot;name&quot;: &quot;test&quot;, &quot;type&quot;: &quot;blob&quot;, &quot;path&quot;: &quot;ansible/plays/admin/test.yml&quot; &#125;, &#123; &quot;name&quot;: &quot;audit&quot;, &quot;type&quot;: &quot;tree&quot;, &quot;path&quot;: &quot;ansible/plays/audit&quot; &#125;, &#123; &quot;name&quot;: &quot;config.yml&quot;, &quot;type&quot;: &quot;blob&quot;, &quot;path&quot;: &quot;ansible/plays/config.yml&quot; &#125;, &#123; &quot;name&quot;: &quot;debug_gather_facts.yml&quot;, &quot;type&quot;: &quot;blob&quot;, &quot;path&quot;: &quot;ansible/plays/debug_gather_facts.yml&quot; &#125; ]&#125; 但是 Antd 的 TreeSelect 组件的 treeData prop 接收的却是一种如下的树型数据结构。 1234567891011121314151617181920const treeData = [ &#123; title: &quot;Node1&quot;, value: &quot;0-0&quot;, children: [ &#123; title: &quot;Child Node1&quot;, value: &quot;0-0-1&quot;, &#125;, &#123; title: &quot;Child Node2&quot;, value: &quot;0-0-2&quot;, &#125;, ], &#125;, &#123; title: &quot;Node2&quot;, value: &quot;0-1&quot;, &#125;,]; 因此需要前端自己对数据进行一次转换。 TrieTree 字典树其实 Antd 的 treeData 是一种典型的字典树数据结构，如下图。因此问题就抽象成了字典树的构造问题。 构造 treeData构造 treeData 的代码如下，为方便起见，思路直接写在了注释里面，除了入口函数buildTree，只使用了两个工具函数 insert 和 findChild。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162interface RawDataNode &#123; name: string; type: &quot;tree&quot; | &quot;blob&quot;; path: string;&#125;interface TreeNode &#123; title: string; value: string; isLeaf: boolean; children: TreeNode[];&#125;function findChild(node: TreeNode, title: string) &#123; // 从当前node的children中寻找title相同的节点（如果有，代表之前已经创建过同名的节点了）。 return node.children.find((node) =&gt; node.title === title);&#125;function insert(node: TreeNode, data: RawDataNode) &#123; // 2. 将path 拆解为数组，方便进行深度遍历操作，数组里面就是一层一层的文件（夹）名称 const pathArr = data.path.split(&quot;/&quot;); // 3. 用于记录进入到第几层 path，方便在创建child时生成value const temp = []; // 4. 记录当前node let currentNode = node; // 5. 对pathArr进行遍历 for (const pathSlice of pathArr) &#123; // 6. 尝试从当前节点的children中找到title为pathSlice的节点 let child = findChild(currentNode, pathSlice); temp.push(pathSlice); if (!child) &#123; // 7. 如果没有找到，则创建一个新的child，并将它加入node的children child = &#123; title: pathSlice, value: temp.join(&quot;/&quot;), isLeaf: data.type === &quot;blob&quot;, children: [], &#125;; currentNode.children?.push(child); &#125; // 8. 将当前节点指向node，继续下一轮对pathArr的遍历 currentNode = child; &#125;&#125;export function buildTree(tree_nodes: RawDataNode[]): TreeNode[] &#123; const root: TreeNode = &#123; title: &quot;root&quot;, value: &quot;root&quot;, isLeaf: false, children: [], &#125;; // 1. 对原始数据进行遍历并依次插入tree中 tree_nodes.forEach((node) =&gt; insert(root, node)); return root.children;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"前端应用","slug":"前端应用","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/"}]},{"title":"Iterm2 修改默认Key Mappings","slug":"Iterm2-修改默认Key-Mappings","date":"2022-04-24T16:55:12.000Z","updated":"2022-05-03T13:54:35.977Z","comments":true,"path":"2022/04/24/Iterm2-修改默认Key-Mappings/","link":"","permalink":"http://yoursite.com/2022/04/24/Iterm2-%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4Key-Mappings/","excerpt":"","text":"平时使用 Mac 工作，安装了 Iterm2 来取代默认的 Terminal 软件。但是 Iterm2 的按键却非常不符合平时的习惯。 比如删除一整行这个操作 在类似 VSCode 这样的编辑器中，都是使用Cmd + delete这样的按键组合 但是在 Iterm2 中，却是Control + U 这样的按键组合 可以通过如下方式修改 Iterm2 的 Key Mappings 1. 打开 Preferences 2. 进入 Profiles -&gt; Keys -&gt; Key Mappings。选择 Natural Text Editing 大工告成，可以愉快的使用Cmd + delete这样的按键组合了。","categories":[],"tags":[{"name":"奇奇怪怪的问题的解决方案","slug":"奇奇怪怪的问题的解决方案","permalink":"http://yoursite.com/tags/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"Iterm2","slug":"Iterm2","permalink":"http://yoursite.com/tags/Iterm2/"}]},{"title":"Gitkraken 6.5.1版本回退","slug":"Gitkraken-6-5-1版本回退","date":"2022-04-24T16:35:46.000Z","updated":"2022-05-03T13:54:35.977Z","comments":true,"path":"2022/04/24/Gitkraken-6-5-1版本回退/","link":"","permalink":"http://yoursite.com/2022/04/24/Gitkraken-6-5-1%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/","excerpt":"","text":"Gitkraken 是一款 Git 的图形化操作工作，个人很喜欢他的 UI 和操作方式。如下图: 但是最新版的 Gitkraken 要求必须付费才能使用和操作私有仓库。6.5.1 是支持免费私有仓库的最后一个版本。有需要的朋友可以自己选择下载。有条件的朋友也可以支持一下付费最新版。 PS: Gitkraken 有自动更新的功能，如果需要关闭，在不同的操作系统上有不同的方法。不过，通过修改 host 文件，可以一劳永逸。 Gitkraken 6.5.1 官方地址 win-x86: release.axocdn.com&#x2F;win32&#x2F;GitKrakenSetup-6.5.1.exe release.gitkraken.com&#x2F;win32&#x2F;GitKrakenSetup-6.5.1.exe win-x64: release.axocdn.com&#x2F;win64&#x2F;GitKrakenSetup-6.5.1.exe release.gitkraken.com&#x2F;win64&#x2F;GitKrakenSetup-6.5.1.exe linux-deb: release.axocdn.com&#x2F;linux&#x2F;GitKraken-v6.5.1.deb release.gitkraken.com&#x2F;linux&#x2F;GitKraken-v6.5.1.deb linux-rpm: release.axocdn.com&#x2F;linux&#x2F;GitKraken-v6.5.1.rpm release.gitkraken.com&#x2F;linux&#x2F;GitKraken-v6.5.1.rpm linux-tar.gz: release.axocdn.com&#x2F;linux&#x2F;GitKraken-v6.5.1.tar.gz release.gitkraken.com&#x2F;linux&#x2F;GitKraken-v6.5.1.tar.gz mac: release.axocdn.com&#x2F;darwin&#x2F;GitKraken-v6.5.1.zip release.gitkraken.com&#x2F;darwin&#x2F;GitKraken-v6.5.1.zip 配置 host 文件避免软件自动更新1127.0.0.1 release.gitkraken.com api.gitkraken.com","categories":[],"tags":[{"name":"奇奇怪怪的问题的解决方案","slug":"奇奇怪怪的问题的解决方案","permalink":"http://yoursite.com/tags/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}]},{"title":"使用PicGo和Github打造自己的图床","slug":"使用PicGo和Github打造自己的图床","date":"2022-04-24T15:49:21.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2022/04/24/使用PicGo和Github打造自己的图床/","link":"","permalink":"http://yoursite.com/2022/04/24/%E4%BD%BF%E7%94%A8PicGo%E5%92%8CGithub%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"平时在写 blog 的时候，难免会需要使用一些图片，目前是把图片作为静态资源的一部分放在仓库里，但是这种方式的弊端也很明显，如果我想把 blog 发布到不同的平台上，就需要在每个平台分别上传，使用图床来统一管理图片，在不同的平台都可以方便的引用，这样就方便多了。 网上调研了一下，发现用 github 作为图片的存储空间，配合一个叫做 PicGo 的软件，可以很方便的实现我的需求。下面就是具体的操作步骤。 在 github 上创建一个仓库来专门存放我们的图片。 访问：https://github.com/settings/tokens，生成一个token用于PicGo操作你的仓库 然后点击 Generate new token。 把 repo 的勾打上即可。然后翻到页面最底部，点击 Generate token 的绿色按钮生成 token。 配置 PicGo。 注意：仓库名的格式是用户名&#x2F;仓库，比如我创建了一个叫做 test 的仓库，在 PicGo 里我要设定的仓库名就是 Molunerfinn&#x2F;test。 一般我们选择 main 分支即可。然后记得点击确定以生效，然后可以点击设为默认图床来确保上传的图床是 GitHub。","categories":[],"tags":[{"name":"实用工具","slug":"实用工具","permalink":"http://yoursite.com/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"}]},{"title":"一个操作让你的iTerm2更顺手","slug":"一个操作让你的iTerm2更顺手","date":"2022-03-10T11:37:29.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2022/03/10/一个操作让你的iTerm2更顺手/","link":"","permalink":"http://yoursite.com/2022/03/10/%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E8%AE%A9%E4%BD%A0%E7%9A%84iTerm2%E6%9B%B4%E9%A1%BA%E6%89%8B/","excerpt":"","text":"背景使用iTerm2作为 terminal 已经好长时间了。它的界面确实很漂亮，但是用起来一直有一个不顺手的地方，就是如果想要删除一整行已经输入的字符，需要使用的键盘组合是Ctrl + u，这个设计很反直觉，在很多的场景中，这个操作都是使用Cmd + delete这个按键组合的，比如 vscode、文本编辑器、Chrome 地址栏等等。甚至在 vscode 的 terminal 中，也是这个组合。 实现想要让iTerm2的使用更符合我们的直觉，只要修改如下图的配置就可以了。改完之后，溜到飞起。","categories":[],"tags":[{"name":"iTerm2","slug":"iTerm2","permalink":"http://yoursite.com/tags/iTerm2/"}]},{"title":"Understanding RPC Vs REST For HTTP APIs","slug":"Understanding-RPC-Vs-REST-For-HTTP-APIs","date":"2022-02-08T14:26:30.000Z","updated":"2022-05-03T13:54:35.977Z","comments":true,"path":"2022/02/08/Understanding-RPC-Vs-REST-For-HTTP-APIs/","link":"","permalink":"http://yoursite.com/2022/02/08/Understanding-RPC-Vs-REST-For-HTTP-APIs/","excerpt":"","text":"最近在用 nestjs 写一个后端应用程序，在设计 API 时选择了在 web app 中常被提起的 RESTful API 形式，但在过程中遇到了一些问题。 虽然 RESTful 形式的 API 在很多的教程中被推荐，但是实际的工作中，却也有很多项目的 API 没有遵从 REST 的形式。 实际使用 REST 来设计 API 的时候发现了一些难受的地方，比如如何表达批量操作，如何表达文件处理这个请求。 于是咨询了一些同事，查阅了一些资料，原来工作中的一些 API，使用的是 RPC 的形式。在我以前的印象中 RPC 就是远程服务调用，用后端程序和后端程序之间通信的一种方式。没想到，RPC 也可以是前后端 API 设计的一种形式。在查阅的资料中，这篇Understanding RPC Vs REST For HTTP APIs对我的启发很大。没有必要拘泥于固定的形式，可以 REST 和 RPC 混合使用。","categories":[],"tags":[{"name":"API","slug":"API","permalink":"http://yoursite.com/tags/API/"},{"name":"RESTful","slug":"RESTful","permalink":"http://yoursite.com/tags/RESTful/"},{"name":"RPC","slug":"RPC","permalink":"http://yoursite.com/tags/RPC/"}]},{"title":"浅谈ReactNode ReactElement 和Component","slug":"ReactElement-ReactNode和Component","date":"2022-02-06T11:18:45.000Z","updated":"2022-05-03T13:54:35.977Z","comments":true,"path":"2022/02/06/ReactElement-ReactNode和Component/","link":"","permalink":"http://yoursite.com/2022/02/06/ReactElement-ReactNode%E5%92%8CComponent/","excerpt":"","text":"本文尝试分析一下，ReactNode ReactElement 和 Component 之间的关系和区别。 ReactNodeReactNode是一种 typescript 的类型。在使用 antd 这样的组件库的时候，可以看到某些 prop 的类型是ReactNode，比如PageHeader组件的 extra 属性的类型就是ReactNode。 使用 vscode 的代码追踪，可以进入到@types/react这个包，查看ReactNode的类型定义如下： 1234567type ReactNode = | ReactChild | ReactFragment | ReactPortal | boolean | null | undefined; 可以发现，ReactNode是一个联合类型。比较符合我们平时写代码时的直觉。 其中的ReactChild可以继续跟踪，它的类型定义如下： 12type ReactText = string | number;type ReactChild = ReactElement | ReactText; 可以发现ReactChild也是一个联合类型，其中一个类型就是ReactElement。因此可以发现，ReactNode 包含了ReactElement。 ReactElementReactElement也是一种 typescript 类型。通常，我们在使用 typescript 书写Function Component的时候，如果加上了返回类型，会像这样： 123function App(): JSX.Element &#123; return &lt;div&gt;App&lt;/div&gt;;&#125; 追踪JSX.Element可以看到 123456declare global &#123; namespace JSX &#123; interface Element extends React.ReactElement&lt;any, any&gt; &#123;&#125; // ... &#125;&#125; 所以JSX.Element就是继承自ReactElement。查看ReactElement的类型定义如下： 12345678910interface ReactElement&lt; P = any, T extends string | JSXElementConstructor&lt;any&gt; = | string | JSXElementConstructor&lt;any&gt;&gt; &#123; type: T; props: P; key: Key | null;&#125; 所以本质上ReactElement就是一个对象,包含三个属性type,props,key。 其中最特别的就是type这个属性，它是一个范型，可以是string或者JSXElementConstructor。多说一句，type 如果是string，那么它可能就是类似于div这样的字符串，代表 HTML 的原生标签。再来看JSXElementConstructor，它的定义如下： 123type JSXElementConstructor&lt;P&gt; = | ((props: P) =&gt; ReactElement&lt;any, any&gt; | null) | (new (props: P) =&gt; Component&lt;any, any&gt;); 这也是一个联合类型，一个是函数，返回ReactElement。一个类，可以实例化为一个Component，也就是一个类组件。 其实ReactElement这个类型，就是代表了 React 中Element这个概念。官方解释如下： React elements are the building blocks of React applications. One might confuse elements with a more widely known concept of “components”. An element describes what you want to see on the screen. React elements are immutable.Typically, elements are not used directly, but get returned from components. 1const element = &lt;h1&gt;Hello, world&lt;/h1&gt;; Component这里直接引用 React 的官方文档 React components are small, reusable pieces of code that return a React element to be rendered to the page. The simplest version of React component is a plain JavaScript function that returns a React element: 只看函数组件，简而言之，函数组件就是可以返回一个ReactElement的函数。 JSX我们平时书写Element使用的是 JSX 语法，但是这种含有标签的语法（比如 &lt;h1&gt;Hello, world&lt;h1&gt;）并不是 js 语法的一部分。因此我们熟悉的 JSX 语句会被编译为标准的 js 代码。 JSX is a syntax extension to JavaScript. It is similar to a template language, but it has full power of JavaScript. JSX gets compiled to React.createElement() calls which return plain JavaScript objects called “React elements”. To get a basic introduction to JSX see the docs here and find a more in-depth tutorial on JSX here. 使用 Babel 可以让我们看到 JSX 编译后的代码。如下： 123456789101112function Button() &#123; return &lt;button&gt;click&lt;/button&gt;;&#125;function App() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;Button /&gt; &lt;/div&gt; );&#125; 编译后 1234567891011121314&quot;use strict&quot;;function Button() &#123; return /*#__PURE__*/ React.createElement(&quot;button&quot;, null, &quot;click&quot;);&#125;function App() &#123; return /*#__PURE__*/ React.createElement( &quot;div&quot;, null, /*#__PURE__*/ React.createElement(&quot;h1&quot;, null, &quot;Hello World&quot;), /*#__PURE__*/ React.createElement(Button, null) );&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"精读《Airbnb CSS / Sass Styleguide》","slug":"精读《Airbnb-CSS-Sass-Styleguide》","date":"2022-02-05T14:57:34.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2022/02/05/精读《Airbnb-CSS-Sass-Styleguide》/","link":"","permalink":"http://yoursite.com/2022/02/05/%E7%B2%BE%E8%AF%BB%E3%80%8AAirbnb-CSS-Sass-Styleguide%E3%80%8B/","excerpt":"","text":"Formatting Prefer dashes over camelCasing in class names. 12345678910111213141516171819202122&lt;!-- bad --&gt;.avatar&#123; border-radius:50%; border:2px solid white; &#125;.no, .nope, .not_good &#123; // ...&#125;#lol-no &#123; // ...&#125;&lt;!-- good --&gt;.avatar &#123; border-radius: 50%; border: 2px solid white;&#125;.one,.selector,.per-line &#123; // ...&#125; BEMBEM, or “Block-Element-Modifier”, is a naming convention for classes in HTML and CSS. It was originally developed by Yandex with large codebases and scalability in mind, and can serve as a solid set of guidelines for implementing OOCSS. BorderUse 0 instead of none to specify that a style has no border. SASSOrdering of property declarations1. Property declarationsList all standard property declarations, anything that isn’t an @include or a nested selector. 12345.btn-green &#123; background: green; font-weight: bold; // ...&#125; 2. @include declarationsGrouping @includes at the end makes it easier to read the entire selector. 123456.btn-green &#123; background: green; font-weight: bold; @include transition(background 0.5s ease); // ...&#125; 3. Nested selectorsNested selectors, if necessary, go last, and nothing goes after them. Add whitespace between your rule declarations and nested selectors, as well as between adjacent nested selectors. Apply the same guidelines as above to your nested selectors. 123456789.btn &#123; background: green; font-weight: bold; @include transition(background 0.5s ease); .icon &#123; margin-right: 10px; &#125;&#125; VariablesPrefer dash-cased variable names (e.g. $my-variable) over camelCased or snake_cased variable names. It is acceptable to prefix variable names that are intended to be used only within the same file with an underscore (e.g. $_my-variable). MixinsMixins should be used to DRY up your code, add clarity, or abstract complexity–in much the same way as well-named functions. Mixins that accept no arguments can be useful for this, but note that if you are not compressing your payload (e.g. gzip), this may contribute to unnecessary code duplication in the resulting styles. Extend directive@extend should be avoided because it has unintuitive and potentially dangerous behavior, especially when used with nested selectors. Even extending top-level placeholder selectors can cause problems if the order of selectors ends up changing later (e.g. if they are in other files and the order the files are loaded shifts). Gzipping should handle most of the savings you would have gained by using @extend, and you can DRY up your stylesheets nicely with mixins. Nested selectorsDo not nest selectors more than three levels deep! 1234567.page-container &#123; .content &#123; .profile &#123; // STOP! &#125; &#125;&#125; When selectors become this long, you’re likely writing CSS that is: Strongly coupled to the HTML (fragile) —OR— Overly specific (powerful) —OR— Not reusable Again: never nest ID selectors! If you must use an ID selector in the first place (and you should really try not to), they should never be nested. If you find yourself doing this, you need to revisit your markup, or figure out why such strong specificity is needed. If you are writing well formed HTML and CSS, you should never need to do this.","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"sass","slug":"sass","permalink":"http://yoursite.com/tags/sass/"},{"name":"style guide","slug":"style-guide","permalink":"http://yoursite.com/tags/style-guide/"}]},{"title":"精读《Airbnb JavaScript Style Guide》","slug":"精读《Airbnb-JavaScript-Style-Guide》","date":"2022-02-04T17:42:14.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2022/02/04/精读《Airbnb-JavaScript-Style-Guide》/","link":"","permalink":"http://yoursite.com/2022/02/04/%E7%B2%BE%E8%AF%BB%E3%80%8AAirbnb-JavaScript-Style-Guide%E3%80%8B/","excerpt":"","text":"Array To convert an iterable object to an array, use spreads … instead of Array.from. 1234567const foo = document.querySelectorAll(&quot;.foo&quot;);// goodconst nodes = Array.from(foo);// bestconst nodes = [...foo]; Use Array.from for converting an array-like object to an array. 1234567const arrLike = &#123; 0: &quot;foo&quot;, 1: &quot;bar&quot;, 2: &quot;baz&quot;, length: 3 &#125;;// badconst arr = Array.prototype.slice.call(arrLike);// goodconst arr = Array.from(arrLike); Use Array.from instead of spread … for mapping over iterables, because it avoids creating an intermediate array. 12345// badconst baz = [...foo].map(bar);// goodconst baz = Array.from(foo, bar); Properties Use exponentiation operator ** when calculating exponentiations. eslint: no-restricted-properties 12345// badconst binary = Math.pow(2, 10);// goodconst binary = 2 ** 10; Variables Group all your consts and then group all your lets. 1234567891011121314151617181920// badlet i, len, dragonball, items = getItems(), goSportsTeam = true;// badlet i;const items = getItems();let dragonball;const goSportsTeam = true;let len;// goodconst goSportsTeam = true;const items = getItems();let dragonball;let i;let length; Type Casting &amp; Coercion Strings: eslint: no-new-wrappers 12345678910111213// =&gt; this.reviewScore = 9;// badconst totalScore = new String(this.reviewScore); // typeof totalScore is &quot;object&quot; not &quot;string&quot;// badconst totalScore = this.reviewScore + &quot;&quot;; // invokes this.reviewScore.valueOf()// badconst totalScore = this.reviewScore.toString(); // isn’t guaranteed to return a string// goodconst totalScore = String(this.reviewScore); Numbers: Use Number for type casting and parseInt always with a radix for parsing strings. eslint: radix no-new-wrappers Why? The parseInt function produces an integer value dictated by interpretation of the contents of the string argument according to the specified radix. Leading whitespace in string is ignored. If radix is undefined or 0, it is assumed to be 10 except when the number begins with the character pairs 0x or 0X, in which case a radix of 16 is assumed. This differs from ECMAScript 3, which merely discouraged (but allowed) octal interpretation. Many implementations have not adopted this behavior as of 2013. And, because older browsers must be supported, always specify a radix. 12345678910111213141516171819const inputValue = &quot;4&quot;;// badconst val = new Number(inputValue);// badconst val = +inputValue;// badconst val = inputValue &gt;&gt; 0;// badconst val = parseInt(inputValue);// goodconst val = Number(inputValue);// goodconst val = parseInt(inputValue, 10); If for whatever reason you are doing something wild and parseInt is your bottleneck and need to use Bitshift for performance reasons, leave a comment explaining why and what you’re doing. 1234567// good/** * parseInt was the reason my code was slow. * Bitshifting the String to coerce it to a * Number made it a lot faster. */const val = inputValue &gt;&gt; 0; Booleans 12345678910const age = 0;// badconst hasAge = new Boolean(age);// goodconst hasAge = Boolean(age);// bestconst hasAge = !!age; Naming Conventions Don’t save references to this. Use arrow functions or Function#bind. 12345678910111213141516171819202122// badfunction foo() &#123; const self = this; return function () &#123; console.log(self); &#125;;&#125;// badfunction foo() &#123; const that = this; return function () &#123; console.log(that); &#125;;&#125;// goodfunction foo() &#123; return () =&gt; &#123; console.log(this); &#125;;&#125; You may optionally uppercase a constant only if it (1) is exported, (2) is a const (it can not be reassigned), and (3) the programmer can trust it (and its nested properties) to never change. What about all const variables? - This is unnecessary, so uppercasing should not be used for constants within a file. It should be used for exported constants however. What about exported objects? - Uppercase at the top level of export (e.g. EXPORTED_OBJECT.key) and maintain that all nested properties do not change. Why? This is an additional tool to assist in situations where the programmer would be unsure if a variable might ever change. UPPERCASE_VARIABLES are letting the programmer know that they can trust the variable (and its properties) not to change. 12345678910111213141516171819202122232425262728// badconst PRIVATE_VARIABLE = &quot;should not be unnecessarily uppercased within a file&quot;;// badexport const THING_TO_BE_CHANGED = &quot;should obviously not be uppercased&quot;;// badexport let REASSIGNABLE_VARIABLE = &quot;do not use let with uppercase variables&quot;;// ---// allowed but does not supply semantic valueexport const apiKey = &quot;SOMEKEY&quot;;// better in most casesexport const API_KEY = &quot;SOMEKEY&quot;;// ---// bad - unnecessarily uppercases key while adding no semantic valueexport const MAPPING = &#123; KEY: &quot;value&quot;,&#125;;// goodexport const MAPPING = &#123; key: &quot;value&quot;,&#125;;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"vscode extension 开发debug时卡在building的原因和解决","slug":"vscode extension 开发debug时卡在building的原因和解决","date":"2021-11-06T12:28:36.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2021/11/06/vscode extension 开发debug时卡在building的原因和解决/","link":"","permalink":"http://yoursite.com/2021/11/06/vscode%20extension%20%E5%BC%80%E5%8F%91debug%E6%97%B6%E5%8D%A1%E5%9C%A8building%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3/","excerpt":"","text":"背景最近在开发一款 vscode 插件，遇到了一个问题。特此记录。 问题描述 使用 vscode extension 官方的 cli 生成项目模版 开始 debugger 开发，一切正常，按 F5 自动弹出一个新的 vscode 升级项目中使用的 webpack 版本 使用 debugger 开发，按 F5 不会在自动弹出新的 vscode，卡在了 build 阶段，如下图 问题原因和解决在 google 了很久之后，总算确定了问题的原因 😳。 vscode extension 在 debug 的 watch 模式下，会监听控制台 webpack 的输出。上图的截图，控制台中显示的家就是 webpack 的输出。然后在项目的 task.json 中的 endsPattern 字段，会去匹配这个输出的字符串，如果匹配上了，就认为构建 ok 了，然后弹出一个新的 vscode。 问题的根据就在于升级 webpack 之后，webpack 的输出变了，因此需要重写一下。如下图。","categories":[],"tags":[{"name":"vscode extension","slug":"vscode-extension","permalink":"http://yoursite.com/tags/vscode-extension/"}]},{"title":"TrieTree在前端TreeSelect中的应用","slug":"TrieTree在前端TreeSelector中的应用","date":"2021-10-26T03:32:52.000Z","updated":"2022-05-03T13:54:35.977Z","comments":true,"path":"2021/10/26/TrieTree在前端TreeSelector中的应用/","link":"","permalink":"http://yoursite.com/2021/10/26/TrieTree%E5%9C%A8%E5%89%8D%E7%AB%AFTreeSelector%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"TreeSelectAntd 作为最有最优秀的 React 开源组件库之一，被广泛的使用。最近笔者在工作中使用TreeSelect组件。它的使用非常简单，可以接收下面这样的数据结构，来生成一个树型选择器。 1234567891011121314151617181920const treeData = [ &#123; title: &quot;Node1&quot;, value: &quot;0-0&quot;, children: [ &#123; title: &quot;Child Node1&quot;, value: &quot;0-0-1&quot;, &#125;, &#123; title: &quot;Child Node2&quot;, value: &quot;0-0-2&quot;, &#125;, ], &#125;, &#123; title: &quot;Node2&quot;, value: &quot;0-1&quot;, &#125;,]; 场景比如后端吐出给前端的数据如下。 1const rawData = [&quot;a.bb&quot;, &quot;a.cc&quot;, &quot;a.dd.eee&quot;, &quot;h.ff.llll&quot;]; 要求根据.作为分层级隔符，将数据展示为树形选择器。因此需要将数据转为如下形式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const treeData = [ &#123; title: &quot;*&quot;, value: &quot;*&quot;, children: [ &#123; title: &quot;a&quot;, value: &quot;a.*&quot;, children: [ &#123; title: &quot;bb&quot;, value: &quot;a.bb&quot;, &#125;, &#123; title: &quot;cc&quot;, value: &quot;a.cc&quot;, &#125;, &#123; title: &quot;dd&quot;, value: &quot;a.dd.*&quot;, children: [ &#123; title: &quot;eee&quot;, value: &quot;a.dd.eee&quot;, &#125;, ], &#125;, ], &#125;, &#123; title: &quot;h&quot;, value: &quot;h.*&quot;, children: [ &#123; title: &quot;ff&quot;, value: &quot;h.ff.*&quot;, children: [ &#123; title: &quot;llll&quot;, value: &quot;h.ff.llll&quot;, &#125;, ], &#125;, ], &#125;, ], &#125;,]; 前缀树（字典树）关于前缀树的文章可以参考leetcode 208 实现 Trie 树。 这种 case，根据共同的前缀，层层递进形成的数据结构，正是前缀树的应用场景了。那么我们如何将rawData 转换为treeData呢？笔者给了一个自己实现，如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677interface TreeData &#123; title: string; value: string; children?: TreeData[];&#125;export class TrieNode &#123; constructor( public value: string = &quot;&quot;, public path: string = &quot;&quot;, public isLeaf: boolean = false, public isRoot: boolean = false, public children: TrieNode[] ) &#123;&#125;&#125;export class TrieTree &#123; root: TrieNode; constructor(data: string[] = []) &#123; this.root = new TrieNode(&quot;*&quot;, &quot;&quot;, false, true, []); data.forEach((item) =&gt; &#123; this.insert(item.split(&quot;.&quot;)); &#125;); &#125; findNode(node: TrieNode, key: string) &#123; if (!key) return null; if (!node || !node.children?.length) return null; return node.children.find((child) =&gt; child.value === key); &#125; insert(keys: string[]) &#123; let node = this.root; const paths = []; for (const key of keys) &#123; paths.push(key); let child = this.findNode(node, key); if (!child) &#123; child = new TrieNode(key, paths.join(&quot;.&quot;), false, false, []); node.children.push(child); &#125; node = child; &#125; node.isLeaf = true; &#125; getValue() &#123; const treeData: TreeData[] = []; const dfs = (node: TrieNode, treeData: TreeData[]) =&gt; &#123; if (!node) return; const data: TreeData = &#123; title: node.value, value: node.isRoot ? node.value : node.isLeaf ? node.path : node.path + &quot;.*&quot;, &#125;; if (node.children?.length) data.children = []; treeData.push(data); for (const child of node.children) &#123; dfs(child, data.children); &#125; &#125;; dfs(this.root, treeData); return treeData; &#125;&#125; 结合 Antd 来使用codesandbox","categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"前端开发中的算法","slug":"前端开发中的算法","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95/"}]},{"title":"英语语法整理","slug":"英语语法整理","date":"2021-10-24T12:12:14.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2021/10/24/英语语法整理/","link":"","permalink":"http://yoursite.com/2021/10/24/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86/","excerpt":"","text":"简单句语法一般英语句子的结构，可以总结为主语+谓语+（东西）。 主语：人或者物品 谓语：动作 主语+谓语 I swim swim 是不及物动词 主语+谓语+宾语 I like her like 是及物动词 主语+谓语+间接宾语+直接宾语 (双宾)谓语后面跟着两个动作的承受者。 Dabai teaches you English 主语+谓语+宾语+宾语补充谓语后面跟着一个动作的承受者和他的补充说明。 Dabai makes you happy 主语+系动词+表语 Dabai is smart 三种起修饰成分的句子结构定语，定语是广义的形容词 The cute boy speaks English The boy in red speaks English The boy when I played withe speaks English; 状语，状语是广义的副词副词是用来修饰形容词和动词的词。 Dabai answered quickly Dabai answerd in English 同位语，把主语换个说法再说一遍 Shabai’s brother,BigShaBai,is a teacher We Chinese People are hardworking 复杂句并列关系的复合句 I washed my hands, and I ate breakfast 嵌套关系的复杂句 The boy said that he was very hungry The boy who was crying said when I spoke to him that he was very hungry because he had had no food for two days 词类 名词，可数+不可数 代词，you I she he it 形容词，happy 副词，quickly 动词，run 数次，one two 冠词，the a this 介词，in at on 连词，and but 叹词，oh oops shit","categories":[],"tags":[{"name":"英语学习","slug":"英语学习","permalink":"http://yoursite.com/tags/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"}]},{"title":"如何克服精神内耗","slug":"如何克服精神内耗","date":"2021-10-24T11:39:28.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2021/10/24/如何克服精神内耗/","link":"","permalink":"http://yoursite.com/2021/10/24/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E7%B2%BE%E7%A5%9E%E5%86%85%E8%80%97/","excerpt":"","text":"精神内耗今天再次阅读精神内耗这篇知乎文章以及他的姐妹篇高效管理时间的秘诀，在于这三个清单。 理想的精神状态理想的精神状态应该是，可以全神贯注的专注在你当前正在做的事情上，不论是学习，工作，思考，还是娱乐。 我的精神状态但是目前的我是做不到的，脑袋中存在着各种各样的纠结，推演各种各样的情况，处理各种各样的信息。导致我总是精神不振，每天精神都不充沛和兴奋。 这种情况导致的结果就是，我的大脑无时无刻都在处理信息，有事甚至是不同的信息，比如我在写这篇文章的时候，就想到了还要写一篇关于头油的文章。强制转换注意力，导致注意力不集中。这里面的大量信息是无用的，空耗我大脑的 CPU 资源。 而想法多的另一个坏处是，导致想的多，做的少，比如我想学习 flutter，我想买个瑜伽垫健身，我想读《编码》这本书，我想读完我微信收藏的文章，我想看完我极客时间的课程（那个想了很久的网络协议课程），都还只停留在想想的阶段。（这个问题也许可以通过指定合理的 todo 清单来解决） 真的非常痛苦 😖。 过度思虑（精神内耗），为什么会有精神内耗我的状态有个专业名词来描述，就是过度思虑，也就是通俗的精神内耗。 为什么会有这种情况呢？有以下几个原因 过度活跃的 DMNDMN 就是 Default Mode Network，默认模式网络。它是把大脑后台零碎的信息进行梳理，把可能被遗忘的重新进行激活。哪怕什么都不做，大脑也有大约 20%的耗能任务在执行。TPN，Task Positive Network 专注网络。 优势 长时记忆能力、想象力、创造力更好一些。 DMN 涉及的脑部区域和负责自我与他人以及情感判断的网络所涉及的部分，是高度重叠的。因此更容易考虑别人的感受，以及注意到不好的地方。也就是有更好的共情能力。 劣势 DMN 过度的活跃，会在我专注工作时，和争夺大脑的 CPU 资源，导致无法持续专注。（这点我感觉我还挺明显的，比如刚才我就突然想到了 Grab 上的麦当劳是不是可以 pick up，然后打开手机看了一下） 当 DMN 不受 TPN 的钳制时，会更加放飞自我，把很多负面的情绪和想法输送到意识里。 由威胁识别带来的恐惧威胁识别。我们的大脑在加工各种信息时，有一个功能，叫做威胁识别，它往往会夸大和凸显一个事物中的威胁的细节，忽视安全的细节，从而看不清事物的全貌，继而导致我去逃避该事物。 优势 自我保护 劣势 让我们害怕去做一些事，比如我总是不敢探寻新的餐厅，担心里面价格很贵，买到很坑的东西，亦或是担心不卫生。 大脑还有一种机制叫做“延伸记忆”，也就是我过去付出行动、获得成功、获得经验的经历，比如我鼓起勇气成功探寻了某个餐厅，某个景点，某个理发店，我就会发现它没什么大不了，它就会成为我下次做决定的一个选项。比如我在平时不敢说话的群里面，问了一个问题，我后面就不会再认为在这个群里问问题会有什么困难。 当大脑进行”威胁识别“时，会使用”延伸记忆“里面的信息，来进行对抗和抵消。 形成精神内耗 我遇到问题，决定先审视一下再说 这种“审视一下”，导致我过度夸大了它的威胁，从而形成恐惧 这种恐惧使我的行动的意向进一步被削弱，我需要更多的精力跟它对抗，才能采取行动，于是造成了拖延 而大多数问题在拖延之下，会变得越来越糟，最终逼我不得不去行动，于是我会感觉“做出了一个错误的决定” 久而久之，这种感觉就会加重我的自我怀疑，削弱我的自信，而从削弱我的“延伸记忆”，使得我更没有办法对抗恐惧。。。 最终，我的幸福感会下降。 结论过度的精神内耗，会让我自我怀疑，缺乏自我的价值感和意义感觉。并且肯定会让我的幸福感降低，觉得很多事情没有意思，失去了生活的激情，我现在基本就有这种感觉，很多事情提不起兴趣。 当我专注时，更容易获得“绞尽脑汁”解决问题的快感。当我被 DMN 主宰时，我会分心，无法专注，因此也无法获得“绞尽脑汁”的快感，反而还会想起负面、不快乐的事情。 精神内耗会 消耗精力 降低行动力 降低幸福感 克服精神内耗掌控自己的想法这个方法其实很困难，想法如果可以轻易被我掌控，那也就不会有那么多问题了。如何掌控，可以试试以下几种形式 当我产生负面情绪，或者乱七八糟的想法时，对它说：我知道了，退下吧，我会等有空的时候处理。 用一个笔记本来记录我的负面的想法。产生负面想法时，先记下来，然后就不要想了（这一步很难） 定期查看笔记本中的负面想法，问自己 他是真实的吗？ 他发生的可能性大吗？ 我有没有方法可以应对它？ 一旦把这三个问题想清楚，就划掉他 上面的做法，可以强化我的“主动性”，让我感受到，我是可以掌控我的想法的，我有能力那么做。 锻炼专注和感知能力DMN 就是在我的大脑空闲时的信马由缰，因此如果我可以把大脑专注在某件事上，我就能降低 DMN 的活跃性。有以下两个方法可以帮我提高专注力。我需要把他们加到我的小习惯里面。 冥想&#x2F;正念。这个方法在《自控力》这本书中也提到过，看来方法的有效性形成了共识。找一个舒适的位置，闭上眼睛，采取 10s 左右的呼吸，把注意力放在呼吸上面，体会呼吸的过程，不要去管脑海中来来回回的想法，也不要抑制它。持续 10 ～ 15 分钟。 停下手头的事，找个舒适的位置，先深呼吸一到两次，然后按顺序问自己 我看到了什么 听到了什么 嗅到了什么 手和脚触碰到了什么 感觉是怎样的 或者闭上眼睛，依靠感官走几步，专注感受感官传来的信息。 注意力转换和饱和我工作的时候为什么会分心呢？就是因为当前的事情无法百分之百的吸引我的兴趣了，使我的注意力“不饱和”，然后产生了闲置资源，发生 DMN。 一个解决方法是分段工作模式，就是把同时打开多个项目（事情），项目一工作一段时间，转换到项目二，然后项目三，以此类推。这样的好处是，在同一个任务长时间之行后，开始无法集中注意力，大脑产生闲置，这时为了不让闲置的大脑专向 DMN，于是开启项目二来吸引我的注意力和大脑资源。 也就是说，我们无力控制自己分心，但是我们可以把分心引导到一个更有意义，更符合我们需求的方向。 可以结合后文的 Todo 清单来实践。 把行动变成默认模式如果一件事，我想不到特别有力的不去做的原因，那么，优先选择去做。 应该把这句话当成一个信条，指导我生活中的行动。 这些不确定的事情，因为害怕麻烦，权衡得失等原因，如果不得到解决，会一残留在我的记忆里，随着 DMN 的激活而挤占我的认知资源。 只有去行动了，才能把未知变成已知，把不确定变成确定，让它们得到安置，不再干扰我的思考。 另外，行动也会带给我正向的反馈。我所恐惧的东西，其实没有那么可怕，我对他的猜测，担忧和焦虑，很多都是不必要的。 高效管理时间为了合理的安排自己的时间和需要做的事情，我之前制定了 Todo List，但是我之前制定的 Todo List，虽然看上去分门别类，但是最后执行力不行，很多都成了摆设，应该是失败了 😂。 因此决定学习“L 先生说” 公众号里推荐的 Todo List 管理方案。 拖延症为啥我有拖延的毛病呢？一个可能的原因来自“认知负担”，它让我产生了这么一个潜意识“这是一个复杂的任务，我没法立刻开工，我需要先理清思路”。比如我很早就计划了上 b 站搜索健身教程，并尝试在家里做简单的运动，但是却一直没有开始 😂。实际上，我的大脑逻辑非常简单，他倾向于去做简单的，不需要太多思考的事情，而排斥复杂的，需要大量投入的事情。这就为我们制定 Todo List 提供了一种指导。 AFD TodoList“L 先生说”实行的是名叫 AFD 的方法，也就是 Action、Focused、Dessert Action 执行清单执行清单，就是自己计划需要完成的，但是这里不能简单的罗列，需要把粒度尽量的变小。 比如“到超市买苹果”，就是一个非常明确简单的行动，不需要思考，它所占用的认知资源非常少。 再比如“完成 Policy 改版”，就不行，颗粒度太大，并不是一步可以完成的，这样的 todo 很容易产生迷惑 我做到了哪里 我的思路是什么 我还需要做些什么 这些就会带给我认知负担。因此需要对这样的 item，做详细的分解。明确需要做什么，而且越具体，行动起来越容易，比如数量、目的、关键词等等。 这样当我看到任务的时候，可以毫不犹豫的去执行，不会产生拖延情绪。 但是话说回来，能够把任务拆的细，也是需要时间精力的，但是这种应该是值得的。 Focused 聚焦清单“休息”并不一定是要睡个觉。对于体力劳动，睡觉时最好的休息方式，可以让肌肉得到放松。但是对于脑力劳动，却不是这样。 大脑处理不同的任务，使用的是不同的区域，当长时间执行一个任务时，大脑的耗能和平时其实不会差太多，但是对他的“新鲜感”会降低很多，这种“新鲜感”的降低，是我们脑力劳动疲劳的主要原因，有时我会觉得自己困了，其实是长时间思考同样的内容，会抑制大脑的活动，让人感到厌倦、昏昏欲睡无法集中注意力。 因此脑力疲惫更好的方式时，调整聚焦点，切换到不同的工作上，激活大脑的另一个区域。 因此这个清单中，可以存放两类东西 重要的亟待解决的问题 正在研读和学习的书籍等 每当工作累了，就可以站起来走走，喝点东西，散步，然后再脑袋里思考这些问题。比如： 今晚吃什么 需要买些什么东西了 调研一下周末去哪里玩 或者打开没有阅读完的书籍，阅读一会儿。等到这个清单的里的事情疲惫了，就可以去接着做之前的事情了。 Dessert 成就感清单如果是在觉得厌烦、无聊，提不起精神，不想动脑子，无论是 Action、还是 Focused 里面的事情，都不想干，这就是精神低谷的时候，就可以准备一个“Dessert”清单，里面放一些非常简单，无需动脑、没有时间限制的小事，比如 整理书桌 整理电脑文件夹 下载资源 这样可以积累成就感，帮助我的精神状态回归。通过在做完 2-3 项 Dessert 之后，状态应该可以回归。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"整理英语学习资源","slug":"整理英语学习资源","date":"2021-10-23T04:20:18.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2021/10/23/整理英语学习资源/","link":"","permalink":"http://yoursite.com/2021/10/23/%E6%95%B4%E7%90%86%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/","excerpt":"","text":"资源整理目前收集了很多的英语学习资源，在国内的时候更多的是单纯的学习，而来到新加坡后有了很多的实战场景，除了日常的积累外，还是需要一些系统性的学些 lah！🤪 方法论 English leval up tips for chinese APP 开言英语 英语流利说 视频 五分钟英语基础语法 外教 Gill 英语精品课 说一口流利标准英语 English with Lucy B 站 UP 主 Youtobe 口语精选 Youtobe 英语精选 Youtobe 听力精选 Bigshot 英语 Youtobe English with Lucy Speak English With Vanessa 公众号 英语资源学习中心 Podcast 潘吉 JENNY 告诉你 ALL EARS ENGLISH 英文小酒馆 LHH 一席英语 6 Minute English 计划某次偶然的机会听到了潘吉 JENNY 告诉你这款播客，感觉这种中英对话聊天的形式很有意思，每期一个话题，除了学习英语，还可以知道一些有趣的事情。继而开始使用他们公司开发的开言英语App，使用了外交视频课，感觉还不错，根据具体的场景来学习英语。 其他资源自然是屯起来才有安全感 lah！还都没开始看 🤪。 播客打算额外选择一个一席英语，再从视频里选择说一口流利标准英语把它办了 💪！","categories":[],"tags":[{"name":"英语学习","slug":"英语学习","permalink":"http://yoursite.com/tags/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"}]},{"title":"算法资源整理","slug":"整理算法资源","date":"2021-10-20T11:18:43.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2021/10/20/整理算法资源/","link":"","permalink":"http://yoursite.com/2021/10/20/%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%E8%B5%84%E6%BA%90/","excerpt":"","text":"最近打算再一次系统的学习数据结构与算法，并再次开始有节奏的刷 leetcode。功在平时，有备无患，在还没有熟练掌握之前，学习数据结构与算法和刷题必然是一个长期的过程。 资源整理目前手头上掌握的资源挺多，可真正耐下心看完的没有几个。很多都是看到之后，随手就丢进了收藏夹里吃灰（众所周知，收藏就等于学会了 🤪）。 在线书籍 labuladong 算法小抄 瓶子君的算法小书 程序厨的动画算法 leetcode cookbook 极客时间 算法面试通过 40 讲 数据结构与算法之美 常用算法 25 讲 视频 百度云-算法训练营 代码随想录 清华大学数据结构精品课-邓俊辉 左程云 LeetCode 刷题笔记 github LeetCode 题目分类与面试问题整理 Fucking Algorithm(同 labuladong 算法小抄) LeetCode Classify Awesome CS Books Coding Interview University LeetCode Animation LeetCode 全解 书籍 剑指 offer 编程之美 挑选资料整理了好多，但是之前没有系统的钻研过。除了面试前看的《算法面试通关 40 讲》和《数据结构与算法之美》,前者属于视频类，后者属于小册类。 资料太多，不可能一次全部搞完，没有计划，很容易他们就集体吃灰了，还是需要逐个击破。这次决定从众多资料中，挑出两个，一个文字阅读类，一个视频类，互为补充的来学习。 labuladong 算法小抄 百度云-算法训练营 计划从 labuladong 算法小抄中，从头到尾，按照专题，每两天做一道题目，如果遇到简单的做过的，就顺势做到下一题。遇到复杂的概念和困难的题目，可以结合算法训练营视频来消化。 2021&#x2F;10&#x2F;20 星期三 反馈这里等待反馈，如果 labuladong 算法小抄过了一遍，再来这篇 blog 记录下成功的时间。 未完待续。。。","categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"Mac 安装和启动MySQL数据库","slug":"Mac-安装和启动MySQL数据库","date":"2021-10-19T11:05:29.000Z","updated":"2022-05-03T13:54:35.977Z","comments":true,"path":"2021/10/19/Mac-安装和启动MySQL数据库/","link":"","permalink":"http://yoursite.com/2021/10/19/Mac-%E5%AE%89%E8%A3%85%E5%92%8C%E5%90%AF%E5%8A%A8MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"最近在学习 NestJS 框架，需要使用 MySQL 数据库来配合完成一些功能，以前只使用过 MongoDB，第一次使用 MySQL，在安装和使用时踩了一些坑，记录下来。 下载MySQL 分为商业版和社区版，社区版我理解就是开源免费的。但是在官网想要找到下载入口比较费劲，个人感觉不是清晰。下载社区版可以直接使用下面这个链接。MySQL Community Download 安装下载完成后，直接双击 dmg 文件进行安装。安装过程中需要输入输入 root 的密码，这里需要记下来。后面链接数据库的时候需要使用。 启动为了启动 MySQL 我走了不少弯路，一开始使用命令行来启动，结果很麻烦，也没有成功启动。后来发现其实 MySQL 很人性化，它会在 System Perference 里面生成一个图标，点击图标后就可进行一些基本操作，包括 start stop initialize 连接数据库建议直接使用图形化界面来操作，使用命令行太麻烦了。图形化界面有两个选择一个是收费的Navicat，一个是开源免费的Sequel Pro。笔者一开始试用过Navicat，确实非常好用，鉴于平时需求不是很大，所以暂时没有打算付费使用。于是选择了Sequel Pro。 在使用Sequel Pro的过程中遇到了一些问题。最开始下载的是v1.1.2正式版，但是使用过程中无法连接数据库，还总是闪退。尝试重装也没有解决。搜索后发现很多人都遇到了这个问题。解决方案是下载test build版本。可以完美解决。 下载地址: Sequel Pro test build 如此依赖就可以快乐的使用 MySQL 数据库了。","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"使用React设计一个Form表单组件","slug":"使用React设计一个Form表单组件","date":"2021-07-18T17:18:44.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2021/07/18/使用React设计一个Form表单组件/","link":"","permalink":"http://yoursite.com/2021/07/18/%E4%BD%BF%E7%94%A8React%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AAForm%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6/","excerpt":"","text":"通过设计一个 Form 组件，学习 React 中，React.Children.forEach 和 React.CloneElement 以及 React.isValidElement 这三个 API 的用法。 组件 API 设计组件用法如下 1234567891011121314151617181920212223242526272829303132import &#123; useRef &#125; from &quot;react&quot;;import &#123; Form, FormItem, Input &#125; from &quot;./Form&quot;;export default function App() &#123; const form = useRef(); const onSubmit = () =&gt; &#123; form.current.submit((data) =&gt; &#123; console.log(&quot;data&quot;, data); &#125;); &#125;; const onReset = () =&gt; &#123; form.current.reset(); &#125;; return ( &lt;div className=&quot;App&quot;&gt; &lt;Form ref=&#123;form&#125;&gt; &lt;FormItem name=&quot;name&quot; label=&quot;姓名&quot;&gt; &lt;Input /&gt; &lt;/FormItem&gt; &lt;FormItem name=&quot;age&quot; label=&quot;年龄&quot;&gt; &lt;Input /&gt; &lt;/FormItem&gt; &lt;FormItem name=&quot;sex&quot; label=&quot;性别&quot;&gt; &lt;Input /&gt; &lt;/FormItem&gt; &lt;/Form&gt; &lt;button onClick=&#123;onSubmit&#125;&gt;提交&lt;/button&gt; &lt;button onClick=&#123;onReset&#125;&gt;重置&lt;/button&gt; &lt;/div&gt; );&#125; 组件实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import React from &quot;react&quot;;export class Form extends React.Component &#123; state = &#123; formData: &#123;&#125;, &#125;; submit = (cb) =&gt; &#123; cb &amp;&amp; cb(&#123; ...this.state.formData &#125;); &#125;; reset = () =&gt; &#123; const &#123; formData &#125; = this.state; Object.keys(formData).forEach((key) =&gt; &#123; formData[key] = &quot;&quot;; &#125;); this.setState(&#123; formData &#125;); &#125;; setValue = (name, value) =&gt; &#123; const &#123; formData &#125; = this.state; formData[name] = value; this.setState(&#123; formData &#125;); &#125;; render() &#123; const &#123; children &#125; = this.props; const &#123; formData &#125; = this.state; const renderChildren = []; React.Children.forEach(children, (child) =&gt; &#123; if (child.type.displayName === &quot;FormItem&quot;) &#123; const &#123; name &#125; = child.props; renderChildren.push( React.cloneElement( child, &#123; key: name, value: formData[name] || &quot;&quot;, handleChange: this.setValue, &#125;, child.props.children ) ); &#125; &#125;); return renderChildren; &#125;&#125;export class FormItem extends React.Component &#123; static displayName = &quot;FormItem&quot;; onChange = (value) =&gt; &#123; const &#123; name, handleChange &#125; = this.props; handleChange &amp;&amp; handleChange(name, value); &#125;; render() &#123; const &#123; label, value, children &#125; = this.props; return ( &lt;div&gt; &lt;span&gt;&#123;label&#125;&lt;/span&gt; &#123;React.isValidElement(children) &amp;&amp; children.type.displayName === &quot;FormItem-Input&quot; ? React.cloneElement(children, &#123; onChange: this.onChange, value &#125;) : null&#125; &lt;/div&gt; ); &#125;&#125;export class Input extends React.Component &#123; static displayName = &quot;FormItem-Input&quot;; render() &#123; const &#123; value, onChange &#125; = this.props; return ( &lt;input value=&#123;value&#125; onChange=&#123;(e) =&gt; &#123; onChange &amp;&amp; onChange(e.target.value); &#125;&#125; /&gt; ); &#125;&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"javascript冷门知识点","slug":"javascript冷门知识点","date":"2021-07-11T17:51:26.000Z","updated":"2022-05-03T13:54:35.977Z","comments":true,"path":"2021/07/11/javascript冷门知识点/","link":"","permalink":"http://yoursite.com/2021/07/11/javascript%E5%86%B7%E9%97%A8%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"为什么函数是 javascript 中的一等公民如果某个编程语言的函数，可以和这个语言的数据类型做一样的事情，我们就把这个语言中的函数称为一等公民。在 javascript 中，函数可以像对象一样拥有自己的属性和方法，也可以作为参数传递给另一个函数，甚至可以作为一个函数的返回值（这个特性要求 js 虚拟机必须实现闭包的特性）。 javascript 中对象属性的访问顺序1234567891011121314151617181920212223242526272829function Foo() &#123; this[100] = &quot;test-100&quot;; this[1] = &quot;test-1&quot;; this[&quot;B&quot;] = &quot;bar-B&quot;; this[50] = &quot;test-50&quot;; this[9] = &quot;test-9&quot;; this[8] = &quot;test-8&quot;; this[3] = &quot;test-3&quot;; this[5] = &quot;test-5&quot;; this[&quot;A&quot;] = &quot;bar-A&quot;; this[&quot;C&quot;] = &quot;bar-C&quot;;&#125;var bar = new Foo();for (key in bar) &#123; console.log(`index:$&#123;key&#125; value:$&#123;bar[key]&#125;`);&#125;/**index:1 value:test-1index:3 value:test-3index:5 value:test-5index:8 value:test-8index:9 value:test-9index:50 value:test-50index:100 value:test-100index:B value:bar-Bindex:A value:bar-Aindex:C value:bar-C * / 在 ECMAScript 规范中定义了数字属性应该按照索引值大小升序排列，字符串属性按照创建时的顺序升序排列。数字属性成为排序属性（elements），字符串属性成为常规属性（properties） javascript 中的 fast、slow、in-object 属性在 js 的对象中，访问速度最快的是 in-object 属性，他们直接存储在对象上面，但是 in-object 属性的数量取决于初始化对象的大小（可以理解为一般为 10 个）。当属性数量超出 in-object 的 size 时，属性会被存储到 properties 中，在数量不大的情况下，properties 中的属性采用线性存储结构，有点是访问速度快，增加和删除的速度慢。在数量增大的情况下，properties 会转化为字典的存储结构，有点是增加和删除的速度快，访问的速度慢。 函数声明与函数表达式12345// 函数声明function foo() &#123;&#125;// 函数表达式const foo = function () &#123;&#125;;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"数组排序系列","slug":"数组排序系列","date":"2021-04-18T15:52:57.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2021/04/18/数组排序系列/","link":"","permalink":"http://yoursite.com/2021/04/18/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%B3%BB%E5%88%97/","excerpt":"","text":"数组的排序应该是基本中的基本了。 \b 冒泡排序冒泡排序的思想是，通过一次遍历，通过比较，将一个最大的元素，调整到数组的末尾，进行 n 次之后，数组就有序了。因此时间复杂度是 O(n^2) 12345678910function sortArray(nums: number[]): number[] &#123; for (let i = 0; i &lt; nums.length; i++) &#123; for (let j = 0; j &lt; nums.length - i; j++) &#123; if (nums[j] &gt; nums[j + 1]) &#123; swap(nums, j, j + 1); &#125; &#125; &#125; return nums;&#125; 插入排序插入排序的思想是，将数组分成两部分，左半部分是有序的，右半部分是无序的，每次从右半部分取出第一个元素，插入到左半部分。插入的过程是，把待插入元素和左半部分的元素比较，如果小于就交换，如果大于等于就停止。 12345678910111213function sortArray(nums: number[]): number[] &#123; // nums[i] 是待插入的元素 for (let i = 0; i &lt; nums.length; i++) &#123; for (let j = i; j &gt; 0; j--) &#123; if (nums[j] &lt; nums[j - 1]) &#123; swap(nums, j - 1, j); &#125; else &#123; break; &#125; &#125; &#125; return nums;&#125; 快速排序快速排序的思想是，每次将数组分为左右两部分，左半部分的所有值都小于右半部分，然后对左右部分再进行这样的操作。最终整个数组有序。 12345678910111213141516171819202122232425262728293031function partition(nums: number[], left: number, right: number): number &#123; if (left &gt;= right) return right; const pvoit = nums[left]; const start = left; left = left + 1; while (left &lt;= right) &#123; if (nums[left] &gt; pvoit &amp;&amp; nums[right] &lt; pvoit) &#123; swap(nums, left++, right--); &#125; else if (nums[left] &lt;= pvoit) &#123; left++; &#125; else &#123; right--; &#125; &#125; swap(nums, start, right); return right;&#125;function quickSort(nums: number[], left: number, right: number): number[] &#123; if (left &gt;= right) return nums; const p = partition(nums, left, right); quickSort(nums, left, p - 1); quickSort(nums, p + 1, right); return nums;&#125;function sortArray(nums: number[]): number[] &#123; return quickSort(nums, 0, nums.length - 1);&#125;","categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"前缀和系列","slug":"前缀和系列","date":"2021-04-17T10:44:29.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2021/04/17/前缀和系列/","link":"","permalink":"http://yoursite.com/2021/04/17/%E5%89%8D%E7%BC%80%E5%92%8C%E7%B3%BB%E5%88%97/","excerpt":"","text":"前缀和前缀和，简单说就是数组的前 n 项的和。不过需要注意，在代码里面，presum[i] 代表前 i 项的和，也就是 nums[0]~nums[i-1]的和。比如 presum[2] &#x3D; nums[0] + nums[1]。 通过前缀和的思想和 map，可以优化很多问题解法。 同时前缀和不一定真的就是前缀的和，也可以是前缀中奇数数字的个数等。总之就前缀的一个统计信息，可以是和，也可以是其他。 123456function presum(nums: number): number[] &#123; let presum = [0]; for (let i = 0; i &lt; nums.length; i++) &#123; presum[i + 1] = presum[i] + nums[i]; &#125;&#125; 724. 寻找数组的中心下标给你一个整数数组 nums，请编写一个能够返回数组 “中心下标” 的方法。数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。如果数组不存在中心下标，返回 -1 。如果数组有多个中心下标，应该返回最靠近左边的那一个。 1234567891011121314151617181920// 先求出总和// 遍历求出左边的和，然后用总和减去左边的和以及当前值，就是右边的和// 判断左右的和是否相等function pivotIndex(nums: number[]): number &#123; let presum = 0; for (let i = 0; i &lt; nums.length; i++) &#123; presum += nums[i]; &#125; let leftsum = 0; let rightsum = 0; for (let i = 0; i &lt; nums.length; i++) &#123; rightsum = presum - leftsum - nums[i]; if (leftsum === rightsum) &#123; return i; &#125; leftsum += nums[i]; &#125; return -1;&#125; 1. 两数之和给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 12345678910111213// 使用一个map，记录已经访问过的值// 遍历数组，判断map中是否已经存在一个值，和当前值相加的和是target// 如果不是，就把当前值加入到map中function twoSum(nums: number[], target: number): number[] &#123; const map = new Map(); for (let i = 0; i &lt; nums.length; i++) &#123; if (map.has(target - nums[i])) &#123; return [map.get(target - nums[i]), i]; &#125; map.set(nums[i], i); &#125; return [];&#125; 560. 和为 K 的子数组给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例 1 : 输入:nums &#x3D; [1,1,1], k &#x3D; 2; 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况 12345678910111213141516171819202122232425262728293031323334// 暴力法，求出了所有子数组的和// 有可能会超时function subarraySum(nums: number[], k: number): number &#123; let sum = 0; let cnt = 0; for (let i = 0; i &lt; nums.length; i++) &#123; sum = 0; for (let j = i; j &lt; nums.length; j++) &#123; sum += nums[j]; if (sum === k) &#123; cnt++; &#125; &#125; &#125; return cnt;&#125;// 与两数之和类似，使用map节省时间// map 中记录前缀和，以及该前缀和出现的次数function subarraySum(nums: number[], k: number): number &#123; let presum = 0; let cnt = 0; const map = new Map(); map.set(0, 1); for (let i = 0; i &lt; nums.length; i++) &#123; presum += nums[i]; if (map.has(presum - k)) &#123; cnt += map.get(presum - k); &#125; const curVal = map.has(presum) ? map.get(presum) : 0; map.set(presum, curVal + 1); &#125; return cnt;&#125; 1248. 统计优美子数组给你一个整数数组 nums 和一个整数 k。如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。请返回这个数组中「优美子数组」的数目。 1234567891011121314151617181920212223242526272829303132333435363738// 使用位运算判断数字的奇偶性function isOdd(num: number): boolean &#123; return (num &amp; 1) === 1;&#125;// 暴力法，遍历所有的子数组，计算子数组奇数的个数，判断个数是否为kfunction numberOfSubarrays(nums: number[], k: number): number &#123; let cnt = 0; let oddCnt = 0; for (let i = 0; i &lt; nums.length; i++) &#123; oddCnt = 0; for (let j = i; j &lt; nums.length; j++) &#123; if (isOdd(nums[j])) oddCnt++; if (oddCnt === k) cnt++; &#125; &#125; return cnt;&#125;// presum 记录的是当前前缀中的奇数的个数// map记录前缀中奇数个数，以及该种case出现的次数// 比如map(5,2) 代表，该前缀中有5个奇数，它出现了2次function numberOfSubarrays(nums: number[], k: number): number &#123; let cnt = 0; let presum = 0; const map = new Map(); map.set(0, 1); for (let i = 0; i &lt; nums.length; i++) &#123; presum += isOdd(nums[i]) ? 1 : 0; if (map.has(presum - k)) &#123; cnt += map.get(presum - k); &#125; const curVal = map.has(presum) ? map.get(presum) : 0; map.set(presum, curVal + 1); &#125; return cnt;&#125; 974. 和可被 K 整除的子数组给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。 这里的 k 大于 2 数组 A 中有负数。 12345678910111213141516171819202122232425262728293031323334353637383940// 暴力法// 求出所有子数组的和，验证是否可以被K整除// 超时了function subarraysDivByK(A: number[], K: number): number &#123; let cnt = 0; let sum = 0; for (let i = 0; i &lt; A.length; i++) &#123; sum = 0; for (let j = i; j &lt; A.length; j++) &#123; sum += A[j]; if (sum % K === 0) &#123; cnt++; &#125; &#125; &#125; return cnt;&#125;// presum 还是前缀和// map记录前缀和对K的余数，以及次数// (presum[i]-presum[j]) % K = 0 --&gt; presum[i] % K = presum[j] % Kfunction subarraysDivByK(A: number[], K: number): number &#123; let cnt = 0; let presum = 0; let remainder = 0; // 余数 const map = new Map(); // map记录前缀和对K的余数，以及次数 map.set(0, 1); for (let i = 0; i &lt; A.length; i++) &#123; presum += A[i]; // 这里需要把负数的余数转成正数 remainder = ((presum % K) + K) % K; if (map.has(remainder)) &#123; cnt += map.get(remainder); &#125; const curVal = map.has(remainder) ? map.get(remainder) : 0; map.set(remainder, curVal + 1); &#125; return cnt;&#125; 523. 连续的子数组和给定一个包含 非负数 的数组和一个目标 整数 k ，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，且总和为 k 的倍数，即总和为 n * k ，其中 n 也是一个整数。 k 是整数，可能为 0 子数组长度至少为 2 返回 bool 值，判断这个值是否存在 12345678910111213141516171819202122// map的key为余数，val不再是余数出现的次数，而是该余数最早出现的位置// 通过这个位置来判断，子树组长度是否大于等于2// k为0的时候，余数就是presum本身，也就变成了是否有两个前缀和是相等的。function checkSubarraySum(nums: number[], k: number): boolean &#123; let presum = 0; let remainder = 0; const map = new Map(); map.set(0, -1); for (let i = 0; i &lt; nums.length; i++) &#123; presum += nums[i]; remainder = k === 0 ? presum : ((presum % k) + k) % k; if (map.has(remainder)) &#123; const index = map.get(remainder); if (i - index &gt;= 2) &#123; return true; &#125; &#125; else &#123; map.set(remainder, i); &#125; &#125; return false;&#125; 930. 和相同的二元子数组","categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"拓扑排序-课程表系列","slug":"拓扑排序-课程表系列","date":"2021-04-12T21:24:21.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2021/04/12/拓扑排序-课程表系列/","link":"","permalink":"http://yoursite.com/2021/04/12/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-%E8%AF%BE%E7%A8%8B%E8%A1%A8%E7%B3%BB%E5%88%97/","excerpt":"","text":"leetcode 207 课程表你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。 在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] &#x3D; [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程 bi 。 例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。 拓扑排序这种在一个图中，互相有依赖关系，需要按照依赖顺序排序输出的问题，就是拓扑排序。拓扑排序除了排序输出之外，还可以验证图中是否有环。比如下面常见的拓扑排序的应用。 课程学习的先后顺序 相互依赖的文件的编译顺序 拓扑排序的方法一是 Kahn 算法。二是深度优先遍历 Kahn 算法个人认为 Kahn 算法还是比较好理解的。首先需要定义 b 依赖与 a，a 要先与 b 执行，那么就是 a-&gt;b。此时 b 的入度是 1，a 的入度是 0。 算法的思路就是首先统计出所有的点的入度，还需要统计所有点的 next 点 然后找到入度为 0 的点，访问它，随后，将该点的所有 next 点的入度都减 1 然后重复 2 这个步骤 直到没有入度为 0 的点为止 123456789101112131415161718192021222324252627282930313233343536function canFinish(numCourses: number, prerequisites: number[][]): boolean &#123; const inDegree = Array(numCourses).fill(0); const adjacent = inDegree.map(() =&gt; []); for (const [cur, pre] of prerequisites) &#123; // pre -&gt; cur inDegree[cur] += 1; adjacent[pre].push(cur); &#125; // 找到所有入度为0的课程 const queue = []; for (let i = 0; i &lt; inDegree.length; i++) &#123; if (inDegree[i] === 0) &#123; queue.push(i); &#125; &#125; const list = []; // 遍历入度为0的课程，入度为0，则加入list, 并将它的临接课程入度-1 while (queue.length) &#123; const cur = queue.shift(); list.push(cur); // 将当前课程的所有后序课程的入度减1，如果后序课程的入度为0，则加入list adjacent[cur].forEach((next) =&gt; &#123; inDegree[next]--; if (inDegree[next] === 0) &#123; queue.push(next); &#125; &#125;); &#125; // 最后验证一下，是否所有的课程都学完了 return list.length === numCourses;&#125; dfs 深度优先遍历深度优先遍历，也是解决拓扑排序的常用办法。其思路就是沿着一个点，一直往前找它的前置点，直到没有前置的点了，就是找到头了。此时就可以回溯访问了（从外到内探索，从内到外回溯访问）。需要注意的是，需要记录点的状态，未访问｜访问中｜已经访问。 如果未访问需要标记未访问中 如果是访问中，则说明又访问了一次，存在环 如果是已经访问，那么直接返回就可以了;比如(这里和 Kahn 算法是反的，a-&gt;b 代表 b 先于 a 执行。a 依赖 b) a-&gt;b-&gt;c d-&gt;b-&gt;c 访问完 a 这条链路，b 和 c 就已经访问了。因此再访问 d 这条链路时，就不需要访问 b 和 c 了 12345678910111213141516171819202122232425262728293031323334353637383940414243function dfs( cur: number, pres: number[][], visited: number[], res: number[]): boolean &#123; if (visited[cur] === 2) &#123; // 已经访问过了 return true; &#125; else if (visited[cur] === 1) &#123; // 正在访问中，结果又来访问了。出现了环 return false; &#125; else &#123; // 设为访问中 visited[cur] = 1; for (let i = 0; i &lt; pres[cur].length; i++) &#123; // 访问前置节点 if (!dfs(pres[cur][i], pres, visited, res)) &#123; return false; &#125; &#125; visited[cur] = 2; res.push(cur); return true; &#125;&#125;function findOrder(numCourses: number, prerequisites: number[][]): number[] &#123; const visited = Array(numCourses).fill(0); // 0-未访问；1-访问中；2-已经访问 const pres = visited.map(() =&gt; []); // 记录节点的前置节点 // 统计节点的前置节点 for (let [cur, pre] of prerequisites) &#123; pres[cur].push(pre); &#125; const res = []; for (let i = 0; i &lt; numCourses; i++) &#123; if (!dfs(i, pres, visited, res)) &#123; return []; &#125; &#125; return res;&#125;","categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"完全二叉树、堆和优先队列","slug":"完全二叉树、堆和优先队列","date":"2021-04-11T14:10:04.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2021/04/11/完全二叉树、堆和优先队列/","link":"","permalink":"http://yoursite.com/2021/04/11/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/","excerpt":"","text":"完全二叉树完全二叉树是满二叉树的一种退化。它只缺少最后一排最右边的一些元素。如下图所示。 完全二叉树的特性完全二叉树有一个优秀的特性。就是它可以保存在一个数组中，而不需要使用链表的方式来存储。如果对完全二叉树中的节点编号，那么可以总结出一个规律。如果父节点的编号是 i，那么它的左子节点的编号就是 2i，右子节点的编号就是 2i+1 实际上，在计算机中，我们会把数组作为完全二叉树的实际存储结构，而完全二叉树，则是我们重新看待这段数组信息的思维逻辑结构。因此，数据结构最大的价值，就是对我们思维逻辑结构的改造。 堆 堆（Heap）是一个可以被看成近似完全二叉树的数组。树上的每一个结点对应数组的一个元素。除了最底层外，该树是完全充满的，而且是从左到右填充。—— 来自：《算法导论》 堆其实就是使用完全二叉树实现的一种数据结构。分为大顶堆和小顶堆。 小顶堆；如果一个完全二叉树的每一个父节点的值都小于其子节点的值，那么就是一个小顶堆。 大顶堆；如果一个完全二叉树的每一个父节点的值都大于其子节点的值，那么就是一个大顶堆。 为了让你更好地学习堆这种数据结构，我要和你分享一个学习数据结构的公式：数据结构 &#x3D; 结构定义 + 结构操作。结构定义和结构操作是组成数据结构最重要的两个部分，也是你之后在学任何一种数据结构时的重点内容。结构定义就是定义一种性质，结构操作就是维护这种性质。 堆的结构定义 大顶堆可以维护一个集合中的最大值。 小顶堆可以维护一个集合中的最小值。 堆的结构操作 插入新元素 插入到最后面（数组的最后） 向上调整，维护堆的特性 删除最值元素 将最后一个元素覆盖堆顶元素（数组尾元素覆盖数组头元素） 向下调整，维护堆的特性 堆排序 对数组建立一个大顶堆 每次将堆顶元素和堆尾元素调换位置（相当于把最大值放在了最后），然后减小堆的 size，从上到下维护堆 执行 n 次之后，得到一个从小到达排序的数组 优先队列 优先队列好像就是堆的别名啊？其实不然。你可以把优先队列当成是一种概念，那它的定义就是一种可以实现根据优先级出队的结构。而堆只是实现优先队列的其中一种方式，当然也是最普遍的方式。 实现一个最(小)大堆123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146abstract class Heap&lt;T&gt; &#123; protected heap: T[] = []; protected getNumberForCompare: (val: T) =&gt; number; protected abstract compare(indexA: number, indexB: number): boolean; constructor(getNumberForCompare: (val: T) =&gt; number, values: T[] = []) &#123; this.getNumberForCompare = getNumberForCompare; this.heapify(values); &#125; // 交换堆内元素 protected swap(indexA: number, indexB: number) &#123; const temp = this.heap[indexA]; this.heap[indexA] = this.heap[indexB]; this.heap[indexB] = temp; &#125; // 获取左孩子的索引 protected getLeftChildIndex(index: number) &#123; return 2 * index + 1; &#125; // 获取右孩子的索引 protected getRightChildIndex(index: number) &#123; return 2 * index + 2; &#125; // 获取父亲节点的索引 protected getParentIndex(index: number) &#123; if (index === 0) return null; return (index - 1) &gt;&gt;&gt; 1; &#125; // 初始化建堆 protected heapify(values: T[]) &#123; this.heap = values; // 完全二叉树的叶子节点的个数是总节点个数的一半。 // 叶子节点本身不需要堆化。只需要等待后面的节点堆化。 for (let i = this.heap.length &gt;&gt;&gt; 1; i &gt;= 0; i--) &#123; this.heapifyDown(i); &#125; &#125; // 向上维护堆 protected heapifyUp(index: number) &#123; let currentIndex = index; let parentIndex = this.getParentIndex(currentIndex); while (parentIndex &gt;= 0 &amp;&amp; this.compare(currentIndex, parentIndex)) &#123; this.swap(currentIndex, parentIndex); currentIndex = parentIndex; parentIndex = this.getParentIndex(parentIndex); &#125; &#125; // 向下维护堆 protected heapifyDown(index: number) &#123; let currentIndex = index; let lChildIndex = this.getLeftChildIndex(currentIndex); let rChildIndex = this.getRightChildIndex(currentIndex); const size = this.size(); // 如果当前值大于左孩子 if (lChildIndex &lt; size &amp;&amp; this.compare(lChildIndex, currentIndex)) &#123; currentIndex = lChildIndex; &#125; // 如果当前值大于右孩子 if (rChildIndex &lt; size &amp;&amp; this.compare(rChildIndex, currentIndex)) &#123; currentIndex = rChildIndex; &#125; // 如果当前索引被替换 if (currentIndex !== index) &#123; this.swap(currentIndex, index); this.heapifyDown(currentIndex); &#125; &#125; // 获取堆的大小 size() &#123; return this.heap.length; &#125; // 判断堆是否为空 isEmpty() &#123; return this.heap.length === 0; &#125; // 插入元素 insert(value: T): boolean &#123; if (value != null) &#123; this.heap.push(value); this.heapifyUp(this.heap.length - 1); return true; &#125; return false; &#125; // 删除堆顶元素 extract(): T &#123; if (this.isEmpty()) return null; if (this.size() === 1) return this.heap.shift(); // 交换堆顶和堆尾元素 this.swap(0, this.heap.length - 1); // 剔除最小元素 const top = this.heap.pop(); // 重新堆化 this.heapifyDown(0); return top; &#125; // 获取堆顶元素 top(): T &#123; return this.isEmpty() ? null : this.heap[0]; &#125; // 获取堆内元素 values(): T[] &#123; return [...this.heap]; &#125;&#125;// 小顶堆export class MinHeap&lt;T&gt; extends Heap&lt;T&gt; &#123; protected compare(indexA: number, indexB: number): boolean &#123; return ( this.getNumberForCompare(this.heap[indexA]) &lt; this.getNumberForCompare(this.heap[indexB]) ); &#125;&#125;// 大顶堆export class MaxHeap&lt;T&gt; extends Heap&lt;T&gt; &#123; protected compare(indexA: number, indexB: number): boolean &#123; return ( this.getNumberForCompare(this.heap[indexA]) &gt; this.getNumberForCompare(this.heap[indexB]) ); &#125;&#125; 参考 Typescript binary heap","categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Express Koa Redux 中间件原理分析","slug":"Express-Koa-Redux中间件原理分析","date":"2021-04-10T12:23:57.000Z","updated":"2022-05-03T13:54:35.977Z","comments":true,"path":"2021/04/10/Express-Koa-Redux中间件原理分析/","link":"","permalink":"http://yoursite.com/2021/04/10/Express-Koa-Redux%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","excerpt":"","text":"最早接触中间件，是在第一次使用 express 框架的时候，那时对中间件的作用有了了解，后面再使用 Koa 框架时，也遇到了中间件，最大的使用感受就是中间件的参数不一样了，可以使用await语法来执行next()函数。几乎于此同时，使用的 Redux 也提出了中间件的概念。中间件的概念被广泛的采用，一定有其优势所在。本篇文章尝试分析和比较 Express Koa2 Redux 这三个框架的实现原理。 调试这三个框架的源码其实非常简单。 书写一个 js 文件，编写代码。 使用 vscode 的 debug 功能启动代码。 使用 curl 请求 localhost。 Express 的中间件express 是内置路由功能的，并且同时内置了static,json,urlencoded 这三个中间件。 下面是启动一个 express app 并注册 App-Level middleware 的代码。通过这段代码来分析 express 启动和中间件运行流程。 1234567891011121314151617// express相当于一个工厂函数，它会返回一个函数，也就是appconst express = require(&quot;express&quot;);const app = express();app.use(function middlewareA(req, res, next) &#123; console.log(&quot;1&quot;); next(); console.log(&quot;2&quot;);&#125;);app.use(function middlewareB(req, res, next) &#123; console.log(&quot;3&quot;); next(); console.log(&quot;4&quot;);&#125;);app.use(function middlewareC(req, res, next) &#123; res.send(&quot;hello world&quot;);&#125;);app.listen(3000); 以上代码返回了一个 express 实例，不过这个实例，是一个挂载了很多属性的函数。下面是express()的调用，在源码中就是createApplication()的调用。如下是源码部分。 123456789101112131415161718192021222324252627// express/lib/express.jsfunction createApplication() &#123; // 定义app是一个函数。 var app = function (req, res, next) &#123; // app.handle 是通过mixin的方式组合进来的 app.handle(req, res, next); &#125;; // 使用组合的方式，给app这个函数上挂载通用方法。 mixin(app, EventEmitter.prototype, false); mixin(app, proto, false); // expose the prototype that will get set on requests app.request = Object.create(req, &#123; app: &#123; configurable: true, enumerable: true, writable: true, value: app &#125;, &#125;); // expose the prototype that will get set on responses app.response = Object.create(res, &#123; app: &#123; configurable: true, enumerable: true, writable: true, value: app &#125;, &#125;); app.init(); // 返回app函数 return app;&#125; app 通过 mixin 的方式挂载了很多的方法，其中就包含了 use 和 listen 方法。他们的源码如下。精简了一下代码。 123456789101112131415161718// express/lib/application.jsapp.use = function use(fn) &#123; var path = &quot;/&quot;; // setup router this.lazyrouter(); var router = this._router; fns.forEach(function (fn) &#123; // 判断当前的中间件函数不是express app if (!fn || !fn.handle || !fn.set) &#123; // 把中间件挂载到路由的跟路径下。 return router.use(path, fn); &#125; &#125;, this); return this;&#125;; 从上面可以看到，router 很重要，即使是 App-Level 中间件，也是挂载到 router 上的。下面看一下 router 的代码。 12345678910111213141516171819202122232425262728293031323334353637383940// express/lib/router/index.jsproto.use = function use(fn) &#123; var offset = 0; var path = &quot;/&quot;; // default path to &#x27;/&#x27; // disambiguate router.use([fn]) if (typeof fn !== &quot;function&quot;) &#123; var arg = fn; while (Array.isArray(arg) &amp;&amp; arg.length !== 0) &#123; arg = arg[0]; &#125; // first arg is the path if (typeof arg !== &quot;function&quot;) &#123; offset = 1; path = fn; &#125; &#125; var callbacks = flatten(slice.call(arguments, offset)); for (var i = 0; i &lt; callbacks.length; i++) &#123; var fn = callbacks[i]; // 根据path和中间件函数生成一个layer实例 // 这里layer大概就是，根据path将处理流程分为一个一个层。 var layer = new Layer( path, &#123; sensitive: this.caseSensitive, strict: false, end: false, &#125;, fn ); layer.route = undefined; // 最后将layer推入一个栈中。相当于把中间件保存了起来。 this.stack.push(layer); &#125; return this;&#125;; 上面 router 的代码，就是最终实现了 app.use 方法保存中间件函数的逻辑。如果断点调试，会发现一个有趣的事实，就是在我们的 middlewareA 中间件之前，express 已经加入了两个默认的 layer。如下图 下面再来看下程序运行并收到请求后的执行流程。首先是 app.listen，通过 http.createServer 构造了一个 server 实例，实例的回调函数，就是 app 本身，这种写法也是非常骚了，把一个 app 函数玩弄于股掌之间。 1234app.listen = function listen() &#123; var server = http.createServer(this); return server.listen.apply(server, arguments);&#125;; 从 createApplication 函数中可以看到，app 函数本身，就是调用了 app.handle,而 app.handle 又是调用了router.handle 囧。所以我们的每个请求，其实最终就是由 router.handle 来处理了，并且会在这里展开对所有中间件的调用。这个代码很长，我们精简一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130// express/lib/router/index.jsproto.handle = function handle(req, res, out) &#123; var self = this; var idx = 0; var protohost = getProtohost(req.url) || &quot;&quot;; var removed = &quot;&quot;; var slashAdded = false; var paramcalled = &#123;&#125;; // store options for OPTIONS request // only used if OPTIONS request var options = []; // middleware and routes var stack = self.stack; // manage inter-router variables var done = restore(out, req, &quot;baseUrl&quot;, &quot;next&quot;, &quot;params&quot;); // setup next layer req.next = next; next(); function next(err) &#123; var layerError = err === &quot;route&quot; ? null : err; // signal to exit router if (layerError === &quot;router&quot;) &#123; setImmediate(done, null); return; &#125; // no more matching layers if (idx &gt;= stack.length) &#123; setImmediate(done, layerError); return; &#125; // get pathname of request var path = getPathname(req); if (path == null) &#123; return done(layerError); &#125; // find next matching layer var layer; var match; var route; while (match !== true &amp;&amp; idx &lt; stack.length) &#123; layer = stack[idx++]; match = matchLayer(layer, path); route = layer.route; if (typeof match !== &quot;boolean&quot;) &#123; // hold on to layerError layerError = layerError || match; &#125; if (match !== true) &#123; continue; &#125; if (!route) &#123; // process non-route handlers normally continue; &#125; if (layerError) &#123; // routes do not match with a pending error match = false; continue; &#125; var method = req.method; var has_method = route._handles_method(method); // build up automatic options response if (!has_method &amp;&amp; method === &quot;OPTIONS&quot;) &#123; appendMethods(options, route._options()); &#125; // don&#x27;t even bother matching route if (!has_method &amp;&amp; method !== &quot;HEAD&quot;) &#123; match = false; continue; &#125; &#125; // no match if (match !== true) &#123; return done(layerError); &#125; // store route for dispatch on change if (route) &#123; req.route = route; &#125; // Capture one-time layer values req.params = self.mergeParams ? mergeParams(layer.params, parentParams) : layer.params; var layerPath = layer.path; // this should be done for the layer self.process_params(layer, paramcalled, req, res, function (err) &#123; if (err) &#123; return next(layerError || err); &#125; if (route) &#123; return layer.handle_request(req, res, next); &#125; trim_prefix(layer, layerError, layerPath, path); &#125;); &#125; if (layerError) &#123; layer.handle_error(layerError, req, res, next); &#125; else &#123; layer.handle_request(req, res, next); &#125; &#125;&#125;; 可以看到，关键的就是 next 函数了，next 函数引用了一个外部变量 idx ，形成了一个包含 idx 的闭包，next 函数每次执行，都会找到下一个需要执行的中间件(layer), 然后执行 layer.handle_request(req, res, next); , 在执行的过程中，将 next 函数本身作为参数传递，这样当中间件执行 next 的时候，又会重复上述过程。通过 next 的执行，串起了一个一个中间件。 Express 中间件的总结第一段代码的输出为 1 3 4 2, 其实也可以说 express 的中间件执行顺序类似与洋葱圈模型。但是，express 结束请求，返回响应的标志是 res.send ，也就是说一旦调用了 res.send,那么响应也就结束了，虽然后序的代码仍然会继续执行。但是已经影响不到响应了。这也是和 koa 的一个重要区别。 另一个要说明的就是，express 相对于 koa，内置了路由系统，甚至中间件也是挂载在路由上的，因此源代码比 koa 更加复杂。express 成型的时间比较早，内部的写法还都是函数，也没有明显的使用 promise async await 等先进的特性。 参考 [1] express [2] koa 和 express 中间件揭秘 [3] express 和 koa 的区别","categories":[],"tags":[{"name":"中间件","slug":"中间件","permalink":"http://yoursite.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"express","slug":"express","permalink":"http://yoursite.com/tags/express/"},{"name":"koa","slug":"koa","permalink":"http://yoursite.com/tags/koa/"},{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"}]},{"title":"二叉树系列","slug":"二叉树系列","date":"2021-04-07T09:51:15.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2021/04/07/二叉树系列/","link":"","permalink":"http://yoursite.com/2021/04/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%97/","excerpt":"","text":"(搜索)二叉树这种数据结构，操作和判断特别多，这篇文章归纳和整理一下它的常见操作。一个有趣的现象是，关于二叉树，有广度优先和深度优先两种搜索办法。如果是广度优先，常规做法是使用一个辅助队列 queue。如果是深度优先，常规做法是使用递归。 验证二叉搜索树 对称二叉树 二叉树的前中后序遍历 二叉树的层次遍历&#x2F;锯形层次遍历 二叉树最近公共祖先 二叉树最大&#x2F;最小深度 删除二叉树中的节点 从中序遍历和后序遍历构造二叉树 验证二叉搜索树 98验证一棵树是否为二叉搜索树，有两种方法。都是基于二叉搜索树的特征。 基于二叉搜索树的中序遍历结果是升序序列。 中序遍历整个二叉搜索树，遍历的过程中查验是否为升序。 基于节点的左子树中所有的节点的值，均小于当前节点的值；节点的右子树中所有节点的值，均大于当前节点的值。 根节点的值的范围为(-Infinity,Infinity)。其左子节点的值应该小于 root.val, 所以范围应该为(-Infinity,root.val)。同理，右子节点的范围应该为(root.val,Infinity)。树上的每个节点都应该满足上面的条件。 递归代码1234567891011121314function helper(root: TreeNode | null, min: number, max: number): boolean &#123; if (!root) return true; // 不满足条件 if (root.val &lt;= min || root.val &gt;= max) &#123; return false; &#125; // 递归验证左右孩子是否满足条件 return helper(root.left, min, root.val) &amp;&amp; helper(root.right, root.val, max);&#125;function isValidBST(root: TreeNode | null): boolean &#123; // root节点的取值范围为(-Infinity,Infinity) return helper(root, -Infinity, Infinity);&#125; 对称二叉树 剑指 offer28验证一个树是否为对称二叉树，优雅的方案还是递归，毕竟要一层一层的比较，而且每次比较的模式都是一样的。 递归代码123456789101112131415161718192021function helper(left: TreeNode | null, right: TreeNode | null): boolean &#123; if (!left &amp;&amp; !right) &#123; // 都不存在 return true; &#125; else if (left &amp;&amp; right) &#123; if (left.val === right.val) &#123; // 当前两个节点是对称的，继续去验证他们的孩子是否对称 return helper(left.left, right.right) &amp;&amp; helper(left.right, right.left); &#125; else &#123; // 不对称相等 return false; &#125; &#125; else &#123; // left或者right，只存在一个 return false; &#125;&#125;function isSymmetric(root: TreeNode | null): boolean &#123; return helper(root, root);&#125; 二叉树的前中后序遍历 94这里以二叉树的中序遍历为例子。使用递归，中序遍历的实现很容易实现（代码简单）。比较难（或者说不容易记住和理解）的是使用迭代的方式来遍历。不过话说回来，明明递归的代码看上去更简洁明了，可能是更符合人们的思维习惯。相反如果是使用迭代，确需要肯定的理解其执行过程 😖。 递归代码12345678910111213function helper(root: TreeNode | null, res: number[]) &#123; if (!root) return; helper(root.left, res); res.push(root.val); helper(root.right, res);&#125;function inorderTraversal(root: TreeNode | null): number[] &#123; const res: number[] = []; helper(root, res); return res;&#125; 迭代代码12345678910111213141516171819202122function inorderTraversal(root: TreeNode | null): number[] &#123; if (!root) return []; const res = []; // 既然是递归，就要用栈来模拟咯 const stack = []; while (stack.length || root) &#123; while (root) &#123; stack.push(root); root = root.left; &#125; // 此时的root为null，栈顶元素就是最左边的叶子节点 // 弹出并访问 const node = stack.pop(); res.push(node.val); // 这一步很关键，开始准备遍历右子树 root = node.right; &#125; return res;&#125; 二叉树的层次遍历 使用递归，也就是 dfs 深度优先搜索。 可以使用一个队列来保存被访问的节点，也就是广度优先搜索。 递归代码123456789101112131415function helper(root: TreeNode | null, index: number, res: number[][]) &#123; if (!root) return; res[index] ? res[index].push(root.val) : (res[index] = [root.val]); helper(root.left, index + 1, res); helper(root.right, index + 1, res);&#125;function levelOrder(root: TreeNode | null): number[][] &#123; if (!root) return []; const res = []; helper(root, 0, res); return res;&#125; 迭代代码1234567891011121314151617function levelOrder(root: TreeNode | null): number[][] &#123; if (!root) return []; const queue = [root]; const res = []; while (queue.length) &#123; const length = queue.length; const temp = []; for (let i = 0; i &lt; length; i++) &#123; const node = queue.shift(); temp.push(node.val); if (node.left) queue.push(node.left); if (node.right) queue.push(node.right); &#125; res.push(temp); &#125; return res;&#125; 二叉树最近公共祖先前提条件是 p 和 q 都是树中的节点。 递归代码12345678910111213141516171819function lowestCommonAncestor( root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null &#123; if (!root) return root; if (root === p || root === q) return root; const left = lowestCommonAncestor(root.left, p, q); const right = lowestCommonAncestor(root.right, p, q); if (left &amp;&amp; right) &#123; return root; &#125; else if (left) &#123; return left; &#125; else &#123; return right; &#125;&#125; 二叉树的最大深度递归求出左右子树深度的最大值，然后加 1。 1234567891011121314151617function maxDepth(root: TreeNode | null): number &#123; if (!root) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;&#125;function minDepth(root: TreeNode | null): number &#123; if (!root) return 0; if (!root.left &amp;&amp; !root.right) return 1; let min = Infinity; if (root.left) &#123; min = Math.min(minDepth(root.left), min); &#125; if (root.right) &#123; min = Math.min(minDepth(root.right), min); &#125; return min + 1;&#125;","categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"常用React hooks","slug":"常用React-hooks","date":"2021-04-05T21:32:11.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2021/04/05/常用React-hooks/","link":"","permalink":"http://yoursite.com/2021/04/05/%E5%B8%B8%E7%94%A8React-hooks/","excerpt":"","text":"React hooks 已经很普及了。记录和整理一些比较通用的 hook。 useMount返回组件挂载的状态。可以在一些异步处理之后，判断组件是否已经被卸载。 1234567891011function useMount() &#123; const mount = useRef(false); useEffect(() =&gt; &#123; mount.current = true; return () =&gt; &#123; mount.current = false; &#125;; &#125;, []); return () =&gt; mount.current;&#125; usePreProps返回上一次的 props，也可以用来判断某个 props 是否改变。 123456789function usePreProps(props) &#123; const ref = useRef(props); useEffect(() =&gt; &#123; ref.current = props; &#125;, [props]); // return ref.current === props; // 判断属性是否改变 return ref.current; // 返回上一次的属性&#125; useOnScreen返回组件是否曝光。 12345678910111213141516171819202122const useOnScreen = (ref: React.RefObject&lt;any&gt;, rootMargin = &quot;0px&quot;) =&gt; &#123; if (!ref || !ref.current) return; const [intersecting, setIntersecting] = useState(false); // 是否已经曝光 useEffect(() =&gt; &#123; const ovserver = new IntersectionObserver( ([entry]) =&gt; &#123; setIntersecting(entry.isIntersecting); &#125;, &#123; rootMargin &#125; ); ovserver.observe(ref.current); return () =&gt; &#123; observer.unobserve(ref.current); &#125;; &#125;, []); return [intersecting];&#125;;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"leetcode-n数之和系列","slug":"leetcode-N数之和系列","date":"2021-03-26T09:17:51.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2021/03/26/leetcode-N数之和系列/","link":"","permalink":"http://yoursite.com/2021/03/26/leetcode-N%E6%95%B0%E4%B9%8B%E5%92%8C%E7%B3%BB%E5%88%97/","excerpt":"","text":"N 数之和系列两数之和给定一个数组，一个 target，找到数组中所有两个数字之和为 target 的组合。这里为了后面 N 数之和做准备，不是返回一个组合。 代码123456789101112131415161718192021222324function twoSum(nums: number[], target: number): number[][] &#123; // 先排序数组 nums.sorts((a, b) =&gt; a - b); // 双指针遍历 let left = 0; let right = nums.length - 1; const res = []; while (left &lt; right) &#123; const lVal = nums[left]; const rVal = nums[right]; if (lVal + rVal === target) &#123; res.push([lVal, rVal]); // 排除重复的 while (nums[left] === lVal) left++; while (nums[right] === rVal) right--; &#125; else if (lVal + rVal &lt; target) &#123; left++; &#125; else &#123; right--; &#125; &#125; return res;&#125; 三数之和有了两数之和，三数之和的计算就可以依赖现有的两数之和的函数，但是要稍微改造一下。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243// 更加泛型（通用）的两数之和函数// 默认数组已经排序function twoSum(nums: number[], target: number, start: number): number[][] &#123; // 双指针遍历 let left = start; let right = nums.length - 1; const res = []; while (left &lt; right) &#123; const lVal = nums[left]; const rVal = nums[right]; if (lVal + rVal === target) &#123; res.push([lVal, rVal]); // 排除重复的 while (nums[left] === lVal) left++; while (nums[right] === rVal) right--; &#125; else if (lVal + rVal &lt; target) &#123; left++; &#125; else &#123; right--; &#125; &#125; return res;&#125;function threeSum(nums: number[]): number[][] &#123; if (nums.length &lt; 3) return []; nums.sort((a, b) =&gt; a - b); const res = []; for (let i = 0; i &lt; nums.length; i++) &#123; // 遍历第一个数字，下面要求两数之和，和为target-nums[i] const newTarget = 0 - nums[i]; const newStart = i + 1; const temp = twoSum(nums, newTarget, newStart); for (let j = 0; j &lt; temp.length; j++) &#123; res.push([nums[i], ...temp[j]]); &#125; // 去除重复的结果 while (nums[i] === nums[i + 1]) i++; &#125; return res;&#125; N 数之和有了上面的例子，继而推演出 N 数之和的通用方法，也就有了思路。每次确定一个数字，最终只剩两个数字的时候，就是调用两数之和的时候。需要注意的是，常规的想法是 N 是几，就进行 N-1 层遍历。这里 N 是未知的。不过可以使用递归，来一层一层的减少 N 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 更加泛型（通用）的两数之和函数// 默认数组已经排序function twoSum(nums: number[], target: number, start: number): number[][] &#123; // 双指针遍历 let left = start; let right = nums.length - 1; const res = []; while (left &lt; right) &#123; const lVal = nums[left]; const rVal = nums[right]; if (lVal + rVal === target) &#123; res.push([lVal, rVal]); // 排除重复的 while (nums[left] === lVal) left++; while (nums[right] === rVal) right--; &#125; else if (lVal + rVal &lt; target) &#123; left++; &#125; else &#123; right--; &#125; &#125; return res;&#125;// 这里数组已经排序function nSum( nums: number[][], target: number, n: number, start: number, visited: number[], ans: number[][] = []): number[][] &#123; // 注意这里是大于 if (n + start &gt; nums.length) return []; if (n === 2) &#123; // 可以调用两数之和 const temp = twoSum(nums, target, start); for (let i = 0; i &lt; temp.length; i++) &#123; ans.push([...visited, ...temp[i]]); &#125; return; &#125; else &#123; // n大于2 for (let i = start; i &lt; nums.length; i++) &#123; const newTarget = target - nums[i]; const newN = n - 1; const newStart = i + 1; const newVisited = [...visited, nums[i]]; nSum(nums, newTarget, newN, newStart, newVisited, ans); // 去除重复的 while (nums[i] === nums[i + 1]) i++; &#125; &#125; return ans;&#125;// 例如求四数之和function fourSum(nums: number[], target: number): number[][] &#123; nums.sort((a, b) =&gt; a - b); return nSum(nums, target, 4, 0, []);&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"leetcode-买卖股票的最佳时机系列(121,122,123,188)","slug":"leetcode-买卖股票的最佳时机系列","date":"2021-03-14T18:32:46.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2021/03/14/leetcode-买卖股票的最佳时机系列/","link":"","permalink":"http://yoursite.com/2021/03/14/leetcode-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E7%B3%BB%E5%88%97/","excerpt":"","text":"121 买卖股票的最佳时机 I给定一只股票，但是只能买卖一次。 暴力法进行两层循环，第一层循环是买入的日子，第二层循环是卖出的日子，遍历左右的利润，求出最大值。 代码1234567891011function maxProfit(prices: number[]): number &#123; if (prices.length &lt; 2) return 0; const length = prices.length; let profit = 0; for (let i = 0; i &lt; length; i++) &#123; for (let j = i + 1; j &lt; length; j++) &#123; profit = Math.max(profit, prices[j] - prices[i]); &#125; &#125; return profit;&#125; 优化进行一次遍历，在遍历的过程中修改变量，一个是当前最低的价格，一个是当前的利润。如果当前价格低于最低价格，则更新最低价格。用当前的价格减去最低价格，即是这一天能够获得的最大利润。 代码12345678910111213function maxProfit(prices: number[]): number &#123; if (prices.length &lt; 2) return 0; const length = prices.length; let minPrice = prices[0]; let profit = 0; for (let i = 1; i &lt; prices.length; i++) &#123; if (prices[i] &lt; minPrice) &#123; minPrice = prices[i]; &#125; profit = Math.max(profit, prices[i] - minPrice); &#125; return profit;&#125; 122 买卖股票的最佳时机 II暴力法对于每个股票交易日，都有两种选择，一种是按兵不动，即不进行任何操作。还有一种是根据当前股票的持有情况，进入买进或者卖出，比如当前持有股票就可以卖出，当前没有股票就进行买入。 每一个交日易都有不同的选择，一次一次的选择形成了一棵操作树，这是典型的 dfs 了。 暴力法代码12345678910111213141516171819202122232425262728function maxProfit(prices: number[]): number &#123; let max = 0; const length = prices.length; // status:0代表手上没有股票，可以买。1代表手上有股票，可以卖。 const dfs = (count: number, profit: number, status: number) =&gt; &#123; if (count === length) &#123; max = Math.max(max, profit); return; &#125; // 按兵不动 dfs(count + 1, profit, status); // 进行操作 if (status === 0) &#123; // 进行买入，利润要减掉当前价格 dfs(count + 1, profit - prices[count], 1); &#125; else if (status === 1) &#123; // 进行卖出，利润要加上当前价格 dfs(count + 1, profit + prices[count], 0); &#125; &#125;; dfs(0, 0, 0); return max;&#125; 贪心算法这个问题，可以使用贪心算法，即根据当日的价格来决定上个交易日是否进行买入，只要今天的价格比昨天高，就昨天买日，今天卖出。当然现实情况下，是不可能买入昨天的股票的。 贪心法代码123456789101112function maxProfit(prices: number[]): number &#123; if (!prices || prices.length &lt; 2) return 0; let profit = 0; for (let i = 1; i &lt; prices.length; i++) &#123; if (prices[i] &gt; prices[i - 1]) &#123; profit += prices[i] - prices[i - 1]; &#125; &#125; return profit;&#125; 动态规划如果使用动态规划来解决这个问题，那么需要保存一个二维的状态，dp[i][j]。dp[i][0] 代表第 i 天，手上没有股票时的收益。dp[i][1]代表第 i 天手上有股票的收益。那么推导一下状态方程就是 dp[i][0] &#x3D; Math.max(dp[i-1][0],dp[i-1][1]+prices[i]) 也就是第 i 天手上没有股票时，可以是 i-1 天本来就没有股票，然后第 i 天不进行任何操作，或者是 i-1 天持有股票，然后将其卖出。取两者的最大值。 dp[i][1] &#x3D; Math.max(dp[i-1][1],dp[i-1][0]-prices[i]) 也就是第 i 天手上有股票时，可以是 i-1 天本来就有股票，然后第 i 天按兵不动，或者第 i-1 天手上没有骨片，然后今天买进。取两者的最大值。 最后我们期望的结果就是 dp[n][0]。也就是最后一天手上没有股票时的金额。可以看出第 n 天的最大收益，是根据之前的每一天的收益情况，一点一点推导出来的。非常经典的动态规划。 动态规划代码1234567891011121314function maxProfit(prices: number[]): number &#123; if (!prices || prices.length &lt; 2) return 0; const dp = prices.map(() =&gt; [0, 0]); dp[0][0] = 0; dp[0][1] = -prices[0]; for (let i = 1; i &lt; prices.length; i++) &#123; dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); &#125; return dp[prices.length - 1][0];&#125; 123 买卖股票的最佳时机 III不同于买卖股票的最佳时机 II。这次只能交易两次了。这次我们只选择动态规划来解决这个问题。我们把买进股票作为交易一次股票的标志。 动态规划首先需要增加一个状态，来记录当前已经交易了几次。dp[i][j][k] ,j 代表了是第几次买进股票了。可以的取值为 0，1，2。k 还是代表当前手上是否持有股票，0 表示不持有，1 表示持有。 代码1234567891011121314151617181920212223242526272829303132333435function maxProfit(prices: number[]): number &#123; if (prices.length &lt; 2) return 0; const length = prices.length; // 初始化三维dp数组 const dp = prices.map(() =&gt; Array(2)); for (let i = 0; i &lt; length; i++) &#123; for (let j = 0; j &lt;= 2; j++) &#123; dp[i][j] = []; &#125; &#125; // 初始化状态 for (let i = 0; i &lt; length; i++) &#123; dp[i][0][0] = 0; // 第i天，没有交易股票，手上也没有股票 dp[i][0][1] = -Infinity; // 第i天，没有交易股票，手上有一股，是不可能的。 &#125; for (let j = 0; j &lt;= 2; j++) &#123; dp[0][j][0] = 0; // 第1天，买入了j次，手上没有股票 dp[0][j][1] = -pirces[0]; // 第一天，买入了j次，手上有股票 &#125; for (let i = 1; i &lt; length; i++) &#123; for (let j = 1; j &lt;= 2; j++) &#123; dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]); dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]); &#125; &#125; // 求最后一天，手上没有股票时的最大利润 let maxProfit = 0; for (let j = 0; j &lt;= 2; j++) &#123; maxProfit = Math.max(maxProfit, dp[length - 1][j][0]); &#125; return maxProfit;&#125; 188 买卖股票的最佳时机 IV这一次又升级了，可以买卖 k 次 动态规划状态方程可以参考买卖两次。其实已经将算法范型化，支持将 2 次变成 k 次就可以了。需要注意的是，当 k&gt;&#x3D;len&#x2F;2 的时候，问题相当于变成了可以交易无数次，也就是 122，这时可以直接采用 122 的贪心算法。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function greedy(prices: number[]): number &#123; if (!prices || prices.length &lt; 2) return 0; let profit = 0; for (let i = 1; i &lt; prices.length; i++) &#123; if (prices[i] &gt; prices[i - 1]) &#123; profit += prices[i] - prices[i - 1]; &#125; &#125; return profit;&#125;function maxProfit(k: number, prices: number[]): number &#123; if (prices.length &lt; 2) return 0; if (k &gt;= prices.length / 2) return greedy(prices); const length = prices.length; // 初始化三维dp数组 const dp = prices.map(() =&gt; Array(k + 1)); for (let i = 0; i &lt; length; i++) &#123; for (let j = 0; j &lt;= k; j++) &#123; dp[i][j] = []; &#125; &#125; // 初始化状态 for (let i = 0; i &lt; length; i++) &#123; dp[i][0][0] = 0; // 第i天，没有交易股票，手上也没有股票 dp[i][0][1] = -Infinity; // 第i天，没有交易股票，手上有一股，是不可能的。 &#125; for (let j = 0; j &lt;= k; j++) &#123; dp[0][j][0] = 0; // 第1天，买入了j次，手上没有股票 dp[0][j][1] = -prices[0]; // 第一天，买入了j次，手上有股票 &#125; for (let i = 1; i &lt; length; i++) &#123; for (let j = 1; j &lt;= k; j++) &#123; dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]); dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]); &#125; &#125; // 求最后一天，手上没有股票时的最大利润 let maxProfit = 0; for (let j = 0; j &lt;= k; j++) &#123; maxProfit = Math.max(maxProfit, dp[length - 1][j][0]); &#125; return maxProfit;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"leetcode-142-环形链表","slug":"leetcode-142-环形链表","date":"2021-03-14T11:05:49.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2021/03/14/leetcode-142-环形链表/","link":"","permalink":"http://yoursite.com/2021/03/14/leetcode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/","excerpt":"","text":"142 环形链表解法 1遍历链表，同时使用一个 set 存储已经访问过的节点，如果当前正在访问的节点存在于 set 中，则说明找到了换的入口。返回该节点。 12345678910111213function detectCycle(head: ListNode | null): ListNode | null &#123; const set = new Set&lt;ListNode&gt;(); let node = head; while (node) &#123; if (set.has(node)) &#123; return node; &#125; else &#123; set.add(node); node = node.next; &#125; &#125; return null;&#125; 解法 2假设起点到环的入口点的距离是 a，慢指针和快指针在环内相遇，慢指针在环内走过的距离是 b，环内剩下的距离是 c，则环的周长是 b+c。快指针走过的距离是慢指针的 2 倍。 12345slow * 2 = fastslow = a + bfast = a + b + (b + c)2 * (a + b) = a + b + (b + c);a = c 可以推导出环内剩余路程 c，和 a 距离相等。因此定义一个指针从 head 出发，慢指针继续走，相遇点即为入口点。 12345678910111213141516171819202122232425function detectCycle(head: ListNode | null): ListNode | null &#123; let slow = head; let fast = head; while (fast &amp;&amp; fast.next) &#123; slow = slow.next; fast = fast.next.next; if (slow === fast) &#123; break; &#125; &#125; // 没有环 if (!fast || !fast.next) return null; // 有环 let p = head; while (p !== slow) &#123; p = p.next; slow = slow.next; &#125; return p;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"并查集","slug":"并查集","date":"2021-03-13T22:30:17.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2021/03/13/并查集/","link":"","permalink":"http://yoursite.com/2021/03/13/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"并查集并查集一种数据结构，可以用一个 Class 来实现。可以把一组数据关联起来，然后统计数量。可以用来解决岛屿数量的问题。 实现 使用一个数组来保存每一项的父节点 使用一个数组来保存每一项的层级 一个 findRoot 方法，可以找到一项的根 一个 union 方法，如果两项的根不同，可以合并两项的根，使他们俩的根相同 1234567891011121314151617181920212223242526272829303132333435363738394041424344class UnionFind &#123; parent: number[] = []; rank: number[] = []; count: number = 0; constructor(nums: number[][]) &#123; const m = nums.length; const n = nums[0].length; for (let i = 0; i &lt; m; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; this.rank[i * n + j] = 0; if (nums[i][j]) &#123; this.parent[i * n + j] = i * n + j; this.count++; &#125; &#125; &#125; &#125; find(num: number): number &#123; if (this.parent[num] !== num) &#123; this.parent[num] = this.find(this.parent[num]); &#125; return this.parent[num]; &#125; union(x: number, y: number) &#123; const rootX = this.find(x); const rootY = this.find(y); if (rootX !== rootY) &#123; if (this.rank[rootX] &lt; this.rank[rootY]) &#123; this.parent[rootX] = rootY; &#125; else if (this.rank[rootX] &gt; this.rank[rootY]) &#123; this.parent[rootY] = rootX; &#125; else &#123; // rank rootX 等于 rank rootY this.parent[rootX] = rootY; this.rank[rootY]++; &#125; this.count--; &#125; &#125;&#125;","categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"省份数量和岛屿数量-两种DFS","slug":"省份数量和岛屿数量-两种DFS","date":"2021-03-13T22:26:19.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2021/03/13/省份数量和岛屿数量-两种DFS/","link":"","permalink":"http://yoursite.com/2021/03/13/%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F%E5%92%8C%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-%E4%B8%A4%E7%A7%8DDFS/","excerpt":"","text":"省份数量和岛屿数量-两种 DFS省份数量 计算省份数量，也可以是计算朋友圈的数量。从 1 到 n，一共有 n 个城市，他们的连接关系可以用一个二维数组来表示。 1234567const isConnected = [ [1, 1, 0], [1, 1, 0], [0, 0, 1],];// isConnected[i][j]=1 代表了i和j这两个连接，isConnected[i][j]=0则代表不直接连接。 连接具有传递性。i-&gt;j 连接，j-&gt;k 连接，那么 i-&gt;k。所有相连接的城市（朋友）构成了一个省份（朋友圈）。求所有省份的数量。 这里需要用到 DFS 去搜索，并且需要一个 visited 来记录哪些城市已经被访问过了。遍历这 n 个城市，如果没有被 visited，省份就加 1。比如搜索到了城市 i，那么就顺着把 i 这个链条都去访问一遍，并且记录在 visited 里面。 1234567891011121314151617181920212223242526272829303132function dfs( isConnected: number[][], visited: boolean[], i: number, m: number) &#123; if (visited[i]) return; visited[i] = true; for (let j = 0; j &lt; m; j++) &#123; if (isConnected[i][j]) &#123; dfs(isConnected, visited, j, m); &#125; &#125;&#125;function findCircleNum(isConnected: number[][]): number &#123; if (!isConnected.length || !isConnected[0].length) return 0; const m = isConnected.length; const visited = Array(m).fill(false); let count = 0; for (let i = 0; i &lt; m; i++) &#123; if (!visited[i]) &#123; count++; dfs(isConnected, visited, i, m); &#125; &#125; return count;&#125; 岛屿数量使用二维矩阵代表一篇区域，如果 grid[i][j]为 1 代表陆地，如果 grid[i][j]为 0 代表海洋，所有连接的 1 构成一个岛屿，求岛屿的数量。 也是 dfs，遍历整个二维矩阵，如果当前是陆地，就 dfs 搜索这个点的周围区域，并且把周围区域标记为 0。需要向四个方向来进行 dfs。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function bfs(grid: string[][], i: number, j: number, m: number, n: number) &#123; const queue = [[i, j]]; while (queue.length) &#123; const [a, b] = queue.shift(); if (grid[a][b] === &quot;1&quot;) &#123; grid[a][b] = &quot;0&quot;; if (a - 1 &gt;= 0 &amp;&amp; grid[a - 1][b] === &quot;1&quot;) queue.push([a - 1, b]); if (a + 1 &lt; m &amp;&amp; grid[a + 1][b] === &quot;1&quot;) queue.push([a + 1, b]); if (b - 1 &gt;= 0 &amp;&amp; grid[a][b - 1] === &quot;1&quot;) queue.push([a, b - 1]); if (b + 1 &lt; n &amp;&amp; grid[a][b + 1] === &quot;1&quot;) queue.push([a, b + 1]); &#125; &#125;&#125;function dfs(grid: string[][], i: number, j: number, m: number, n: number) &#123; if (i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n || grid[i][j] == &quot;0&quot;) &#123; return; &#125; grid[i][j] = &quot;0&quot;; const dirs = [ [1, 0], [-1, 0], [0, -1], [0, 1], ]; for (const [dx, dy] of dirs) &#123; dfs(grid, dx + i, dy + j, m, n); &#125;&#125;function numIslands(grid: string[][]): number &#123; if (!grid.length || !grid[0].length) return 0; const copy = grid.map((item) =&gt; [...item]); const m = copy.length; const n = copy[0].length; let count = 0; for (let i = 0; i &lt; m; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; if (copy[i][j] == &quot;1&quot;) &#123; count++; dfs(copy, i, j, m, n); &#125; &#125; &#125; return count;&#125; 对比 省份是沿着一个链接链条进行 dfs，并标记 visited 岛屿是沿着一个点，向四个方向进行 dfs，并将 grid 置为 0。 也可以使用 bfs","categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"leetcode-101-105-23-使用递归吧","slug":"leetcode-101-105-23-使用递归吧","date":"2021-01-14T23:23:28.000Z","updated":"2022-05-03T13:54:35.977Z","comments":true,"path":"2021/01/14/leetcode-101-105-23-使用递归吧/","link":"","permalink":"http://yoursite.com/2021/01/14/leetcode-101-105-23-%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%90%A7/","excerpt":"","text":"101-105-23 使用递归吧 101 对称二叉树 105 根据中序遍历和先序遍历构造二叉树 23 合并 k 个升序链表 这几个问题虽然情景各不一样，但是都可以使用递归的编程技巧来解决问题。 101 对称二叉树使用递归 使用两个指针 p 和 q，初始化都指向 root 节点。 判断 p.val&#x3D;&#x3D;&#x3D;q.val，如果相等那么 p 和 q 同时移动，但是移动的方向是对称的，也就是 p 向左移动，那么 q 就要向右移动。 由于要比较和操作 p 和 q 两个指针，因此我们的函数也需要两个参数 代码如下： 123456789101112131415function helper(p: TreeNode | null, q: TreeNode | null): boolean &#123; if (!p &amp;&amp; !q) return true; if (!p || !q) return false; if (p.val !== q.val) return false; const inner = helper(p.left, q.right); // 验证内对称 const outer = helper(p.right, q.left); // 验证外对称 return inner &amp;&amp; outer;&#125;function isSymmetric(root: TreeNode | null): boolean &#123; return helper(root, root);&#125; 这里的为了验证对称性，内部调用了两次 helper，这也算是树的递归常见模式，针对不同的情况，分开递归调用。其中 helper 还可以简写为如下形式。 123456function helper(p: TreeNode | null, q: TreeNode | null): boolean &#123; if (!p &amp;&amp; !q) return true; if (!p || !q) return false; return p.val === q.val &amp;&amp; helper(p.left, q.right) &amp;&amp; helper(p.right, q.left);&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"leetcode-71-简化路径","slug":"leetcode-71-简化路径","date":"2020-11-21T22:57:38.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2020/11/21/leetcode-71-简化路径/","link":"","permalink":"http://yoursite.com/2020/11/21/leetcode-71-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/","excerpt":"","text":"71 路径总和示例示例 1： 输入：”&#x2F;home&#x2F;“输出：”&#x2F;home”解释：注意，最后一个目录名后面没有斜杠。示例 2： 输入：”&#x2F;..&#x2F;“输出：”&#x2F;“解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。示例 3： 输入：”&#x2F;home&#x2F;&#x2F;foo&#x2F;“输出：”&#x2F;home&#x2F;foo”解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。示例 4： 输入：”&#x2F;a&#x2F;.&#x2F;b&#x2F;..&#x2F;..&#x2F;c&#x2F;“输出：”&#x2F;c”示例 5： 输入：”&#x2F;a&#x2F;..&#x2F;..&#x2F;b&#x2F;..&#x2F;c&#x2F;&#x2F;.&#x2F;&#x2F;“输出：”&#x2F;c” 问题分析Round One一开始没有头绪，大概想到了依次读取字符串，然后利用栈。比如遇到..就 pop 一个元素。但是没有整理出完整的思路。 Round Two不啰嗦，直接看 leetcode 上的 discussion 吧。果然人家的思路清晰又简单。 使用’&#x2F;‘将路径字符串分割为路径数组。准备一个栈 遍历数组 遇到 ‘’ 直接 continue(分割了&#x2F;&#x2F;) 遇到 ‘.’ 直接 continue(分割了&#x2F;.&#x2F;) 遇到’..’ stack.pop() 需要返回上一级 遇到普通字符串 stack.push() 进入一级 代码实现12345678910111213141516function simplifyPath(path: string): string &#123; const arr = path.split(&quot;/&quot;); const stack: string[] = []; for (let str of arr) &#123; if (str == &quot;&quot;) &#123; continue; &#125; else if (str == &quot;.&quot;) &#123; continue; &#125; else if (str == &quot;..&quot;) &#123; stack.pop(); &#125; else &#123; stack.push(str); &#125; &#125; return `/$&#123;stack.join(&quot;/&quot;)&#125;`;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"浏览器登录态保存方案","slug":"浏览器登录态保存方案","date":"2020-11-18T09:19:44.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2020/11/18/浏览器登录态保存方案/","link":"","permalink":"http://yoursite.com/2020/11/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95%E6%80%81%E4%BF%9D%E5%AD%98%E6%96%B9%E6%A1%88/","excerpt":"","text":"什么是 Cookie Cookie 是由服务器发出，并由浏览器保存的一小块数据（大概 4kb 大小），浏览器再下一次请求同一个服务器时，会携带 cookie。 通过 cookie 可以使浏览器的访问变得有状态，但是由于数据只保存在浏览器中，因此状态是单向的，服务器无法验证。 什么是 session Session 是另一种记录服务器和浏览器会话状态的机制。Session 这种机制基于 Cookie 来实现 Session 的状态数据存储在服务器端，浏览器通过 Cookie 保存了一个 SessionId Session 认证流程 用户向服务器提交用户名和密码 服务器收到并验证成功后，生成一个 session（其实就是一段数据，比如包含 userId,userName 等）保存在内存或者数据库中 服务器返回给用户一个 session_id，写入用户的 cookie 用户后面的每一次访问，都会通过 Cookie 将 session_id 传回服务器 服务器收到 session_id 找到之前保存的数据，由此得知用户身份，继而执行操作 如果没有找到数据，则可以重定向至登陆页。 session 的问题 如果是一个服务器集群，就需要共享 session 数据 如果 AB 网站需要单点登录共享登录态，也需要共享 session 数据 什么是 JWT json web tokenJWT 是另一种保存状态的方案，和 Session 的区别是，JWT 只需要浏览器保存就可以了，服务器不需要在维护 session 数据。JWT 会在浏览器端保存哪些数据呢？其实还是类似 userId，userName 等数据。但是直接保存明文数据肯定是不行的，需要保存加密之后的数据。 将数据加密成一个字符串。中间用.分割成 3 部分。分别为 Header 头部一个对象，描述 JWT 的元数据，也就是这个 JWT 是什么格式呀，用了什么加密算法（HS256）呀。比如&#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot; &#125;这个对象使用 Base64URL 算法转换成字符串 Payload 负载（数据）也是一个对象保存各种数据。最后也是使用 Base64URL 算法转换成字符串 Signature 签名签名的作用主要是验证 Header 和 Payload，防止它们被篡改，服务器会保存 Signature 的密钥，使用密钥对 Header 和 Payload 进行 SHA256 加密。浏览器再次请求时，服务器通过密钥对 Header 和 Payload 解密，然后和 Signature 对比，验证数据是否被篡改。以及是否有效。 最终组成 Header.Payload.Signature这样的一个字符串，类似于 客户端收到 JWT 后，可以保存在 cookie 里面，也可以保存在 localStorage 里面。后面的请求时，可以随着 cookie 一起发送，但是会有跨域问题，所以也可以放在 Http 的 Header 里面。例如：Authorization: Bearer &lt;token&gt; JWT 的优点 相比于 Session，JWT 不需要服务器在维护 session 数据了，全部的数据都放在了浏览器上。 但是验证的时候需要做解密的操作，牺牲了一定的 CPU 性能。 JWT 的缺点 一旦签发了某个 Token，服务器无法作废它，因为服务器只会验证它，除非还有额外的逻辑来处理。 由于不好作废它，那么一旦 Token 被盗用，就会一直有效，因此 token 的有效期最好不要太长。 应该使用 Https，保证 token 的安全性","categories":[],"tags":[{"name":"web开发","slug":"web开发","permalink":"http://yoursite.com/tags/web%E5%BC%80%E5%8F%91/"}]},{"title":"leetcode 208 实现Trie树","slug":"leetcode-208-实现Trie树","date":"2020-11-15T11:35:35.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2020/11/15/leetcode-208-实现Trie树/","link":"","permalink":"http://yoursite.com/2020/11/15/leetcode-208-%E5%AE%9E%E7%8E%B0Trie%E6%A0%91/","excerpt":"","text":"208 实现前缀树前缀树其实就是字典树，实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。 示例示例: 1234567Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;); // 返回 truetrie.search(&quot;app&quot;); // 返回 falsetrie.startsWith(&quot;app&quot;); // 返回 truetrie.insert(&quot;app&quot;);trie.search(&quot;app&quot;); // 返回 true 问题分析这个数据结构直接看的极客时间上的课程学来的。但是使用数组来存储 children 的方式确实不错，主要字符集数量有限（26 个英文字母），如果是更大的字符集，使用 map 来存储也不错。 可以用来解决路由表的最长前缀匹配问题，可以使用 trie 树来加快搜索匹配的速度。 Round One trie 树主要支持两个操作 insert - 插入的过程，就是构建这个树的过程，需要动态的创建 children search - 搜索的过程，需要验证单词是否完全匹配，因此节点上需要一个 isEndOfWord 的标记 starsWith - 验证是否是一个合格的前缀，简化版的 search 代码实现children 是数组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class TrieNode &#123; char: string; isEndOfWord: boolean = false; children: TrieNode[] = []; constructor(char: string = &quot;&quot;) &#123; this.char = char; &#125;&#125;class Trie &#123; root: TrieNode; constructor() &#123; this.root = new TrieNode(); &#125; insert(word: string) &#123; let node = this.root; for (let char of word) &#123; const index = char.charCodeAt(0) - 97; if (!node.children[index]) &#123; // 当前字符不再children中，需要创建 node.children[index] = new TrieNode(char); &#125; node = node.children[index]; &#125; node.isEndOfWord = true; &#125; search(word: string) &#123; let node = this.root; for (let char of word) &#123; const index = char.charCodeAt(0) - 97; if (!node.children[index]) &#123; return false; &#125; node = node.children[index]; &#125; return node.isEndOfWord; &#125; startsWith(word: string) &#123; let node = this.root; for (let char of word) &#123; const index = char.charCodeAt(0) - 97; if (!node.children[index]) &#123; return false; &#125; node = node.children[index]; &#125; return true; &#125;&#125; children 是 mapmap 的方法在 leetcode 上更快，应该是因为数组方法里面 charCodeAt 比较耗时吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class TrieNode &#123; char: string; isEndOfWord: boolean = false; children: Map&lt;string,TrieNode&gt; = new Map() constructor(char:string = &#x27;&#x27;)&#123; this.char = char; &#125;&#125;class Trie &#123; root: TrieNode = new TrieNode(); insert(word: string)&#123; let node = this.root; for(let char of word)&#123; if(!node.children.has(char))&#123; node.children.set(char, new TrieNode(char)); &#125; node = node.children.get(char); &#125; node.isEndOfWord = true; &#125; search(word: string)&#123; let node = this.root; for(let char of word)&#123; if(!node.children.has(char))&#123; return false; &#125; node = node.children.get(char); &#125; retur node.isEndOfWord; &#125; startsWith(word: string)&#123; let node = this.root; for(let char of word)&#123; if(!node.children.has(char))&#123; return false; &#125; node = node.children.get(char); &#125; return true; &#125;&#125;","categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"leetcode 139 单词拆分","slug":"leetcode-139-单词拆分","date":"2020-11-15T11:34:51.000Z","updated":"2022-05-03T13:54:35.981Z","comments":true,"path":"2020/11/15/leetcode-139-单词拆分/","link":"","permalink":"http://yoursite.com/2020/11/15/leetcode-139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/","excerpt":"","text":"139 单词拆分示例 1：输入: s &#x3D; “leetcode”, wordDict &#x3D; [“leet”, “code”]输出: true解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。 问题分析Round One 遍历收集所有的 s 可以被拆分的组合 遍历组合，判断是否有某个组合中的所有子串都在 dict 中 这种解法看上去没有问题，关键点在于收集所有的 s 可以被拆分的组合，这里显然需要深度优先和递归。但是如何实现第 1 步，却把我卡住了。没有理清代码的关系。一直卡在了那里。这里暴露了我的一个问题，easy fall into a promble and can’t walk out.不知道是不是其他人也有会有这个问题呢？其实在问题卡住的时候，无非是两种做法。 死磕，把卡住的问题解决（这样也不能算是卡住了） 换一种思路，前提是能想到别的思路 综合上面的两个解决方案，不难发现，本质无非是你足够聪明（可以把卡住的问题解决掉），或是你见多识广（可以换一种方式解决问题）。无论哪一种，都是能力的体现。不得不说，是否聪明比较客观，无法改变，但是思路的转化是可以通过经验的积累来实现的。 Round Two在参考了 leetcode 上的 solutions 之后，获得了很大的启发。将问题分解，先找到一个，然后再对子问题求解，如果子问题也满足条件，那么这个组合就是 ok 的。 一个指针遍历字符串，验证指针前半子串 s1 是否在 dict 中，不存在就移动指针。 如果存在，那么说明已经分解出一个单词，然后对指针的后半子串 s2 进行同样的验证操作（递归）。 直到后半子串 s2 的长度为 0（递归基），说明前面的子串都可以在 dict 中找到了。 Round Three上面的解法基本解决了问题，但是存在很多重复计算。举个例子，一个字符串abcd，如过 a | bcd a | b | cd a | b | c | d a | bc | d a | b | c | d a | bcd ab | cd ab | c | d ab | cd 可以看出 c 和 d 的切分进行了很多次。对于重复的计算，简单的做法就是记录一下，这个子串是否已经切分过了。如果切分过了，就直接返回 代码实现非优化12345678910111213141516function wordBreak(s: stirng, dict: string[]): boolean &#123; if (s.length == 0) return true; for (let i = 0; i &lt; s.length; i++) &#123; // 将s分解。[0,i]为s1，[i+1,end]为s2 const s1 = s.slice(0, i + 1); const s2 = s.slice(i + 1); // 如果s1在dict中，再去验证s2 if (dict.inclueds(s1) &amp;&amp; wordBread(s2, dict)) &#123; // 找到了一组 return true; &#125; &#125; // 没找到 return false;&#125; 优化 - memo 记录12345678910111213141516171819202122232425function canBreak(str: string, dict: string[], memo: Set&lt;string&gt;) &#123; if (str.length === 0) return true; // 当前字符串已经尝试拆分过了，没有返回true，代表没有解 if (memo.has(str)) return false; for (let i = 0; i &lt; str.length; i++) &#123; const s1 = str.slice(0, i + 1); const s2 = str.slice(i + 1); if (dict.includes(s1) &amp;&amp; canBreak(s2, dict, memo)) &#123; return true; &#125; &#125; // 当前子串无法拆分 memo.add(str); return false;&#125;function wordBreak(s: string, dict: string[]) &#123; const memo = new Set&lt;string&gt;(); return canBreak(s, dict, memo);&#125; 优化 - dp 定义状态 dp[i]代表子串 s[0:i-1]是否可以被拆分。 dp[i] = dp[j] &amp;&amp; dict.has(s.slice(j,i)) j[0,i-1] 将 s[0:i-1]以 j 分为两部分，如果 dp[j]为 true，说明 s[0,j-1]可以拆分 如果 s[j:i-1]在 dict 中，则说明这两部分合起来也可以拆分(s[0:j-1],s[j,i-1]) 最终求的就是 dp[s.length]; 举个例子：s=leetcode; dict=[&#39;leet&#39;,&#39;code&#39;]; 那么dp[3]=true // 因为s[0,3]=&#39;leet&#39;; 而且s[4,7]=&#39;code&#39; 存在于dict中所以可以被拆分 1234567891011121314151617function wordBreak(s: string, dict: string[]): boolean &#123; const len = s.length; const dp = Array(s.length + 1).fill(false); dp[0] = true; for (let i = 1; i &lt;= len; i++) &#123; for (let j = i - 1; j &gt;= 0; j--) &#123; const suffix = s.slice(j, i); // 后缀 if (dp[j] &amp;&amp; dict.includes(suffix)) &#123; dp[i] = true; break; &#125; &#125; &#125; return dp[s.length];&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"leetcode 112 路径总和","slug":"leetcode-112-路径总和","date":"2020-11-15T11:30:23.000Z","updated":"2022-05-03T13:54:35.977Z","comments":true,"path":"2020/11/15/leetcode-112-路径总和/","link":"","permalink":"http://yoursite.com/2020/11/15/leetcode-112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/","excerpt":"","text":"112 路径总和示例给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum &#x3D; 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 问题分析Round One初看之下，让我想到了二叉树的最大深度，接着自然想到了 dfs 深度优先搜索，然后使用递归来实现代码。但是这里需要使用一个变量来记录当前路径和，然后想到了使用全局变量 count（事后证明这并不是一个最佳实践），如此一来，再全局变量增加之后，还需要利用回溯来恢复 count，无疑增加了复杂度。 Round Two其实对于类似的问题，之所以使用全局变量，是基于我的一个刻板印象–count 是值类型，不是引用类型，无法直接操作修改 count 的值。但是后来发现，并不需要直接修改 count 的值，只需要操作传递给下一层递归的 count 就可以了。相当于每一次的递归调用里 count 都是新的。 代码实现使用 dfs 递归最初想到的方案，使用 count 来记录当前的累加值。这里需要记住几种特殊 case 空树需要返回 false [1,2] 1 这个 case，虽然树根为 1，但是树根没有左子树，因此不符合题意（从根节点到叶子节点），因此也是返回 false 所以，真正的叶子节点就是本身不为 null，left 和 right 都是 null。 1234567891011121314function calcSum(node: TreeNode | null, sum: number, count: number): boolean &#123; if (!node) return false; count += node.val; if (!node.left &amp;&amp; !node.right) &#123; return count === sum; &#125; return calcSum(node.left, sum, count) || calcSum(node.right, sum, count);&#125;function hasPathSum(root: TreeNode | null, sum: number): boolean &#123; return calcSum(root, sum, 0);&#125; 使用 dfs 递归-优化传参看了 leetcode 的留言之后，发现了更好的方式，递减 sum，这样避免了一个多余的 count 参数。这种方式代码量更少，更加简洁。 123456789101112131415function hasPathSum(root: TreeNode | null, sum: number): boolean &#123; // 没有根节点，直接false if (!root) return false; // 已经是叶子节点 if (!root.left &amp;&amp; !root.right) &#123; return root.val === sum; &#125; // 探索左右子树 return ( hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val) );&#125; 使用 bfs使用 bfs 来遍历二叉树，自然要使用队列了。这里需要使用一个额外的队列来存储结果数据。并且数据队列与节点队列保持同步。 1234567891011121314151617181920212223242526function hasPathSum(root: TreeNode | null, sum: number): boolean &#123; if (!root) return false; const queue = [root]; // 遍历节点 const result = [root.val]; // 记录路径和 while (queue.length) &#123; const node = queue.pop(); const value = result.pop(); if (!node) continue; if (!node.left &amp;&amp; !node.right) &#123; if (sum === value) &#123; return true; &#125; &#125; if (node.left) &#123; queue.push(node.left); result.push((value as number) + node.left.val); &#125; if (node.right) &#123; queue.push(node.right); result.push((value as number) + node.right.val); &#125; &#125; return false;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"First Post","slug":"Post","date":"2020-07-28T22:34:55.000Z","updated":"2022-05-03T13:54:35.977Z","comments":true,"path":"2020/07/28/Post/","link":"","permalink":"http://yoursite.com/2020/07/28/Post/","excerpt":"","text":"这是我用 Hexo 写的第一篇 blog，之前的 Hello World 真的就是 Hello World 而已。之所以开通这个 blog，是因为在 B 站上看到了一个教学视频，感觉很有意思，总结一下这个 blog 的几个优点。 不需要自己的服务器，省钱呀。 构建简单，使用 MarkDown 编写。 之前很多的东西记录在印象笔记里，迁移到 blog 上可以被更多人看到（虽然可能只是一些浅显的理解） 这是第一篇 blog，万事开头难，不能再拖了，必须先交稿，不然怕我的拖延症犯了之后，把 blog 晾起来了。这篇就随便聊聊。 最近有了一些新的感悟，和朋友同事吃饭，总爱问他们平时休息都是做啥，有没有什么有意思的活动，因为总感觉自己的生活空洞无聊，想向别人讨些经验，然而得到的回答也大都差不多。然而我突然有一刻总结出了我理解的有意思(意义)的生活。 学习。锻炼大脑 运动。锻炼身体 体验。算是娱乐吧，寻找开心 另外就是健康舒适的身体真是太重要了，如果身体感到不适，那么是没有任何心情和精力去做其他事情的，只能闷头睡大觉，期待身体早日恢复。 随便写写。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]}],"categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"前端应用","slug":"前端应用","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/"},{"name":"奇奇怪怪的问题的解决方案","slug":"奇奇怪怪的问题的解决方案","permalink":"http://yoursite.com/tags/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"Iterm2","slug":"Iterm2","permalink":"http://yoursite.com/tags/Iterm2/"},{"name":"实用工具","slug":"实用工具","permalink":"http://yoursite.com/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"name":"iTerm2","slug":"iTerm2","permalink":"http://yoursite.com/tags/iTerm2/"},{"name":"API","slug":"API","permalink":"http://yoursite.com/tags/API/"},{"name":"RESTful","slug":"RESTful","permalink":"http://yoursite.com/tags/RESTful/"},{"name":"RPC","slug":"RPC","permalink":"http://yoursite.com/tags/RPC/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"sass","slug":"sass","permalink":"http://yoursite.com/tags/sass/"},{"name":"style guide","slug":"style-guide","permalink":"http://yoursite.com/tags/style-guide/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"vscode extension","slug":"vscode-extension","permalink":"http://yoursite.com/tags/vscode-extension/"},{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"前端开发中的算法","slug":"前端开发中的算法","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95/"},{"name":"英语学习","slug":"英语学习","permalink":"http://yoursite.com/tags/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"中间件","slug":"中间件","permalink":"http://yoursite.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"express","slug":"express","permalink":"http://yoursite.com/tags/express/"},{"name":"koa","slug":"koa","permalink":"http://yoursite.com/tags/koa/"},{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"},{"name":"web开发","slug":"web开发","permalink":"http://yoursite.com/tags/web%E5%BC%80%E5%8F%91/"}]}