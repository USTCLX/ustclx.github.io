{"meta":{"title":"herrycodelee blog","subtitle":"","description":"","author":"Xiang Li","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2021-04-05T18:46:54.000Z","updated":"2021-11-06T12:54:08.428Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"进阶中的 web 开发者 ｜ 热爱生活 ｜ 不断学习"},{"title":"书单","date":"2021-11-06T12:54:08.428Z","updated":"2021-11-06T12:54:08.428Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-11-06T12:54:08.428Z","updated":"2021-11-06T12:54:08.428Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-11-06T12:54:08.444Z","updated":"2021-11-06T12:54:08.444Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"vscode extension 开发debug时卡在building的原因和解决","slug":"vscode extension 开发debug时卡在building的原因和解决","date":"2021-11-06T12:28:36.000Z","updated":"2021-11-06T12:54:08.424Z","comments":true,"path":"2021/11/06/vscode extension 开发debug时卡在building的原因和解决/","link":"","permalink":"http://yoursite.com/2021/11/06/vscode%20extension%20%E5%BC%80%E5%8F%91debug%E6%97%B6%E5%8D%A1%E5%9C%A8building%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3/","excerpt":"","text":"背景最近在开发一款 vscode 插件，遇到了一个问题。特此记录。问题描述使用 vscode extension 官方的 cli 生成项目模版开始 debugger 开发，一切正常，按 F5 自动弹出一个新的 vscode升级项目中使用的 webpack 版本使用 debugger 开发，按 F5 不会在自动弹出新的 vscode，卡在了 build 阶段，如下图问题原因和解决在 google 了很久之后，总算确定了问题的原因 😳。vscode extension 在 debug 的 watch 模式下，会监听控制台 webpack 的输出。上图的截图，控制台中显示的家就是 webpack 的输出。然后在项目的 task.json 中的 endsPattern 字段，会去匹配这个输出的字符串，如果匹配上了，就认为构建 ok 了，然后弹出一个新的 vscode。问题的根据就在于升级 webpack 之后，webpack 的输出变了，因此需要重写一下。如下图。","categories":[],"tags":[{"name":"vscode extension","slug":"vscode-extension","permalink":"http://yoursite.com/tags/vscode-extension/"}]},{"title":"TrieTree在前端TreeSelect中的应用","slug":"TrieTree在前端TreeSelector中的应用","date":"2021-10-26T03:32:52.000Z","updated":"2021-11-06T12:54:08.424Z","comments":true,"path":"2021/10/26/TrieTree在前端TreeSelector中的应用/","link":"","permalink":"http://yoursite.com/2021/10/26/TrieTree%E5%9C%A8%E5%89%8D%E7%AB%AFTreeSelector%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"TreeSelectAntd 作为最有最优秀的 React 开源组件库之一，被广泛的使用。最近笔者在工作中使用TreeSelect组件。它的使用非常简单，可以接收下面这样的数据结构，来生成一个树型选择器。1234567891011121314151617181920const treeData = [ &#123; title: \"Node1\", value: \"0-0\", children: [ &#123; title: \"Child Node1\", value: \"0-0-1\", &#125;, &#123; title: \"Child Node2\", value: \"0-0-2\", &#125;, ], &#125;, &#123; title: \"Node2\", value: \"0-1\", &#125;,];场景比如后端吐出给前端的数据如下。1const rawData = [\"a.bb\", \"a.cc\", \"a.dd.eee\", \"h.ff.llll\"];要求根据.作为分层级隔符，将数据展示为树形选择器。因此需要将数据转为如下形式。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const treeData = [ &#123; title: \"*\", value: \"*\", children: [ &#123; title: \"a\", value: \"a.*\", children: [ &#123; title: \"bb\", value: \"a.bb\", &#125;, &#123; title: \"cc\", value: \"a.cc\", &#125;, &#123; title: \"dd\", value: \"a.dd.*\", children: [ &#123; title: \"eee\", value: \"a.dd.eee\", &#125;, ], &#125;, ], &#125;, &#123; title: \"h\", value: \"h.*\", children: [ &#123; title: \"ff\", value: \"h.ff.*\", children: [ &#123; title: \"llll\", value: \"h.ff.llll\", &#125;, ], &#125;, ], &#125;, ], &#125;,];前缀树（字典树）关于前缀树的文章可以参考leetcode 208 实现 Trie 树。这种 case，根据共同的前缀，层层递进形成的数据结构，正是前缀树的应用场景了。那么我们如何将rawData 转换为treeData呢？笔者给了一个自己实现，如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677interface TreeData &#123; title: string; value: string; children?: TreeData[];&#125;export class TrieNode &#123; constructor( public value: string = \"\", public path: string = \"\", public isLeaf: boolean = false, public isRoot: boolean = false, public children: TrieNode[] ) &#123;&#125;&#125;export class TrieTree &#123; root: TrieNode; constructor(data: string[] = []) &#123; this.root = new TrieNode(\"*\", \"\", false, true, []); data.forEach((item) =&gt; &#123; this.insert(item.split(\".\")); &#125;); &#125; findNode(node: TrieNode, key: string) &#123; if (!key) return null; if (!node || !node.children?.length) return null; return node.children.find((child) =&gt; child.value === key); &#125; insert(keys: string[]) &#123; let node = this.root; const paths = []; for (const key of keys) &#123; paths.push(key); let child = this.findNode(node, key); if (!child) &#123; child = new TrieNode(key, paths.join(\".\"), false, false, []); node.children.push(child); &#125; node = child; &#125; node.isLeaf = true; &#125; getValue() &#123; const treeData: TreeData[] = []; const dfs = (node: TrieNode, treeData: TreeData[]) =&gt; &#123; if (!node) return; const data: TreeData = &#123; title: node.value, value: node.isRoot ? node.value : node.isLeaf ? node.path : node.path + \".*\", &#125;; if (node.children?.length) data.children = []; treeData.push(data); for (const child of node.children) &#123; dfs(child, data.children); &#125; &#125;; dfs(this.root, treeData); return treeData; &#125;&#125;结合 Antd 来使用codesandbox","categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"前端开发中的算法","slug":"前端开发中的算法","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95/"}]},{"title":"英语语法整理","slug":"英语语法整理","date":"2021-10-24T12:12:14.000Z","updated":"2021-11-06T12:54:08.428Z","comments":true,"path":"2021/10/24/英语语法整理/","link":"","permalink":"http://yoursite.com/2021/10/24/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86/","excerpt":"","text":"简单句语法一般英语句子的结构，可以总结为主语+谓语+（东西）。主语：人或者物品谓语：动作主语+谓语I swimswim 是不及物动词主语+谓语+宾语I like herlike 是及物动词主语+谓语+间接宾语+直接宾语 (双宾)谓语后面跟着两个动作的承受者。Dabai teaches you English主语+谓语+宾语+宾语补充谓语后面跟着一个动作的承受者和他的补充说明。Dabai makes you happy主语+系动词+表语Dabai is smart三种起修饰成分的句子结构定语，定语是广义的形容词The cute boy speaks EnglishThe boy in red speaks EnglishThe boy when I played withe speaks English;状语，状语是广义的副词副词是用来修饰形容词和动词的词。Dabai answered quicklyDabai answerd in English同位语，把主语换个说法再说一遍Shabai’s brother,BigShaBai,is a teacherWe Chinese People are hardworking复杂句并列关系的复合句I washed my hands, and I ate breakfast嵌套关系的复杂句The boy said that he was very hungryThe boy who was crying said when I spoke to him that he was very hungry because he had had no food for two days词类名词，可数+不可数代词，you I she he it形容词，happy副词，quickly动词，run数次，one two冠词，the a this介词，in at on连词，and but叹词，oh oops shit","categories":[],"tags":[{"name":"英语学习","slug":"英语学习","permalink":"http://yoursite.com/tags/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"}]},{"title":"如何克服精神内耗","slug":"如何克服精神内耗","date":"2021-10-24T11:39:28.000Z","updated":"2021-11-06T12:54:08.424Z","comments":true,"path":"2021/10/24/如何克服精神内耗/","link":"","permalink":"http://yoursite.com/2021/10/24/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E7%B2%BE%E7%A5%9E%E5%86%85%E8%80%97/","excerpt":"","text":"精神内耗今天再次阅读精神内耗这篇知乎文章以及他的姐妹篇高效管理时间的秘诀，在于这三个清单。理想的精神状态理想的精神状态应该是，可以全神贯注的专注在你当前正在做的事情上，不论是学习，工作，思考，还是娱乐。我的精神状态但是目前的我是做不到的，脑袋中存在着各种各样的纠结，推演各种各样的情况，处理各种各样的信息。导致我总是精神不振，每天精神都不充沛和兴奋。这种情况导致的结果就是，我的大脑无时无刻都在处理信息，有事甚至是不同的信息，比如我在写这篇文章的时候，就想到了还要写一篇关于头油的文章。强制转换注意力，导致注意力不集中。这里面的大量信息是无用的，空耗我大脑的 CPU 资源。而想法多的另一个坏处是，导致想的多，做的少，比如我想学习 flutter，我想买个瑜伽垫健身，我想读《编码》这本书，我想读完我微信收藏的文章，我想看完我极客时间的课程（那个想了很久的网络协议课程），都还只停留在想想的阶段。（这个问题也许可以通过指定合理的 todo 清单来解决）真的非常痛苦 😖。过度思虑（精神内耗），为什么会有精神内耗我的状态有个专业名词来描述，就是过度思虑，也就是通俗的精神内耗。为什么会有这种情况呢？有以下几个原因过度活跃的 DMNDMN 就是 Default Mode Network，默认模式网络。它是把大脑后台零碎的信息进行梳理，把可能被遗忘的重新进行激活。哪怕什么都不做，大脑也有大约 20%的耗能任务在执行。TPN，Task Positive Network 专注网络。优势长时记忆能力、想象力、创造力更好一些。DMN 涉及的脑部区域和负责自我与他人以及情感判断的网络所涉及的部分，是高度重叠的。因此更容易考虑别人的感受，以及注意到不好的地方。也就是有更好的共情能力。劣势DMN 过度的活跃，会在我专注工作时，和争夺大脑的 CPU 资源，导致无法持续专注。（这点我感觉我还挺明显的，比如刚才我就突然想到了 Grab 上的麦当劳是不是可以 pick up，然后打开手机看了一下）当 DMN 不受 TPN 的钳制时，会更加放飞自我，把很多负面的情绪和想法输送到意识里。由威胁识别带来的恐惧威胁识别。我们的大脑在加工各种信息时，有一个功能，叫做威胁识别，它往往会夸大和凸显一个事物中的威胁的细节，忽视安全的细节，从而看不清事物的全貌，继而导致我去逃避该事物。优势自我保护劣势让我们害怕去做一些事，比如我总是不敢探寻新的餐厅，担心里面价格很贵，买到很坑的东西，亦或是担心不卫生。大脑还有一种机制叫做“延伸记忆”，也就是我过去付出行动、获得成功、获得经验的经历，比如我鼓起勇气成功探寻了某个餐厅，某个景点，某个理发店，我就会发现它没什么大不了，它就会成为我下次做决定的一个选项。比如我在平时不敢说话的群里面，问了一个问题，我后面就不会再认为在这个群里问问题会有什么困难。当大脑进行”威胁识别“时，会使用”延伸记忆“里面的信息，来进行对抗和抵消。形成精神内耗我遇到问题，决定先审视一下再说这种“审视一下”，导致我过度夸大了它的威胁，从而形成恐惧这种恐惧使我的行动的意向进一步被削弱，我需要更多的精力跟它对抗，才能采取行动，于是造成了拖延而大多数问题在拖延之下，会变得越来越糟，最终逼我不得不去行动，于是我会感觉“做出了一个错误的决定”久而久之，这种感觉就会加重我的自我怀疑，削弱我的自信，而从削弱我的“延伸记忆”，使得我更没有办法对抗恐惧。。。最终，我的幸福感会下降。结论过度的精神内耗，会让我自我怀疑，缺乏自我的价值感和意义感觉。并且肯定会让我的幸福感降低，觉得很多事情没有意思，失去了生活的激情，我现在基本就有这种感觉，很多事情提不起兴趣。当我专注时，更容易获得“绞尽脑汁”解决问题的快感。当我被 DMN 主宰时，我会分心，无法专注，因此也无法获得“绞尽脑汁”的快感，反而还会想起负面、不快乐的事情。精神内耗会消耗精力降低行动力降低幸福感克服精神内耗掌控自己的想法这个方法其实很困难，想法如果可以轻易被我掌控，那也就不会有那么多问题了。如何掌控，可以试试以下几种形式当我产生负面情绪，或者乱七八糟的想法时，对它说：我知道了，退下吧，我会等有空的时候处理。用一个笔记本来记录我的负面的想法。产生负面想法时，先记下来，然后就不要想了（这一步很难）定期查看笔记本中的负面想法，问自己他是真实的吗？他发生的可能性大吗？我有没有方法可以应对它？一旦把这三个问题想清楚，就划掉他上面的做法，可以强化我的“主动性”，让我感受到，我是可以掌控我的想法的，我有能力那么做。锻炼专注和感知能力DMN 就是在我的大脑空闲时的信马由缰，因此如果我可以把大脑专注在某件事上，我就能降低 DMN 的活跃性。有以下两个方法可以帮我提高专注力。我需要把他们加到我的小习惯里面。冥想/正念。这个方法在《自控力》这本书中也提到过，看来方法的有效性形成了共识。找一个舒适的位置，闭上眼睛，采取 10s 左右的呼吸，把注意力放在呼吸上面，体会呼吸的过程，不要去管脑海中来来回回的想法，也不要抑制它。持续 10 ～ 15 分钟。停下手头的事，找个舒适的位置，先深呼吸一到两次，然后按顺序问自己我看到了什么听到了什么嗅到了什么手和脚触碰到了什么感觉是怎样的或者闭上眼睛，依靠感官走几步，专注感受感官传来的信息。注意力转换和饱和我工作的时候为什么会分心呢？就是因为当前的事情无法百分之百的吸引我的兴趣了，使我的注意力“不饱和”，然后产生了闲置资源，发生 DMN。一个解决方法是分段工作模式，就是把同时打开多个项目（事情），项目一工作一段时间，转换到项目二，然后项目三，以此类推。这样的好处是，在同一个任务长时间之行后，开始无法集中注意力，大脑产生闲置，这时为了不让闲置的大脑专向 DMN，于是开启项目二来吸引我的注意力和大脑资源。也就是说，我们无力控制自己分心，但是我们可以把分心引导到一个更有意义，更符合我们需求的方向。可以结合后文的 Todo 清单来实践。把行动变成默认模式如果一件事，我想不到特别有力的不去做的原因，那么，优先选择去做。应该把这句话当成一个信条，指导我生活中的行动。这些不确定的事情，因为害怕麻烦，权衡得失等原因，如果不得到解决，会一残留在我的记忆里，随着 DMN 的激活而挤占我的认知资源。只有去行动了，才能把未知变成已知，把不确定变成确定，让它们得到安置，不再干扰我的思考。另外，行动也会带给我正向的反馈。我所恐惧的东西，其实没有那么可怕，我对他的猜测，担忧和焦虑，很多都是不必要的。高效管理时间为了合理的安排自己的时间和需要做的事情，我之前制定了 Todo List，但是我之前制定的 Todo List，虽然看上去分门别类，但是最后执行力不行，很多都成了摆设，应该是失败了 😂。因此决定学习“L 先生说” 公众号里推荐的 Todo List 管理方案。拖延症为啥我有拖延的毛病呢？一个可能的原因来自“认知负担”，它让我产生了这么一个潜意识“这是一个复杂的任务，我没法立刻开工，我需要先理清思路”。比如我很早就计划了上 b 站搜索健身教程，并尝试在家里做简单的运动，但是却一直没有开始 😂。实际上，我的大脑逻辑非常简单，他倾向于去做简单的，不需要太多思考的事情，而排斥复杂的，需要大量投入的事情。这就为我们制定 Todo List 提供了一种指导。AFD TodoList“L 先生说”实行的是名叫 AFD 的方法，也就是 Action、Focused、DessertAction 执行清单执行清单，就是自己计划需要完成的，但是这里不能简单的罗列，需要把粒度尽量的变小。比如“到超市买苹果”，就是一个非常明确简单的行动，不需要思考，它所占用的认知资源非常少。再比如“完成 Policy 改版”，就不行，颗粒度太大，并不是一步可以完成的，这样的 todo 很容易产生迷惑我做到了哪里我的思路是什么我还需要做些什么这些就会带给我认知负担。因此需要对这样的 item，做详细的分解。明确需要做什么，而且越具体，行动起来越容易，比如数量、目的、关键词等等。这样当我看到任务的时候，可以毫不犹豫的去执行，不会产生拖延情绪。但是话说回来，能够把任务拆的细，也是需要时间精力的，但是这种应该是值得的。Focused 聚焦清单“休息”并不一定是要睡个觉。对于体力劳动，睡觉时最好的休息方式，可以让肌肉得到放松。但是对于脑力劳动，却不是这样。大脑处理不同的任务，使用的是不同的区域，当长时间执行一个任务时，大脑的耗能和平时其实不会差太多，但是对他的“新鲜感”会降低很多，这种“新鲜感”的降低，是我们脑力劳动疲劳的主要原因，有时我会觉得自己困了，其实是长时间思考同样的内容，会抑制大脑的活动，让人感到厌倦、昏昏欲睡无法集中注意力。因此脑力疲惫更好的方式时，调整聚焦点，切换到不同的工作上，激活大脑的另一个区域。因此这个清单中，可以存放两类东西重要的亟待解决的问题正在研读和学习的书籍等每当工作累了，就可以站起来走走，喝点东西，散步，然后再脑袋里思考这些问题。比如：今晚吃什么需要买些什么东西了调研一下周末去哪里玩或者打开没有阅读完的书籍，阅读一会儿。等到这个清单的里的事情疲惫了，就可以去接着做之前的事情了。Dessert 成就感清单如果是在觉得厌烦、无聊，提不起精神，不想动脑子，无论是 Action、还是 Focused 里面的事情，都不想干，这就是精神低谷的时候，就可以准备一个“Dessert”清单，里面放一些非常简单，无需动脑、没有时间限制的小事，比如整理书桌整理电脑文件夹下载资源这样可以积累成就感，帮助我的精神状态回归。通过在做完 2-3 项 Dessert 之后，状态应该可以回归。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"整理英语学习资源","slug":"整理英语学习资源","date":"2021-10-23T04:20:18.000Z","updated":"2021-11-06T12:54:08.428Z","comments":true,"path":"2021/10/23/整理英语学习资源/","link":"","permalink":"http://yoursite.com/2021/10/23/%E6%95%B4%E7%90%86%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/","excerpt":"","text":"资源整理目前收集了很多的英语学习资源，在国内的时候更多的是单纯的学习，而来到新加坡后有了很多的实战场景，除了日常的积累外，还是需要一些系统性的学些 lah！🤪方法论English leval up tips for chineseAPP开言英语英语流利说视频五分钟英语基础语法外教 Gill 英语精品课说一口流利标准英语English with LucyB 站 UP 主Youtobe 口语精选Youtobe 英语精选Youtobe 听力精选Bigshot 英语YoutobeEnglish with LucySpeak English With Vanessa公众号英语资源学习中心Podcast潘吉 JENNY 告诉你ALL EARS ENGLISH英文小酒馆 LHH一席英语6 Minute English计划某次偶然的机会听到了潘吉 JENNY 告诉你这款播客，感觉这种中英对话聊天的形式很有意思，每期一个话题，除了学习英语，还可以知道一些有趣的事情。继而开始使用他们公司开发的开言英语App，使用了外交视频课，感觉还不错，根据具体的场景来学习英语。其他资源自然是屯起来才有安全感 lah！还都没开始看 🤪。播客打算额外选择一个一席英语，再从视频里选择说一口流利标准英语把它办了 💪！","categories":[],"tags":[{"name":"英语学习","slug":"英语学习","permalink":"http://yoursite.com/tags/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"}]},{"title":"算法资源整理","slug":"整理算法资源","date":"2021-10-20T11:18:43.000Z","updated":"2021-11-06T12:54:08.428Z","comments":true,"path":"2021/10/20/整理算法资源/","link":"","permalink":"http://yoursite.com/2021/10/20/%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%E8%B5%84%E6%BA%90/","excerpt":"","text":"最近打算再一次系统的学习数据结构与算法，并再次开始有节奏的刷 leetcode。功在平时，有备无患，在还没有熟练掌握之前，学习数据结构与算法和刷题必然是一个长期的过程。资源整理目前手头上掌握的资源挺多，可真正耐下心看完的没有几个。很多都是看到之后，随手就丢进了收藏夹里吃灰（众所周知，收藏就等于学会了 🤪）。在线书籍labuladong 算法小抄瓶子君的算法小书程序厨的动画算法leetcode cookbook极客时间算法面试通过 40 讲数据结构与算法之美常用算法 25 讲视频百度云-算法训练营代码随想录清华大学数据结构精品课-邓俊辉左程云 LeetCode 刷题笔记githubLeetCode 题目分类与面试问题整理Fucking Algorithm(同 labuladong 算法小抄)LeetCode ClassifyAwesome CS BooksCoding Interview UniversityLeetCode AnimationLeetCode 全解书籍剑指 offer编程之美挑选资料整理了好多，但是之前没有系统的钻研过。除了面试前看的《算法面试通关 40 讲》和《数据结构与算法之美》,前者属于视频类，后者属于小册类。资料太多，不可能一次全部搞完，没有计划，很容易他们就集体吃灰了，还是需要逐个击破。这次决定从众多资料中，挑出两个，一个文字阅读类，一个视频类，互为补充的来学习。labuladong 算法小抄百度云-算法训练营计划从 labuladong 算法小抄中，从头到尾，按照专题，每两天做一道题目，如果遇到简单的做过的，就顺势做到下一题。遇到复杂的概念和困难的题目，可以结合算法训练营视频来消化。2021/10/20 星期三反馈这里等待反馈，如果 labuladong 算法小抄过了一遍，再来这篇 blog 记录下成功的时间。未完待续。。。","categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"Mac 安装和启动MySQL数据库","slug":"Mac-安装和启动MySQL数据库","date":"2021-10-19T11:05:29.000Z","updated":"2021-11-06T12:54:08.424Z","comments":true,"path":"2021/10/19/Mac-安装和启动MySQL数据库/","link":"","permalink":"http://yoursite.com/2021/10/19/Mac-%E5%AE%89%E8%A3%85%E5%92%8C%E5%90%AF%E5%8A%A8MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"最近在学习 NestJS 框架，需要使用 MySQL 数据库来配合完成一些功能，以前只使用过 MongoDB，第一次使用 MySQL，在安装和使用时踩了一些坑，记录下来。下载MySQL 分为商业版和社区版，社区版我理解就是开源免费的。但是在官网想要找到下载入口比较费劲，个人感觉不是清晰。下载社区版可以直接使用下面这个链接。MySQL Community Download安装下载完成后，直接双击 dmg 文件进行安装。安装过程中需要输入输入 root 的密码，这里需要记下来。后面链接数据库的时候需要使用。启动为了启动 MySQL 我走了不少弯路，一开始使用命令行来启动，结果很麻烦，也没有成功启动。后来发现其实 MySQL 很人性化，它会在 System Perference 里面生成一个图标，点击图标后就可进行一些基本操作，包括startstopinitialize连接数据库建议直接使用图形化界面来操作，使用命令行太麻烦了。图形化界面有两个选择一个是收费的Navicat，一个是开源免费的Sequel Pro。笔者一开始试用过Navicat，确实非常好用，鉴于平时需求不是很大，所以暂时没有打算付费使用。于是选择了Sequel Pro。在使用Sequel Pro的过程中遇到了一些问题。最开始下载的是v1.1.2正式版，但是使用过程中无法连接数据库，还总是闪退。尝试重装也没有解决。搜索后发现很多人都遇到了这个问题。解决方案是下载test build版本。可以完美解决。下载地址: Sequel Pro test build如此依赖就可以快乐的使用 MySQL 数据库了。","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"使用React设计一个Form表单组件","slug":"使用React设计一个Form表单组件","date":"2021-07-18T17:18:44.000Z","updated":"2021-11-06T12:54:08.424Z","comments":true,"path":"2021/07/18/使用React设计一个Form表单组件/","link":"","permalink":"http://yoursite.com/2021/07/18/%E4%BD%BF%E7%94%A8React%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AAForm%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6/","excerpt":"","text":"通过设计一个 Form 组件，学习 React 中，React.Children.forEach 和 React.CloneElement 以及 React.isValidElement 这三个 API 的用法。组件 API 设计组件用法如下1234567891011121314151617181920212223242526272829303132import &#123; useRef &#125; from \"react\";import &#123; Form, FormItem, Input &#125; from \"./Form\";export default function App() &#123; const form = useRef(); const onSubmit = () =&gt; &#123; form.current.submit((data) =&gt; &#123; console.log(\"data\", data); &#125;); &#125;; const onReset = () =&gt; &#123; form.current.reset(); &#125;; return ( &lt;div className=\"App\"&gt; &lt;Form ref=&#123;form&#125;&gt; &lt;FormItem name=\"name\" label=\"姓名\"&gt; &lt;Input /&gt; &lt;/FormItem&gt; &lt;FormItem name=\"age\" label=\"年龄\"&gt; &lt;Input /&gt; &lt;/FormItem&gt; &lt;FormItem name=\"sex\" label=\"性别\"&gt; &lt;Input /&gt; &lt;/FormItem&gt; &lt;/Form&gt; &lt;button onClick=&#123;onSubmit&#125;&gt;提交&lt;/button&gt; &lt;button onClick=&#123;onReset&#125;&gt;重置&lt;/button&gt; &lt;/div&gt; );&#125;组件实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import React from \"react\";export class Form extends React.Component &#123; state = &#123; formData: &#123;&#125;, &#125;; submit = (cb) =&gt; &#123; cb &amp;&amp; cb(&#123; ...this.state.formData &#125;); &#125;; reset = () =&gt; &#123; const &#123; formData &#125; = this.state; Object.keys(formData).forEach((key) =&gt; &#123; formData[key] = \"\"; &#125;); this.setState(&#123; formData &#125;); &#125;; setValue = (name, value) =&gt; &#123; const &#123; formData &#125; = this.state; formData[name] = value; this.setState(&#123; formData &#125;); &#125;; render() &#123; const &#123; children &#125; = this.props; const &#123; formData &#125; = this.state; const renderChildren = []; React.Children.forEach(children, (child) =&gt; &#123; if (child.type.displayName === \"FormItem\") &#123; const &#123; name &#125; = child.props; renderChildren.push( React.cloneElement( child, &#123; key: name, value: formData[name] || \"\", handleChange: this.setValue, &#125;, child.props.children ) ); &#125; &#125;); return renderChildren; &#125;&#125;export class FormItem extends React.Component &#123; static displayName = \"FormItem\"; onChange = (value) =&gt; &#123; const &#123; name, handleChange &#125; = this.props; handleChange &amp;&amp; handleChange(name, value); &#125;; render() &#123; const &#123; label, value, children &#125; = this.props; return ( &lt;div&gt; &lt;span&gt;&#123;label&#125;&lt;/span&gt; &#123;React.isValidElement(children) &amp;&amp; children.type.displayName === \"FormItem-Input\" ? React.cloneElement(children, &#123; onChange: this.onChange, value &#125;) : null&#125; &lt;/div&gt; ); &#125;&#125;export class Input extends React.Component &#123; static displayName = \"FormItem-Input\"; render() &#123; const &#123; value, onChange &#125; = this.props; return ( &lt;input value=&#123;value&#125; onChange=&#123;(e) =&gt; &#123; onChange &amp;&amp; onChange(e.target.value); &#125;&#125; /&gt; ); &#125;&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"数组排序系列","slug":"数组排序系列","date":"2021-04-18T15:52:57.000Z","updated":"2021-11-06T12:54:08.428Z","comments":true,"path":"2021/04/18/数组排序系列/","link":"","permalink":"http://yoursite.com/2021/04/18/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%B3%BB%E5%88%97/","excerpt":"","text":"数组的排序应该是基本中的基本了。\b 冒泡排序冒泡排序的思想是，通过一次遍历，通过比较，将一个最大的元素，调整到数组的末尾，进行 n 次之后，数组就有序了。因此时间复杂度是 O(n^2)12345678910function sortArray(nums: number[]): number[] &#123; for (let i = 0; i &lt; nums.length; i++) &#123; for (let j = 0; j &lt; nums.length - i; j++) &#123; if (nums[j] &gt; nums[j + 1]) &#123; swap(nums, j, j + 1); &#125; &#125; &#125; return nums;&#125;插入排序插入排序的思想是，将数组分成两部分，左半部分是有序的，右半部分是无序的，每次从右半部分取出第一个元素，插入到左半部分。插入的过程是，把待插入元素和左半部分的元素比较，如果小于就交换，如果大于等于就停止。12345678910111213function sortArray(nums: number[]): number[] &#123; // nums[i] 是待插入的元素 for (let i = 0; i &lt; nums.length; i++) &#123; for (let j = i; j &gt; 0; j--) &#123; if (nums[j] &lt; nums[j - 1]) &#123; swap(nums, j - 1, j); &#125; else &#123; break; &#125; &#125; &#125; return nums;&#125;快速排序快速排序的思想是，每次将数组分为左右两部分，左半部分的所有值都小于右半部分，然后对左右部分再进行这样的操作。最终整个数组有序。12345678910111213141516171819202122232425262728293031function partition(nums: number[], left: number, right: number): number &#123; if (left &gt;= right) return right; const pvoit = nums[left]; const start = left; left = left + 1; while (left &lt;= right) &#123; if (nums[left] &gt; pvoit &amp;&amp; nums[right] &lt; pvoit) &#123; swap(nums, left++, right--); &#125; else if (nums[left] &lt;= pvoit) &#123; left++; &#125; else &#123; right--; &#125; &#125; swap(nums, start, right); return right;&#125;function quickSort(nums: number[], left: number, right: number): number[] &#123; if (left &gt;= right) return nums; const p = partition(nums, left, right); quickSort(nums, left, p - 1); quickSort(nums, p + 1, right); return nums;&#125;function sortArray(nums: number[]): number[] &#123; return quickSort(nums, 0, nums.length - 1);&#125;","categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"前缀和系列","slug":"前缀和系列","date":"2021-04-17T10:44:29.000Z","updated":"2021-11-06T12:54:08.424Z","comments":true,"path":"2021/04/17/前缀和系列/","link":"","permalink":"http://yoursite.com/2021/04/17/%E5%89%8D%E7%BC%80%E5%92%8C%E7%B3%BB%E5%88%97/","excerpt":"","text":"前缀和前缀和，简单说就是数组的前 n 项的和。不过需要注意，在代码里面，presum[i] 代表前 i 项的和，也就是 nums[0]~nums[i-1]的和。比如 presum[2] = nums[0] + nums[1]。通过前缀和的思想和 map，可以优化很多问题解法。同时前缀和不一定真的就是前缀的和，也可以是前缀中奇数数字的个数等。总之就前缀的一个统计信息，可以是和，也可以是其他。123456function presum(nums: number): number[] &#123; let presum = [0]; for (let i = 0; i &lt; nums.length; i++) &#123; presum[i + 1] = presum[i] + nums[i]; &#125;&#125;724. 寻找数组的中心下标给你一个整数数组 nums，请编写一个能够返回数组 “中心下标” 的方法。数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。如果数组不存在中心下标，返回 -1 。如果数组有多个中心下标，应该返回最靠近左边的那一个。1234567891011121314151617181920// 先求出总和// 遍历求出左边的和，然后用总和减去左边的和以及当前值，就是右边的和// 判断左右的和是否相等function pivotIndex(nums: number[]): number &#123; let presum = 0; for (let i = 0; i &lt; nums.length; i++) &#123; presum += nums[i]; &#125; let leftsum = 0; let rightsum = 0; for (let i = 0; i &lt; nums.length; i++) &#123; rightsum = presum - leftsum - nums[i]; if (leftsum === rightsum) &#123; return i; &#125; leftsum += nums[i]; &#125; return -1;&#125;1. 两数之和给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。12345678910111213// 使用一个map，记录已经访问过的值// 遍历数组，判断map中是否已经存在一个值，和当前值相加的和是target// 如果不是，就把当前值加入到map中function twoSum(nums: number[], target: number): number[] &#123; const map = new Map(); for (let i = 0; i &lt; nums.length; i++) &#123; if (map.has(target - nums[i])) &#123; return [map.get(target - nums[i]), i]; &#125; map.set(nums[i], i); &#125; return [];&#125;560. 和为 K 的子数组给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。示例 1 : 输入:nums = [1,1,1], k = 2; 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况12345678910111213141516171819202122232425262728293031323334// 暴力法，求出了所有子数组的和// 有可能会超时function subarraySum(nums: number[], k: number): number &#123; let sum = 0; let cnt = 0; for (let i = 0; i &lt; nums.length; i++) &#123; sum = 0; for (let j = i; j &lt; nums.length; j++) &#123; sum += nums[j]; if (sum === k) &#123; cnt++; &#125; &#125; &#125; return cnt;&#125;// 与两数之和类似，使用map节省时间// map 中记录前缀和，以及该前缀和出现的次数function subarraySum(nums: number[], k: number): number &#123; let presum = 0; let cnt = 0; const map = new Map(); map.set(0, 1); for (let i = 0; i &lt; nums.length; i++) &#123; presum += nums[i]; if (map.has(presum - k)) &#123; cnt += map.get(presum - k); &#125; const curVal = map.has(presum) ? map.get(presum) : 0; map.set(presum, curVal + 1); &#125; return cnt;&#125;1248. 统计优美子数组给你一个整数数组 nums 和一个整数 k。如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。请返回这个数组中「优美子数组」的数目。1234567891011121314151617181920212223242526272829303132333435363738// 使用位运算判断数字的奇偶性function isOdd(num: number): boolean &#123; return (num &amp; 1) === 1;&#125;// 暴力法，遍历所有的子数组，计算子数组奇数的个数，判断个数是否为kfunction numberOfSubarrays(nums: number[], k: number): number &#123; let cnt = 0; let oddCnt = 0; for (let i = 0; i &lt; nums.length; i++) &#123; oddCnt = 0; for (let j = i; j &lt; nums.length; j++) &#123; if (isOdd(nums[j])) oddCnt++; if (oddCnt === k) cnt++; &#125; &#125; return cnt;&#125;// presum 记录的是当前前缀中的奇数的个数// map记录前缀中奇数个数，以及该种case出现的次数// 比如map(5,2) 代表，该前缀中有5个奇数，它出现了2次function numberOfSubarrays(nums: number[], k: number): number &#123; let cnt = 0; let presum = 0; const map = new Map(); map.set(0, 1); for (let i = 0; i &lt; nums.length; i++) &#123; presum += isOdd(nums[i]) ? 1 : 0; if (map.has(presum - k)) &#123; cnt += map.get(presum - k); &#125; const curVal = map.has(presum) ? map.get(presum) : 0; map.set(presum, curVal + 1); &#125; return cnt;&#125;974. 和可被 K 整除的子数组给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。这里的 k 大于 2数组 A 中有负数。12345678910111213141516171819202122232425262728293031323334353637383940// 暴力法// 求出所有子数组的和，验证是否可以被K整除// 超时了function subarraysDivByK(A: number[], K: number): number &#123; let cnt = 0; let sum = 0; for (let i = 0; i &lt; A.length; i++) &#123; sum = 0; for (let j = i; j &lt; A.length; j++) &#123; sum += A[j]; if (sum % K === 0) &#123; cnt++; &#125; &#125; &#125; return cnt;&#125;// presum 还是前缀和// map记录前缀和对K的余数，以及次数// (presum[i]-presum[j]) % K = 0 --&gt; presum[i] % K = presum[j] % Kfunction subarraysDivByK(A: number[], K: number): number &#123; let cnt = 0; let presum = 0; let remainder = 0; // 余数 const map = new Map(); // map记录前缀和对K的余数，以及次数 map.set(0, 1); for (let i = 0; i &lt; A.length; i++) &#123; presum += A[i]; // 这里需要把负数的余数转成正数 remainder = ((presum % K) + K) % K; if (map.has(remainder)) &#123; cnt += map.get(remainder); &#125; const curVal = map.has(remainder) ? map.get(remainder) : 0; map.set(remainder, curVal + 1); &#125; return cnt;&#125;523. 连续的子数组和给定一个包含 非负数 的数组和一个目标 整数 k ，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，且总和为 k 的倍数，即总和为 n * k ，其中 n 也是一个整数。k 是整数，可能为 0子数组长度至少为 2返回 bool 值，判断这个值是否存在12345678910111213141516171819202122// map的key为余数，val不再是余数出现的次数，而是该余数最早出现的位置// 通过这个位置来判断，子树组长度是否大于等于2// k为0的时候，余数就是presum本身，也就变成了是否有两个前缀和是相等的。function checkSubarraySum(nums: number[], k: number): boolean &#123; let presum = 0; let remainder = 0; const map = new Map(); map.set(0, -1); for (let i = 0; i &lt; nums.length; i++) &#123; presum += nums[i]; remainder = k === 0 ? presum : ((presum % k) + k) % k; if (map.has(remainder)) &#123; const index = map.get(remainder); if (i - index &gt;= 2) &#123; return true; &#125; &#125; else &#123; map.set(remainder, i); &#125; &#125; return false;&#125;930. 和相同的二元子数组","categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"拓扑排序-课程表系列","slug":"拓扑排序-课程表系列","date":"2021-04-12T21:24:21.000Z","updated":"2021-11-06T12:54:08.428Z","comments":true,"path":"2021/04/12/拓扑排序-课程表系列/","link":"","permalink":"http://yoursite.com/2021/04/12/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-%E8%AF%BE%E7%A8%8B%E8%A1%A8%E7%B3%BB%E5%88%97/","excerpt":"","text":"leetcode 207 课程表你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程 bi 。例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。拓扑排序这种在一个图中，互相有依赖关系，需要按照依赖顺序排序输出的问题，就是拓扑排序。拓扑排序除了排序输出之外，还可以验证图中是否有环。比如下面常见的拓扑排序的应用。课程学习的先后顺序相互依赖的文件的编译顺序拓扑排序的方法一是 Kahn 算法。二是深度优先遍历Kahn 算法个人认为 Kahn 算法还是比较好理解的。首先需要定义 b 依赖与 a，a 要先与 b 执行，那么就是 a-&gt;b。此时 b 的入度是 1，a 的入度是 0。算法的思路就是首先统计出所有的点的入度，还需要统计所有点的 next 点然后找到入度为 0 的点，访问它，随后，将该点的所有 next 点的入度都减 1然后重复 2 这个步骤直到没有入度为 0 的点为止123456789101112131415161718192021222324252627282930313233343536function canFinish(numCourses: number, prerequisites: number[][]): boolean &#123; const inDegree = Array(numCourses).fill(0); const adjacent = inDegree.map(() =&gt; []); for (const [cur, pre] of prerequisites) &#123; // pre -&gt; cur inDegree[cur] += 1; adjacent[pre].push(cur); &#125; // 找到所有入度为0的课程 const queue = []; for (let i = 0; i &lt; inDegree.length; i++) &#123; if (inDegree[i] === 0) &#123; queue.push(i); &#125; &#125; const list = []; // 遍历入度为0的课程，入度为0，则加入list, 并将它的临接课程入度-1 while (queue.length) &#123; const cur = queue.shift(); list.push(cur); // 将当前课程的所有后序课程的入度减1，如果后序课程的入度为0，则加入list adjacent[cur].forEach((next) =&gt; &#123; inDegree[next]--; if (inDegree[next] === 0) &#123; queue.push(next); &#125; &#125;); &#125; // 最后验证一下，是否所有的课程都学完了 return list.length === numCourses;&#125;dfs 深度优先遍历深度优先遍历，也是解决拓扑排序的常用办法。其思路就是沿着一个点，一直往前找它的前置点，直到没有前置的点了，就是找到头了。此时就可以回溯访问了（从外到内探索，从内到外回溯访问）。需要注意的是，需要记录点的状态，未访问｜访问中｜已经访问。如果未访问需要标记未访问中如果是访问中，则说明又访问了一次，存在环如果是已经访问，那么直接返回就可以了;比如(这里和 Kahn 算法是反的，a-&gt;b 代表 b 先于 a 执行。a 依赖 b)a-&gt;b-&gt;cd-&gt;b-&gt;c访问完 a 这条链路，b 和 c 就已经访问了。因此再访问 d 这条链路时，就不需要访问 b 和 c 了12345678910111213141516171819202122232425262728293031323334353637383940414243function dfs( cur: number, pres: number[][], visited: number[], res: number[]): boolean &#123; if (visited[cur] === 2) &#123; // 已经访问过了 return true; &#125; else if (visited[cur] === 1) &#123; // 正在访问中，结果又来访问了。出现了环 return false; &#125; else &#123; // 设为访问中 visited[cur] = 1; for (let i = 0; i &lt; pres[cur].length; i++) &#123; // 访问前置节点 if (!dfs(pres[cur][i], pres, visited, res)) &#123; return false; &#125; &#125; visited[cur] = 2; res.push(cur); return true; &#125;&#125;function findOrder(numCourses: number, prerequisites: number[][]): number[] &#123; const visited = Array(numCourses).fill(0); // 0-未访问；1-访问中；2-已经访问 const pres = visited.map(() =&gt; []); // 记录节点的前置节点 // 统计节点的前置节点 for (let [cur, pre] of prerequisites) &#123; pres[cur].push(pre); &#125; const res = []; for (let i = 0; i &lt; numCourses; i++) &#123; if (!dfs(i, pres, visited, res)) &#123; return []; &#125; &#125; return res;&#125;","categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"完全二叉树、堆和优先队列","slug":"完全二叉树、堆和优先队列","date":"2021-04-11T14:10:04.000Z","updated":"2021-11-06T12:54:08.424Z","comments":true,"path":"2021/04/11/完全二叉树、堆和优先队列/","link":"","permalink":"http://yoursite.com/2021/04/11/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/","excerpt":"","text":"完全二叉树完全二叉树是满二叉树的一种退化。它只缺少最后一排最右边的一些元素。如下图所示。完全二叉树的特性完全二叉树有一个优秀的特性。就是它可以保存在一个数组中，而不需要使用链表的方式来存储。如果对完全二叉树中的节点编号，那么可以总结出一个规律。如果父节点的编号是 i，那么它的左子节点的编号就是 2i，右子节点的编号就是 2i+1实际上，在计算机中，我们会把数组作为完全二叉树的实际存储结构，而完全二叉树，则是我们重新看待这段数组信息的思维逻辑结构。因此，数据结构最大的价值，就是对我们思维逻辑结构的改造。堆堆（Heap）是一个可以被看成近似完全二叉树的数组。树上的每一个结点对应数组的一个元素。除了最底层外，该树是完全充满的，而且是从左到右填充。—— 来自：《算法导论》堆其实就是使用完全二叉树实现的一种数据结构。分为大顶堆和小顶堆。小顶堆；如果一个完全二叉树的每一个父节点的值都小于其子节点的值，那么就是一个小顶堆。大顶堆；如果一个完全二叉树的每一个父节点的值都大于其子节点的值，那么就是一个大顶堆。为了让你更好地学习堆这种数据结构，我要和你分享一个学习数据结构的公式：数据结构 = 结构定义 + 结构操作。结构定义和结构操作是组成数据结构最重要的两个部分，也是你之后在学任何一种数据结构时的重点内容。结构定义就是定义一种性质，结构操作就是维护这种性质。堆的结构定义大顶堆可以维护一个集合中的最大值。小顶堆可以维护一个集合中的最小值。堆的结构操作插入新元素插入到最后面（数组的最后）向上调整，维护堆的特性删除最值元素将最后一个元素覆盖堆顶元素（数组尾元素覆盖数组头元素）向下调整，维护堆的特性堆排序对数组建立一个大顶堆每次将堆顶元素和堆尾元素调换位置（相当于把最大值放在了最后），然后减小堆的 size，从上到下维护堆执行 n 次之后，得到一个从小到达排序的数组优先队列优先队列好像就是堆的别名啊？其实不然。你可以把优先队列当成是一种概念，那它的定义就是一种可以实现根据优先级出队的结构。而堆只是实现优先队列的其中一种方式，当然也是最普遍的方式。实现一个最(小)大堆123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146abstract class Heap&lt;T&gt; &#123; protected heap: T[] = []; protected getNumberForCompare: (val: T) =&gt; number; protected abstract compare(indexA: number, indexB: number): boolean; constructor(getNumberForCompare: (val: T) =&gt; number, values: T[] = []) &#123; this.getNumberForCompare = getNumberForCompare; this.heapify(values); &#125; // 交换堆内元素 protected swap(indexA: number, indexB: number) &#123; const temp = this.heap[indexA]; this.heap[indexA] = this.heap[indexB]; this.heap[indexB] = temp; &#125; // 获取左孩子的索引 protected getLeftChildIndex(index: number) &#123; return 2 * index + 1; &#125; // 获取右孩子的索引 protected getRightChildIndex(index: number) &#123; return 2 * index + 2; &#125; // 获取父亲节点的索引 protected getParentIndex(index: number) &#123; if (index === 0) return null; return (index - 1) &gt;&gt;&gt; 1; &#125; // 初始化建堆 protected heapify(values: T[]) &#123; this.heap = values; // 完全二叉树的叶子节点的个数是总节点个数的一半。 // 叶子节点本身不需要堆化。只需要等待后面的节点堆化。 for (let i = this.heap.length &gt;&gt;&gt; 1; i &gt;= 0; i--) &#123; this.heapifyDown(i); &#125; &#125; // 向上维护堆 protected heapifyUp(index: number) &#123; let currentIndex = index; let parentIndex = this.getParentIndex(currentIndex); while (parentIndex &gt;= 0 &amp;&amp; this.compare(currentIndex, parentIndex)) &#123; this.swap(currentIndex, parentIndex); currentIndex = parentIndex; parentIndex = this.getParentIndex(parentIndex); &#125; &#125; // 向下维护堆 protected heapifyDown(index: number) &#123; let currentIndex = index; let lChildIndex = this.getLeftChildIndex(currentIndex); let rChildIndex = this.getRightChildIndex(currentIndex); const size = this.size(); // 如果当前值大于左孩子 if (lChildIndex &lt; size &amp;&amp; this.compare(lChildIndex, currentIndex)) &#123; currentIndex = lChildIndex; &#125; // 如果当前值大于右孩子 if (rChildIndex &lt; size &amp;&amp; this.compare(rChildIndex, currentIndex)) &#123; currentIndex = rChildIndex; &#125; // 如果当前索引被替换 if (currentIndex !== index) &#123; this.swap(currentIndex, index); this.heapifyDown(currentIndex); &#125; &#125; // 获取堆的大小 size() &#123; return this.heap.length; &#125; // 判断堆是否为空 isEmpty() &#123; return this.heap.length === 0; &#125; // 插入元素 insert(value: T): boolean &#123; if (value != null) &#123; this.heap.push(value); this.heapifyUp(this.heap.length - 1); return true; &#125; return false; &#125; // 删除堆顶元素 extract(): T &#123; if (this.isEmpty()) return null; if (this.size() === 1) return this.heap.shift(); // 交换堆顶和堆尾元素 this.swap(0, this.heap.length - 1); // 剔除最小元素 const top = this.heap.pop(); // 重新堆化 this.heapifyDown(0); return top; &#125; // 获取堆顶元素 top(): T &#123; return this.isEmpty() ? null : this.heap[0]; &#125; // 获取堆内元素 values(): T[] &#123; return [...this.heap]; &#125;&#125;// 小顶堆export class MinHeap&lt;T&gt; extends Heap&lt;T&gt; &#123; protected compare(indexA: number, indexB: number): boolean &#123; return ( this.getNumberForCompare(this.heap[indexA]) &lt; this.getNumberForCompare(this.heap[indexB]) ); &#125;&#125;// 大顶堆export class MaxHeap&lt;T&gt; extends Heap&lt;T&gt; &#123; protected compare(indexA: number, indexB: number): boolean &#123; return ( this.getNumberForCompare(this.heap[indexA]) &gt; this.getNumberForCompare(this.heap[indexB]) ); &#125;&#125;参考Typescript binary heap","categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Express Koa Redux 中间件原理分析","slug":"Express-Koa-Redux中间件原理分析","date":"2021-04-10T12:23:57.000Z","updated":"2021-11-06T12:54:08.424Z","comments":true,"path":"2021/04/10/Express-Koa-Redux中间件原理分析/","link":"","permalink":"http://yoursite.com/2021/04/10/Express-Koa-Redux%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","excerpt":"","text":"最早接触中间件，是在第一次使用 express 框架的时候，那时对中间件的作用有了了解，后面再使用 Koa 框架时，也遇到了中间件，最大的使用感受就是中间件的参数不一样了，可以使用await语法来执行next()函数。几乎于此同时，使用的 Redux 也提出了中间件的概念。中间件的概念被广泛的采用，一定有其优势所在。本篇文章尝试分析和比较 Express Koa2 Redux 这三个框架的实现原理。调试这三个框架的源码其实非常简单。书写一个 js 文件，编写代码。使用 vscode 的 debug 功能启动代码。使用 curl 请求 localhost。Express 的中间件express 是内置路由功能的，并且同时内置了static,json,urlencoded 这三个中间件。下面是启动一个 express app 并注册 App-Level middleware 的代码。通过这段代码来分析 express 启动和中间件运行流程。1234567891011121314151617// express相当于一个工厂函数，它会返回一个函数，也就是appconst express = require(\"express\");const app = express();app.use(function middlewareA(req, res, next) &#123; console.log(\"1\"); next(); console.log(\"2\");&#125;);app.use(function middlewareB(req, res, next) &#123; console.log(\"3\"); next(); console.log(\"4\");&#125;);app.use(function middlewareC(req, res, next) &#123; res.send(\"hello world\");&#125;);app.listen(3000);以上代码返回了一个 express 实例，不过这个实例，是一个挂载了很多属性的函数。下面是express()的调用，在源码中就是createApplication()的调用。如下是源码部分。123456789101112131415161718192021222324252627// express/lib/express.jsfunction createApplication() &#123; // 定义app是一个函数。 var app = function (req, res, next) &#123; // app.handle 是通过mixin的方式组合进来的 app.handle(req, res, next); &#125;; // 使用组合的方式，给app这个函数上挂载通用方法。 mixin(app, EventEmitter.prototype, false); mixin(app, proto, false); // expose the prototype that will get set on requests app.request = Object.create(req, &#123; app: &#123; configurable: true, enumerable: true, writable: true, value: app &#125;, &#125;); // expose the prototype that will get set on responses app.response = Object.create(res, &#123; app: &#123; configurable: true, enumerable: true, writable: true, value: app &#125;, &#125;); app.init(); // 返回app函数 return app;&#125;app 通过 mixin 的方式挂载了很多的方法，其中就包含了 use 和 listen 方法。他们的源码如下。精简了一下代码。123456789101112131415161718// express/lib/application.jsapp.use = function use(fn) &#123; var path = \"/\"; // setup router this.lazyrouter(); var router = this._router; fns.forEach(function (fn) &#123; // 判断当前的中间件函数不是express app if (!fn || !fn.handle || !fn.set) &#123; // 把中间件挂载到路由的跟路径下。 return router.use(path, fn); &#125; &#125;, this); return this;&#125;;从上面可以看到，router 很重要，即使是 App-Level 中间件，也是挂载到 router 上的。下面看一下 router 的代码。12345678910111213141516171819202122232425262728293031323334353637383940// express/lib/router/index.jsproto.use = function use(fn) &#123; var offset = 0; var path = \"/\"; // default path to '/' // disambiguate router.use([fn]) if (typeof fn !== \"function\") &#123; var arg = fn; while (Array.isArray(arg) &amp;&amp; arg.length !== 0) &#123; arg = arg[0]; &#125; // first arg is the path if (typeof arg !== \"function\") &#123; offset = 1; path = fn; &#125; &#125; var callbacks = flatten(slice.call(arguments, offset)); for (var i = 0; i &lt; callbacks.length; i++) &#123; var fn = callbacks[i]; // 根据path和中间件函数生成一个layer实例 // 这里layer大概就是，根据path将处理流程分为一个一个层。 var layer = new Layer( path, &#123; sensitive: this.caseSensitive, strict: false, end: false, &#125;, fn ); layer.route = undefined; // 最后将layer推入一个栈中。相当于把中间件保存了起来。 this.stack.push(layer); &#125; return this;&#125;;上面 router 的代码，就是最终实现了 app.use 方法保存中间件函数的逻辑。如果断点调试，会发现一个有趣的事实，就是在我们的 middlewareA 中间件之前，express 已经加入了两个默认的 layer。如下图下面再来看下程序运行并收到请求后的执行流程。首先是 app.listen，通过 http.createServer 构造了一个 server 实例，实例的回调函数，就是 app 本身，这种写法也是非常骚了，把一个 app 函数玩弄于股掌之间。1234app.listen = function listen() &#123; var server = http.createServer(this); return server.listen.apply(server, arguments);&#125;;从 createApplication 函数中可以看到，app 函数本身，就是调用了 app.handle,而 app.handle 又是调用了router.handle 囧。所以我们的每个请求，其实最终就是由 router.handle 来处理了，并且会在这里展开对所有中间件的调用。这个代码很长，我们精简一下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130// express/lib/router/index.jsproto.handle = function handle(req, res, out) &#123; var self = this; var idx = 0; var protohost = getProtohost(req.url) || \"\"; var removed = \"\"; var slashAdded = false; var paramcalled = &#123;&#125;; // store options for OPTIONS request // only used if OPTIONS request var options = []; // middleware and routes var stack = self.stack; // manage inter-router variables var done = restore(out, req, \"baseUrl\", \"next\", \"params\"); // setup next layer req.next = next; next(); function next(err) &#123; var layerError = err === \"route\" ? null : err; // signal to exit router if (layerError === \"router\") &#123; setImmediate(done, null); return; &#125; // no more matching layers if (idx &gt;= stack.length) &#123; setImmediate(done, layerError); return; &#125; // get pathname of request var path = getPathname(req); if (path == null) &#123; return done(layerError); &#125; // find next matching layer var layer; var match; var route; while (match !== true &amp;&amp; idx &lt; stack.length) &#123; layer = stack[idx++]; match = matchLayer(layer, path); route = layer.route; if (typeof match !== \"boolean\") &#123; // hold on to layerError layerError = layerError || match; &#125; if (match !== true) &#123; continue; &#125; if (!route) &#123; // process non-route handlers normally continue; &#125; if (layerError) &#123; // routes do not match with a pending error match = false; continue; &#125; var method = req.method; var has_method = route._handles_method(method); // build up automatic options response if (!has_method &amp;&amp; method === \"OPTIONS\") &#123; appendMethods(options, route._options()); &#125; // don't even bother matching route if (!has_method &amp;&amp; method !== \"HEAD\") &#123; match = false; continue; &#125; &#125; // no match if (match !== true) &#123; return done(layerError); &#125; // store route for dispatch on change if (route) &#123; req.route = route; &#125; // Capture one-time layer values req.params = self.mergeParams ? mergeParams(layer.params, parentParams) : layer.params; var layerPath = layer.path; // this should be done for the layer self.process_params(layer, paramcalled, req, res, function (err) &#123; if (err) &#123; return next(layerError || err); &#125; if (route) &#123; return layer.handle_request(req, res, next); &#125; trim_prefix(layer, layerError, layerPath, path); &#125;); &#125; if (layerError) &#123; layer.handle_error(layerError, req, res, next); &#125; else &#123; layer.handle_request(req, res, next); &#125; &#125;&#125;;可以看到，关键的就是 next 函数了，next 函数引用了一个外部变量 idx ，形成了一个包含 idx 的闭包，next 函数每次执行，都会找到下一个需要执行的中间件(layer), 然后执行 layer.handle_request(req, res, next); , 在执行的过程中，将 next 函数本身作为参数传递，这样当中间件执行 next 的时候，又会重复上述过程。通过 next 的执行，串起了一个一个中间件。Express 中间件的总结第一段代码的输出为 1 3 4 2, 其实也可以说 express 的中间件执行顺序类似与洋葱圈模型。但是，express 结束请求，返回响应的标志是 res.send ，也就是说一旦调用了 res.send,那么响应也就结束了，虽然后序的代码仍然会继续执行。但是已经影响不到响应了。这也是和 koa 的一个重要区别。另一个要说明的就是，express 相对于 koa，内置了路由系统，甚至中间件也是挂载在路由上的，因此源代码比 koa 更加复杂。express 成型的时间比较早，内部的写法还都是函数，也没有明显的使用 promise async await 等先进的特性。参考[1] express[2] koa 和 express 中间件揭秘[3] express 和 koa 的区别","categories":[],"tags":[{"name":"中间件","slug":"中间件","permalink":"http://yoursite.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"express","slug":"express","permalink":"http://yoursite.com/tags/express/"},{"name":"koa","slug":"koa","permalink":"http://yoursite.com/tags/koa/"},{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"}]},{"title":"二叉树系列","slug":"二叉树系列","date":"2021-04-07T09:51:15.000Z","updated":"2021-11-06T12:54:08.424Z","comments":true,"path":"2021/04/07/二叉树系列/","link":"","permalink":"http://yoursite.com/2021/04/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%97/","excerpt":"","text":"(搜索)二叉树这种数据结构，操作和判断特别多，这篇文章归纳和整理一下它的常见操作。一个有趣的现象是，关于二叉树，有广度优先和深度优先两种搜索办法。如果是广度优先，常规做法是使用一个辅助队列 queue。如果是深度优先，常规做法是使用递归。验证二叉搜索树对称二叉树二叉树的前中后序遍历二叉树的层次遍历/锯形层次遍历二叉树最近公共祖先二叉树最大/最小深度删除二叉树中的节点从中序遍历和后序遍历构造二叉树验证二叉搜索树 98验证一棵树是否为二叉搜索树，有两种方法。都是基于二叉搜索树的特征。基于二叉搜索树的中序遍历结果是升序序列。中序遍历整个二叉搜索树，遍历的过程中查验是否为升序。基于节点的左子树中所有的节点的值，均小于当前节点的值；节点的右子树中所有节点的值，均大于当前节点的值。根节点的值的范围为(-Infinity,Infinity)。其左子节点的值应该小于 root.val, 所以范围应该为(-Infinity,root.val)。同理，右子节点的范围应该为(root.val,Infinity)。树上的每个节点都应该满足上面的条件。递归代码1234567891011121314function helper(root: TreeNode | null, min: number, max: number): boolean &#123; if (!root) return true; // 不满足条件 if (root.val &lt;= min || root.val &gt;= max) &#123; return false; &#125; // 递归验证左右孩子是否满足条件 return helper(root.left, min, root.val) &amp;&amp; helper(root.right, root.val, max);&#125;function isValidBST(root: TreeNode | null): boolean &#123; // root节点的取值范围为(-Infinity,Infinity) return helper(root, -Infinity, Infinity);&#125;对称二叉树 剑指 offer28验证一个树是否为对称二叉树，优雅的方案还是递归，毕竟要一层一层的比较，而且每次比较的模式都是一样的。递归代码123456789101112131415161718192021function helper(left: TreeNode | null, right: TreeNode | null): boolean &#123; if (!left &amp;&amp; !right) &#123; // 都不存在 return true; &#125; else if (left &amp;&amp; right) &#123; if (left.val === right.val) &#123; // 当前两个节点是对称的，继续去验证他们的孩子是否对称 return helper(left.left, right.right) &amp;&amp; helper(left.right, right.left); &#125; else &#123; // 不对称相等 return false; &#125; &#125; else &#123; // left或者right，只存在一个 return false; &#125;&#125;function isSymmetric(root: TreeNode | null): boolean &#123; return helper(root, root);&#125;二叉树的前中后序遍历 94这里以二叉树的中序遍历为例子。使用递归，中序遍历的实现很容易实现（代码简单）。比较难（或者说不容易记住和理解）的是使用迭代的方式来遍历。不过话说回来，明明递归的代码看上去更简洁明了，可能是更符合人们的思维习惯。相反如果是使用迭代，确需要肯定的理解其执行过程 😖。递归代码12345678910111213function helper(root: TreeNode | null, res: number[]) &#123; if (!root) return; helper(root.left, res); res.push(root.val); helper(root.right, res);&#125;function inorderTraversal(root: TreeNode | null): number[] &#123; const res: number[] = []; helper(root, res); return res;&#125;迭代代码12345678910111213141516171819202122function inorderTraversal(root: TreeNode | null): number[] &#123; if (!root) return []; const res = []; // 既然是递归，就要用栈来模拟咯 const stack = []; while (stack.length || root) &#123; while (root) &#123; stack.push(root); root = root.left; &#125; // 此时的root为null，栈顶元素就是最左边的叶子节点 // 弹出并访问 const node = stack.pop(); res.push(node.val); // 这一步很关键，开始准备遍历右子树 root = node.right; &#125; return res;&#125;二叉树的层次遍历使用递归，也就是 dfs 深度优先搜索。可以使用一个队列来保存被访问的节点，也就是广度优先搜索。递归代码123456789101112131415function helper(root: TreeNode | null, index: number, res: number[][]) &#123; if (!root) return; res[index] ? res[index].push(root.val) : (res[index] = [root.val]); helper(root.left, index + 1, res); helper(root.right, index + 1, res);&#125;function levelOrder(root: TreeNode | null): number[][] &#123; if (!root) return []; const res = []; helper(root, 0, res); return res;&#125;迭代代码1234567891011121314151617function levelOrder(root: TreeNode | null): number[][] &#123; if (!root) return []; const queue = [root]; const res = []; while (queue.length) &#123; const length = queue.length; const temp = []; for (let i = 0; i &lt; length; i++) &#123; const node = queue.shift(); temp.push(node.val); if (node.left) queue.push(node.left); if (node.right) queue.push(node.right); &#125; res.push(temp); &#125; return res;&#125;二叉树最近公共祖先前提条件是 p 和 q 都是树中的节点。递归代码12345678910111213141516171819function lowestCommonAncestor( root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null &#123; if (!root) return root; if (root === p || root === q) return root; const left = lowestCommonAncestor(root.left, p, q); const right = lowestCommonAncestor(root.right, p, q); if (left &amp;&amp; right) &#123; return root; &#125; else if (left) &#123; return left; &#125; else &#123; return right; &#125;&#125;二叉树的最大深度递归求出左右子树深度的最大值，然后加 1。1234567891011121314151617function maxDepth(root: TreeNode | null): number &#123; if (!root) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;&#125;function minDepth(root: TreeNode | null): number &#123; if (!root) return 0; if (!root.left &amp;&amp; !root.right) return 1; let min = Infinity; if (root.left) &#123; min = Math.min(minDepth(root.left), min); &#125; if (root.right) &#123; min = Math.min(minDepth(root.right), min); &#125; return min + 1;&#125;","categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"常用React hooks","slug":"常用React-hooks","date":"2021-04-05T21:32:11.000Z","updated":"2021-11-06T12:54:08.428Z","comments":true,"path":"2021/04/05/常用React-hooks/","link":"","permalink":"http://yoursite.com/2021/04/05/%E5%B8%B8%E7%94%A8React-hooks/","excerpt":"","text":"React hooks 已经很普及了。记录和整理一些比较通用的 hook。useMount返回组件挂载的状态。可以在一些异步处理之后，判断组件是否已经被卸载。1234567891011function useMount() &#123; const mount = useRef(false); useEffect(() =&gt; &#123; mount.current = true; return () =&gt; &#123; mount.current = false; &#125;; &#125;, []); return () =&gt; mount.current;&#125;usePreProps返回上一次的 props，也可以用来判断某个 props 是否改变。123456789function usePreProps(props) &#123; const ref = useRef(props); useEffect(() =&gt; &#123; ref.current = props; &#125;, [props]); // return ref.current === props; // 判断属性是否改变 return ref.current; // 返回上一次的属性&#125;useOnScreen返回组件是否曝光。12345678910111213141516171819202122const useOnScreen = (ref: React.RefObject&lt;any&gt;, rootMargin = \"0px\") =&gt; &#123; if (!ref || !ref.current) return; const [intersecting, setIntersecting] = useState(false); // 是否已经曝光 useEffect(() =&gt; &#123; const ovserver = new IntersectionObserver( ([entry]) =&gt; &#123; setIntersecting(entry.isIntersecting); &#125;, &#123; rootMargin &#125; ); ovserver.observe(ref.current); return () =&gt; &#123; observer.unobserve(ref.current); &#125;; &#125;, []); return [intersecting];&#125;;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"leetcode-n数之和系列","slug":"leetcode-N数之和系列","date":"2021-03-26T09:17:51.000Z","updated":"2021-11-06T12:54:08.424Z","comments":true,"path":"2021/03/26/leetcode-N数之和系列/","link":"","permalink":"http://yoursite.com/2021/03/26/leetcode-N%E6%95%B0%E4%B9%8B%E5%92%8C%E7%B3%BB%E5%88%97/","excerpt":"","text":"N 数之和系列两数之和给定一个数组，一个 target，找到数组中所有两个数字之和为 target 的组合。这里为了后面 N 数之和做准备，不是返回一个组合。代码123456789101112131415161718192021222324function twoSum(nums: number[], target: number): number[][] &#123; // 先排序数组 nums.sorts((a, b) =&gt; a - b); // 双指针遍历 let left = 0; let right = nums.length - 1; const res = []; while (left &lt; right) &#123; const lVal = nums[left]; const rVal = nums[right]; if (lVal + rVal === target) &#123; res.push([lVal, rVal]); // 排除重复的 while (nums[left] === lVal) left++; while (nums[right] === rVal) right--; &#125; else if (lVal + rVal &lt; target) &#123; left++; &#125; else &#123; right--; &#125; &#125; return res;&#125;三数之和有了两数之和，三数之和的计算就可以依赖现有的两数之和的函数，但是要稍微改造一下。代码12345678910111213141516171819202122232425262728293031323334353637383940414243// 更加泛型（通用）的两数之和函数// 默认数组已经排序function twoSum(nums: number[], target: number, start: number): number[][] &#123; // 双指针遍历 let left = start; let right = nums.length - 1; const res = []; while (left &lt; right) &#123; const lVal = nums[left]; const rVal = nums[right]; if (lVal + rVal === target) &#123; res.push([lVal, rVal]); // 排除重复的 while (nums[left] === lVal) left++; while (nums[right] === rVal) right--; &#125; else if (lVal + rVal &lt; target) &#123; left++; &#125; else &#123; right--; &#125; &#125; return res;&#125;function threeSum(nums: number[]): number[][] &#123; if (nums.length &lt; 3) return []; nums.sort((a, b) =&gt; a - b); const res = []; for (let i = 0; i &lt; nums.length; i++) &#123; // 遍历第一个数字，下面要求两数之和，和为target-nums[i] const newTarget = 0 - nums[i]; const newStart = i + 1; const temp = twoSum(nums, newTarget, newStart); for (let j = 0; j &lt; temp.length; j++) &#123; res.push([nums[i], ...temp[j]]); &#125; // 去除重复的结果 while (nums[i] === nums[i + 1]) i++; &#125; return res;&#125;N 数之和有了上面的例子，继而推演出 N 数之和的通用方法，也就有了思路。每次确定一个数字，最终只剩两个数字的时候，就是调用两数之和的时候。需要注意的是，常规的想法是 N 是几，就进行 N-1 层遍历。这里 N 是未知的。不过可以使用递归，来一层一层的减少 N代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 更加泛型（通用）的两数之和函数// 默认数组已经排序function twoSum(nums: number[], target: number, start: number): number[][] &#123; // 双指针遍历 let left = start; let right = nums.length - 1; const res = []; while (left &lt; right) &#123; const lVal = nums[left]; const rVal = nums[right]; if (lVal + rVal === target) &#123; res.push([lVal, rVal]); // 排除重复的 while (nums[left] === lVal) left++; while (nums[right] === rVal) right--; &#125; else if (lVal + rVal &lt; target) &#123; left++; &#125; else &#123; right--; &#125; &#125; return res;&#125;// 这里数组已经排序function nSum( nums: number[][], target: number, n: number, start: number, visited: number[], ans: number[][] = []): number[][] &#123; // 注意这里是大于 if (n + start &gt; nums.length) return []; if (n === 2) &#123; // 可以调用两数之和 const temp = twoSum(nums, target, start); for (let i = 0; i &lt; temp.length; i++) &#123; ans.push([...visited, ...temp[i]]); &#125; return; &#125; else &#123; // n大于2 for (let i = start; i &lt; nums.length; i++) &#123; const newTarget = target - nums[i]; const newN = n - 1; const newStart = i + 1; const newVisited = [...visited, nums[i]]; nSum(nums, newTarget, newN, newStart, newVisited, ans); // 去除重复的 while (nums[i] === nums[i + 1]) i++; &#125; &#125; return ans;&#125;// 例如求四数之和function fourSum(nums: number[], target: number): number[][] &#123; nums.sort((a, b) =&gt; a - b); return nSum(nums, target, 4, 0, []);&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"leetcode-买卖股票的最佳时机系列(121,122,123,188)","slug":"leetcode-买卖股票的最佳时机系列","date":"2021-03-14T18:32:46.000Z","updated":"2021-11-06T12:54:08.424Z","comments":true,"path":"2021/03/14/leetcode-买卖股票的最佳时机系列/","link":"","permalink":"http://yoursite.com/2021/03/14/leetcode-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E7%B3%BB%E5%88%97/","excerpt":"","text":"121 买卖股票的最佳时机 I给定一只股票，但是只能买卖一次。暴力法进行两层循环，第一层循环是买入的日子，第二层循环是卖出的日子，遍历左右的利润，求出最大值。代码1234567891011function maxProfit(prices: number[]): number &#123; if (prices.length &lt; 2) return 0; const length = prices.length; let profit = 0; for (let i = 0; i &lt; length; i++) &#123; for (let j = i + 1; j &lt; length; j++) &#123; profit = Math.max(profit, prices[j] - prices[i]); &#125; &#125; return profit;&#125;优化进行一次遍历，在遍历的过程中修改变量，一个是当前最低的价格，一个是当前的利润。如果当前价格低于最低价格，则更新最低价格。用当前的价格减去最低价格，即是这一天能够获得的最大利润。代码12345678910111213function maxProfit(prices: number[]): number &#123; if (prices.length &lt; 2) return 0; const length = prices.length; let minPrice = prices[0]; let profit = 0; for (let i = 1; i &lt; prices.length; i++) &#123; if (prices[i] &lt; minPrice) &#123; minPrice = prices[i]; &#125; profit = Math.max(profit, prices[i] - minPrice); &#125; return profit;&#125;122 买卖股票的最佳时机 II暴力法对于每个股票交易日，都有两种选择，一种是按兵不动，即不进行任何操作。还有一种是根据当前股票的持有情况，进入买进或者卖出，比如当前持有股票就可以卖出，当前没有股票就进行买入。每一个交日易都有不同的选择，一次一次的选择形成了一棵操作树，这是典型的 dfs 了。暴力法代码12345678910111213141516171819202122232425262728function maxProfit(prices: number[]): number &#123; let max = 0; const length = prices.length; // status:0代表手上没有股票，可以买。1代表手上有股票，可以卖。 const dfs = (count: number, profit: number, status: number) =&gt; &#123; if (count === length) &#123; max = Math.max(max, profit); return; &#125; // 按兵不动 dfs(count + 1, profit, status); // 进行操作 if (status === 0) &#123; // 进行买入，利润要减掉当前价格 dfs(count + 1, profit - prices[count], 1); &#125; else if (status === 1) &#123; // 进行卖出，利润要加上当前价格 dfs(count + 1, profit + prices[count], 0); &#125; &#125;; dfs(0, 0, 0); return max;&#125;贪心算法这个问题，可以使用贪心算法，即根据当日的价格来决定上个交易日是否进行买入，只要今天的价格比昨天高，就昨天买日，今天卖出。当然现实情况下，是不可能买入昨天的股票的。贪心法代码123456789101112function maxProfit(prices: number[]): number &#123; if (!prices || prices.length &lt; 2) return 0; let profit = 0; for (let i = 1; i &lt; prices.length; i++) &#123; if (prices[i] &gt; prices[i - 1]) &#123; profit += prices[i] - prices[i - 1]; &#125; &#125; return profit;&#125;动态规划如果使用动态规划来解决这个问题，那么需要保存一个二维的状态，dp[i][j]。dp[i][0] 代表第 i 天，手上没有股票时的收益。dp[i][1]代表第 i 天手上有股票的收益。那么推导一下状态方程就是dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]+prices[i])也就是第 i 天手上没有股票时，可以是 i-1 天本来就没有股票，然后第 i 天不进行任何操作，或者是 i-1 天持有股票，然后将其卖出。取两者的最大值。dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i])也就是第 i 天手上有股票时，可以是 i-1 天本来就有股票，然后第 i 天按兵不动，或者第 i-1 天手上没有骨片，然后今天买进。取两者的最大值。最后我们期望的结果就是 dp[n][0]。也就是最后一天手上没有股票时的金额。可以看出第 n 天的最大收益，是根据之前的每一天的收益情况，一点一点推导出来的。非常经典的动态规划。动态规划代码1234567891011121314function maxProfit(prices: number[]): number &#123; if (!prices || prices.length &lt; 2) return 0; const dp = prices.map(() =&gt; [0, 0]); dp[0][0] = 0; dp[0][1] = -prices[0]; for (let i = 1; i &lt; prices.length; i++) &#123; dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); &#125; return dp[prices.length - 1][0];&#125;123 买卖股票的最佳时机 III不同于买卖股票的最佳时机 II。这次只能交易两次了。这次我们只选择动态规划来解决这个问题。我们把买进股票作为交易一次股票的标志。动态规划首先需要增加一个状态，来记录当前已经交易了几次。dp[i][j][k] ,j 代表了是第几次买进股票了。可以的取值为 0，1，2。k 还是代表当前手上是否持有股票，0 表示不持有，1 表示持有。代码1234567891011121314151617181920212223242526272829303132333435function maxProfit(prices: number[]): number &#123; if (prices.length &lt; 2) return 0; const length = prices.length; // 初始化三维dp数组 const dp = prices.map(() =&gt; Array(2)); for (let i = 0; i &lt; length; i++) &#123; for (let j = 0; j &lt;= 2; j++) &#123; dp[i][j] = []; &#125; &#125; // 初始化状态 for (let i = 0; i &lt; length; i++) &#123; dp[i][0][0] = 0; // 第i天，没有交易股票，手上也没有股票 dp[i][0][1] = -Infinity; // 第i天，没有交易股票，手上有一股，是不可能的。 &#125; for (let j = 0; j &lt;= 2; j++) &#123; dp[0][j][0] = 0; // 第1天，买入了j次，手上没有股票 dp[0][j][1] = -pirces[0]; // 第一天，买入了j次，手上有股票 &#125; for (let i = 1; i &lt; length; i++) &#123; for (let j = 1; j &lt;= 2; j++) &#123; dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]); dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]); &#125; &#125; // 求最后一天，手上没有股票时的最大利润 let maxProfit = 0; for (let j = 0; j &lt;= 2; j++) &#123; maxProfit = Math.max(maxProfit, dp[length - 1][j][0]); &#125; return maxProfit;&#125;188 买卖股票的最佳时机 IV这一次又升级了，可以买卖 k 次动态规划状态方程可以参考买卖两次。其实已经将算法范型化，支持将 2 次变成 k 次就可以了。需要注意的是，当 k&gt;=len/2 的时候，问题相当于变成了可以交易无数次，也就是 122，这时可以直接采用 122 的贪心算法。代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function greedy(prices: number[]): number &#123; if (!prices || prices.length &lt; 2) return 0; let profit = 0; for (let i = 1; i &lt; prices.length; i++) &#123; if (prices[i] &gt; prices[i - 1]) &#123; profit += prices[i] - prices[i - 1]; &#125; &#125; return profit;&#125;function maxProfit(k: number, prices: number[]): number &#123; if (prices.length &lt; 2) return 0; if (k &gt;= prices.length / 2) return greedy(prices); const length = prices.length; // 初始化三维dp数组 const dp = prices.map(() =&gt; Array(k + 1)); for (let i = 0; i &lt; length; i++) &#123; for (let j = 0; j &lt;= k; j++) &#123; dp[i][j] = []; &#125; &#125; // 初始化状态 for (let i = 0; i &lt; length; i++) &#123; dp[i][0][0] = 0; // 第i天，没有交易股票，手上也没有股票 dp[i][0][1] = -Infinity; // 第i天，没有交易股票，手上有一股，是不可能的。 &#125; for (let j = 0; j &lt;= k; j++) &#123; dp[0][j][0] = 0; // 第1天，买入了j次，手上没有股票 dp[0][j][1] = -prices[0]; // 第一天，买入了j次，手上有股票 &#125; for (let i = 1; i &lt; length; i++) &#123; for (let j = 1; j &lt;= k; j++) &#123; dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]); dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]); &#125; &#125; // 求最后一天，手上没有股票时的最大利润 let maxProfit = 0; for (let j = 0; j &lt;= k; j++) &#123; maxProfit = Math.max(maxProfit, dp[length - 1][j][0]); &#125; return maxProfit;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"leetcode-142-环形链表","slug":"leetcode-142-环形链表","date":"2021-03-14T11:05:49.000Z","updated":"2021-11-06T12:54:08.424Z","comments":true,"path":"2021/03/14/leetcode-142-环形链表/","link":"","permalink":"http://yoursite.com/2021/03/14/leetcode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/","excerpt":"","text":"142 环形链表解法 1遍历链表，同时使用一个 set 存储已经访问过的节点，如果当前正在访问的节点存在于 set 中，则说明找到了换的入口。返回该节点。12345678910111213function detectCycle(head: ListNode | null): ListNode | null &#123; const set = new Set&lt;ListNode&gt;(); let node = head; while (node) &#123; if (set.has(node)) &#123; return node; &#125; else &#123; set.add(node); node = node.next; &#125; &#125; return null;&#125;解法 2假设起点到环的入口点的距离是 a，慢指针和快指针在环内相遇，慢指针在环内走过的距离是 b，环内剩下的距离是 c，则环的周长是 b+c。快指针走过的距离是慢指针的 2 倍。12345slow * 2 &#x3D; fastslow &#x3D; a + bfast &#x3D; a + b + (b + c)2 * (a + b) &#x3D; a + b + (b + c);a &#x3D; c可以推导出环内剩余路程 c，和 a 距离相等。因此定义一个指针从 head 出发，慢指针继续走，相遇点即为入口点。12345678910111213141516171819202122232425function detectCycle(head: ListNode | null): ListNode | null &#123; let slow = head; let fast = head; while (fast &amp;&amp; fast.next) &#123; slow = slow.next; fast = fast.next.next; if (slow === fast) &#123; break; &#125; &#125; // 没有环 if (!fast || !fast.next) return null; // 有环 let p = head; while (p !== slow) &#123; p = p.next; slow = slow.next; &#125; return p;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"并查集","slug":"并查集","date":"2021-03-13T22:30:17.000Z","updated":"2021-11-06T12:54:08.428Z","comments":true,"path":"2021/03/13/并查集/","link":"","permalink":"http://yoursite.com/2021/03/13/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"并查集并查集一种数据结构，可以用一个 Class 来实现。可以把一组数据关联起来，然后统计数量。可以用来解决岛屿数量的问题。实现使用一个数组来保存每一项的父节点使用一个数组来保存每一项的层级一个 findRoot 方法，可以找到一项的根一个 union 方法，如果两项的根不同，可以合并两项的根，使他们俩的根相同1234567891011121314151617181920212223242526272829303132333435363738394041424344class UnionFind &#123; parent: number[] = []; rank: number[] = []; count: number = 0; constructor(nums: number[][]) &#123; const m = nums.length; const n = nums[0].length; for (let i = 0; i &lt; m; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; this.rank[i * n + j] = 0; if (nums[i][j]) &#123; this.parent[i * n + j] = i * n + j; this.count++; &#125; &#125; &#125; &#125; find(num: number): number &#123; if (this.parent[num] !== num) &#123; this.parent[num] = this.find(this.parent[num]); &#125; return this.parent[num]; &#125; union(x: number, y: number) &#123; const rootX = this.find(x); const rootY = this.find(y); if (rootX !== rootY) &#123; if (this.rank[rootX] &lt; this.rank[rootY]) &#123; this.parent[rootX] = rootY; &#125; else if (this.rank[rootX] &gt; this.rank[rootY]) &#123; this.parent[rootY] = rootX; &#125; else &#123; // rank rootX 等于 rank rootY this.parent[rootX] = rootY; this.rank[rootY]++; &#125; this.count--; &#125; &#125;&#125;","categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"省份数量和岛屿数量-两种DFS","slug":"省份数量和岛屿数量-两种DFS","date":"2021-03-13T22:26:19.000Z","updated":"2021-11-06T12:54:08.428Z","comments":true,"path":"2021/03/13/省份数量和岛屿数量-两种DFS/","link":"","permalink":"http://yoursite.com/2021/03/13/%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F%E5%92%8C%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-%E4%B8%A4%E7%A7%8DDFS/","excerpt":"","text":"省份数量和岛屿数量-两种 DFS省份数量计算省份数量，也可以是计算朋友圈的数量。从 1 到 n，一共有 n 个城市，他们的连接关系可以用一个二维数组来表示。1234567const isConnected = [ [1, 1, 0], [1, 1, 0], [0, 0, 1],];// isConnected[i][j]=1 代表了i和j这两个连接，isConnected[i][j]=0则代表不直接连接。连接具有传递性。i-&gt;j 连接，j-&gt;k 连接，那么 i-&gt;k。所有相连接的城市（朋友）构成了一个省份（朋友圈）。求所有省份的数量。这里需要用到 DFS 去搜索，并且需要一个 visited 来记录哪些城市已经被访问过了。遍历这 n 个城市，如果没有被 visited，省份就加 1。比如搜索到了城市 i，那么就顺着把 i 这个链条都去访问一遍，并且记录在 visited 里面。1234567891011121314151617181920212223242526272829303132function dfs( isConnected: number[][], visited: boolean[], i: number, m: number) &#123; if (visited[i]) return; visited[i] = true; for (let j = 0; j &lt; m; j++) &#123; if (isConnected[i][j]) &#123; dfs(isConnected, visited, j, m); &#125; &#125;&#125;function findCircleNum(isConnected: number[][]): number &#123; if (!isConnected.length || !isConnected[0].length) return 0; const m = isConnected.length; const visited = Array(m).fill(false); let count = 0; for (let i = 0; i &lt; m; i++) &#123; if (!visited[i]) &#123; count++; dfs(isConnected, visited, i, m); &#125; &#125; return count;&#125;岛屿数量使用二维矩阵代表一篇区域，如果 grid[i][j]为 1 代表陆地，如果 grid[i][j]为 0 代表海洋，所有连接的 1 构成一个岛屿，求岛屿的数量。也是 dfs，遍历整个二维矩阵，如果当前是陆地，就 dfs 搜索这个点的周围区域，并且把周围区域标记为 0。需要向四个方向来进行 dfs。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function bfs(grid: string[][], i: number, j: number, m: number, n: number) &#123; const queue = [[i, j]]; while (queue.length) &#123; const [a, b] = queue.shift(); if (grid[a][b] === \"1\") &#123; grid[a][b] = \"0\"; if (a - 1 &gt;= 0 &amp;&amp; grid[a - 1][b] === \"1\") queue.push([a - 1, b]); if (a + 1 &lt; m &amp;&amp; grid[a + 1][b] === \"1\") queue.push([a + 1, b]); if (b - 1 &gt;= 0 &amp;&amp; grid[a][b - 1] === \"1\") queue.push([a, b - 1]); if (b + 1 &lt; n &amp;&amp; grid[a][b + 1] === \"1\") queue.push([a, b + 1]); &#125; &#125;&#125;function dfs(grid: string[][], i: number, j: number, m: number, n: number) &#123; if (i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n || grid[i][j] == \"0\") &#123; return; &#125; grid[i][j] = \"0\"; const dirs = [ [1, 0], [-1, 0], [0, -1], [0, 1], ]; for (const [dx, dy] of dirs) &#123; dfs(grid, dx + i, dy + j, m, n); &#125;&#125;function numIslands(grid: string[][]): number &#123; if (!grid.length || !grid[0].length) return 0; const copy = grid.map((item) =&gt; [...item]); const m = copy.length; const n = copy[0].length; let count = 0; for (let i = 0; i &lt; m; i++) &#123; for (let j = 0; j &lt; n; j++) &#123; if (copy[i][j] == \"1\") &#123; count++; dfs(copy, i, j, m, n); &#125; &#125; &#125; return count;&#125;对比省份是沿着一个链接链条进行 dfs，并标记 visited岛屿是沿着一个点，向四个方向进行 dfs，并将 grid 置为 0。也可以使用 bfs","categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"leetcode-101-105-23-使用递归吧","slug":"leetcode-101-105-23-使用递归吧","date":"2021-01-14T23:23:28.000Z","updated":"2021-11-06T12:54:08.424Z","comments":true,"path":"2021/01/14/leetcode-101-105-23-使用递归吧/","link":"","permalink":"http://yoursite.com/2021/01/14/leetcode-101-105-23-%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%90%A7/","excerpt":"","text":"101-105-23 使用递归吧101 对称二叉树105 根据中序遍历和先序遍历构造二叉树23 合并 k 个升序链表这几个问题虽然情景各不一样，但是都可以使用递归的编程技巧来解决问题。101 对称二叉树使用递归使用两个指针 p 和 q，初始化都指向 root 节点。判断 p.val===q.val，如果相等那么 p 和 q 同时移动，但是移动的方向是对称的，也就是 p 向左移动，那么 q 就要向右移动。由于要比较和操作 p 和 q 两个指针，因此我们的函数也需要两个参数代码如下：123456789101112131415function helper(p: TreeNode | null, q: TreeNode | null): boolean &#123; if (!p &amp;&amp; !q) return true; if (!p || !q) return false; if (p.val !== q.val) return false; const inner = helper(p.left, q.right); // 验证内对称 const outer = helper(p.right, q.left); // 验证外对称 return inner &amp;&amp; outer;&#125;function isSymmetric(root: TreeNode | null): boolean &#123; return helper(root, root);&#125;这里的为了验证对称性，内部调用了两次 helper，这也算是树的递归常见模式，针对不同的情况，分开递归调用。其中 helper 还可以简写为如下形式。123456function helper(p: TreeNode | null, q: TreeNode | null): boolean &#123; if (!p &amp;&amp; !q) return true; if (!p || !q) return false; return p.val === q.val &amp;&amp; helper(p.left, q.right) &amp;&amp; helper(p.right, q.left);&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"leetcode-71-简化路径","slug":"leetcode-71-简化路径","date":"2020-11-21T22:57:38.000Z","updated":"2021-11-06T12:54:08.424Z","comments":true,"path":"2020/11/21/leetcode-71-简化路径/","link":"","permalink":"http://yoursite.com/2020/11/21/leetcode-71-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/","excerpt":"","text":"71 路径总和示例示例 1：输入：”/home/“输出：”/home”解释：注意，最后一个目录名后面没有斜杠。示例 2：输入：”/../“输出：”/“解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。示例 3：输入：”/home//foo/“输出：”/home/foo”解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。示例 4：输入：”/a/./b/../../c/“输出：”/c”示例 5：输入：”/a/../../b/../c//.//“输出：”/c”问题分析Round One一开始没有头绪，大概想到了依次读取字符串，然后利用栈。比如遇到..就 pop 一个元素。但是没有整理出完整的思路。Round Two不啰嗦，直接看 leetcode 上的 discussion 吧。果然人家的思路清晰又简单。使用’/‘将路径字符串分割为路径数组。准备一个栈遍历数组遇到 ‘’ 直接 continue(分割了//)遇到 ‘.’ 直接 continue(分割了/./)遇到’..’ stack.pop() 需要返回上一级遇到普通字符串 stack.push() 进入一级代码实现12345678910111213141516function simplifyPath(path: string): string &#123; const arr = path.split(\"/\"); const stack: string[] = []; for (let str of arr) &#123; if (str == \"\") &#123; continue; &#125; else if (str == \".\") &#123; continue; &#125; else if (str == \"..\") &#123; stack.pop(); &#125; else &#123; stack.push(str); &#125; &#125; return `/$&#123;stack.join(\"/\")&#125;`;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"浏览器登录态保存方案","slug":"浏览器登录态保存方案","date":"2020-11-18T09:19:44.000Z","updated":"2021-11-06T12:54:08.428Z","comments":true,"path":"2020/11/18/浏览器登录态保存方案/","link":"","permalink":"http://yoursite.com/2020/11/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95%E6%80%81%E4%BF%9D%E5%AD%98%E6%96%B9%E6%A1%88/","excerpt":"","text":"什么是 CookieCookie 是由服务器发出，并由浏览器保存的一小块数据（大概 4kb 大小），浏览器再下一次请求同一个服务器时，会携带 cookie。通过 cookie 可以使浏览器的访问变得有状态，但是由于数据只保存在浏览器中，因此状态是单向的，服务器无法验证。什么是 sessionSession 是另一种记录服务器和浏览器会话状态的机制。Session 这种机制基于 Cookie 来实现Session 的状态数据存储在服务器端，浏览器通过 Cookie 保存了一个 SessionIdSession 认证流程用户向服务器提交用户名和密码服务器收到并验证成功后，生成一个 session（其实就是一段数据，比如包含 userId,userName 等）保存在内存或者数据库中服务器返回给用户一个 session_id，写入用户的 cookie用户后面的每一次访问，都会通过 Cookie 将 session_id 传回服务器服务器收到 session_id 找到之前保存的数据，由此得知用户身份，继而执行操作如果没有找到数据，则可以重定向至登陆页。session 的问题如果是一个服务器集群，就需要共享 session 数据如果 AB 网站需要单点登录共享登录态，也需要共享 session 数据什么是 JWT json web tokenJWT 是另一种保存状态的方案，和 Session 的区别是，JWT 只需要浏览器保存就可以了，服务器不需要在维护 session 数据。JWT 会在浏览器端保存哪些数据呢？其实还是类似 userId，userName 等数据。但是直接保存明文数据肯定是不行的，需要保存加密之后的数据。将数据加密成一个字符串。中间用.分割成 3 部分。分别为Header 头部一个对象，描述 JWT 的元数据，也就是这个 JWT 是什么格式呀，用了什么加密算法（HS256）呀。比如{ &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot; }这个对象使用 Base64URL 算法转换成字符串Payload 负载（数据）也是一个对象保存各种数据。最后也是使用 Base64URL 算法转换成字符串Signature 签名签名的作用主要是验证 Header 和 Payload，防止它们被篡改，服务器会保存 Signature 的密钥，使用密钥对 Header 和 Payload 进行 SHA256 加密。浏览器再次请求时，服务器通过密钥对 Header 和 Payload 解密，然后和 Signature 对比，验证数据是否被篡改。以及是否有效。最终组成 Header.Payload.Signature这样的一个字符串，类似于客户端收到 JWT 后，可以保存在 cookie 里面，也可以保存在 localStorage 里面。后面的请求时，可以随着 cookie 一起发送，但是会有跨域问题，所以也可以放在 Http 的 Header 里面。例如：Authorization: Bearer &lt;token&gt;JWT 的优点相比于 Session，JWT 不需要服务器在维护 session 数据了，全部的数据都放在了浏览器上。但是验证的时候需要做解密的操作，牺牲了一定的 CPU 性能。JWT 的缺点一旦签发了某个 Token，服务器无法作废它，因为服务器只会验证它，除非还有额外的逻辑来处理。由于不好作废它，那么一旦 Token 被盗用，就会一直有效，因此 token 的有效期最好不要太长。应该使用 Https，保证 token 的安全性","categories":[],"tags":[{"name":"web开发","slug":"web开发","permalink":"http://yoursite.com/tags/web%E5%BC%80%E5%8F%91/"}]},{"title":"leetcode 208 实现Trie树","slug":"leetcode-208-实现Trie树","date":"2020-11-15T11:35:35.000Z","updated":"2021-11-06T12:54:08.424Z","comments":true,"path":"2020/11/15/leetcode-208-实现Trie树/","link":"","permalink":"http://yoursite.com/2020/11/15/leetcode-208-%E5%AE%9E%E7%8E%B0Trie%E6%A0%91/","excerpt":"","text":"208 实现前缀树前缀树其实就是字典树，实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。示例示例:1234567Trie trie = new Trie();trie.insert(\"apple\");trie.search(\"apple\"); // 返回 truetrie.search(\"app\"); // 返回 falsetrie.startsWith(\"app\"); // 返回 truetrie.insert(\"app\");trie.search(\"app\"); // 返回 true问题分析这个数据结构直接看的极客时间上的课程学来的。但是使用数组来存储 children 的方式确实不错，主要字符集数量有限（26 个英文字母），如果是更大的字符集，使用 map 来存储也不错。可以用来解决路由表的最长前缀匹配问题，可以使用 trie 树来加快搜索匹配的速度。Round Onetrie 树主要支持两个操作insert - 插入的过程，就是构建这个树的过程，需要动态的创建 childrensearch - 搜索的过程，需要验证单词是否完全匹配，因此节点上需要一个 isEndOfWord 的标记starsWith - 验证是否是一个合格的前缀，简化版的 search代码实现children 是数组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class TrieNode &#123; char: string; isEndOfWord: boolean = false; children: TrieNode[] = []; constructor(char: string = \"\") &#123; this.char = char; &#125;&#125;class Trie &#123; root: TrieNode; constructor() &#123; this.root = new TrieNode(); &#125; insert(word: string) &#123; let node = this.root; for (let char of word) &#123; const index = char.charCodeAt(0) - 97; if (!node.children[index]) &#123; // 当前字符不再children中，需要创建 node.children[index] = new TrieNode(char); &#125; node = node.children[index]; &#125; node.isEndOfWord = true; &#125; search(word: string) &#123; let node = this.root; for (let char of word) &#123; const index = char.charCodeAt(0) - 97; if (!node.children[index]) &#123; return false; &#125; node = node.children[index]; &#125; return node.isEndOfWord; &#125; startsWith(word: string) &#123; let node = this.root; for (let char of word) &#123; const index = char.charCodeAt(0) - 97; if (!node.children[index]) &#123; return false; &#125; node = node.children[index]; &#125; return true; &#125;&#125;children 是 mapmap 的方法在 leetcode 上更快，应该是因为数组方法里面 charCodeAt 比较耗时吧。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class TrieNode &#123; char: string; isEndOfWord: boolean = false; children: Map&lt;string,TrieNode&gt; = new Map() constructor(char:string = '')&#123; this.char = char; &#125;&#125;class Trie &#123; root: TrieNode = new TrieNode(); insert(word: string)&#123; let node = this.root; for(let char of word)&#123; if(!node.children.has(char))&#123; node.children.set(char, new TrieNode(char)); &#125; node = node.children.get(char); &#125; node.isEndOfWord = true; &#125; search(word: string)&#123; let node = this.root; for(let char of word)&#123; if(!node.children.has(char))&#123; return false; &#125; node = node.children.get(char); &#125; retur node.isEndOfWord; &#125; startsWith(word: string)&#123; let node = this.root; for(let char of word)&#123; if(!node.children.has(char))&#123; return false; &#125; node = node.children.get(char); &#125; return true; &#125;&#125;","categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"leetcode 139 单词拆分","slug":"leetcode-139-单词拆分","date":"2020-11-15T11:34:51.000Z","updated":"2021-11-06T12:54:08.424Z","comments":true,"path":"2020/11/15/leetcode-139-单词拆分/","link":"","permalink":"http://yoursite.com/2020/11/15/leetcode-139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/","excerpt":"","text":"139 单词拆分示例 1：输入: s = “leetcode”, wordDict = [“leet”, “code”]输出: true解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。问题分析Round One遍历收集所有的 s 可以被拆分的组合遍历组合，判断是否有某个组合中的所有子串都在 dict 中这种解法看上去没有问题，关键点在于收集所有的 s 可以被拆分的组合，这里显然需要深度优先和递归。但是如何实现第 1 步，却把我卡住了。没有理清代码的关系。一直卡在了那里。这里暴露了我的一个问题，easy fall into a promble and can’t walk out.不知道是不是其他人也有会有这个问题呢？其实在问题卡住的时候，无非是两种做法。死磕，把卡住的问题解决（这样也不能算是卡住了）换一种思路，前提是能想到别的思路综合上面的两个解决方案，不难发现，本质无非是你足够聪明（可以把卡住的问题解决掉），或是你见多识广（可以换一种方式解决问题）。无论哪一种，都是能力的体现。不得不说，是否聪明比较客观，无法改变，但是思路的转化是可以通过经验的积累来实现的。Round Two在参考了 leetcode 上的 solutions 之后，获得了很大的启发。将问题分解，先找到一个，然后再对子问题求解，如果子问题也满足条件，那么这个组合就是 ok 的。一个指针遍历字符串，验证指针前半子串 s1 是否在 dict 中，不存在就移动指针。如果存在，那么说明已经分解出一个单词，然后对指针的后半子串 s2 进行同样的验证操作（递归）。直到后半子串 s2 的长度为 0（递归基），说明前面的子串都可以在 dict 中找到了。Round Three上面的解法基本解决了问题，但是存在很多重复计算。举个例子，一个字符串abcd，如过a | bcda | b | cda | b | c | da | bc | da | b | c | da | bcdab | cdab | c | dab | cd可以看出 c 和 d 的切分进行了很多次。对于重复的计算，简单的做法就是记录一下，这个子串是否已经切分过了。如果切分过了，就直接返回代码实现非优化12345678910111213141516function wordBreak(s: stirng, dict: string[]): boolean &#123; if (s.length == 0) return true; for (let i = 0; i &lt; s.length; i++) &#123; // 将s分解。[0,i]为s1，[i+1,end]为s2 const s1 = s.slice(0, i + 1); const s2 = s.slice(i + 1); // 如果s1在dict中，再去验证s2 if (dict.inclueds(s1) &amp;&amp; wordBread(s2, dict)) &#123; // 找到了一组 return true; &#125; &#125; // 没找到 return false;&#125;优化 - memo 记录12345678910111213141516171819202122232425function canBreak(str: string, dict: string[], memo: Set&lt;string&gt;) &#123; if (str.length === 0) return true; // 当前字符串已经尝试拆分过了，没有返回true，代表没有解 if (memo.has(str)) return false; for (let i = 0; i &lt; str.length; i++) &#123; const s1 = str.slice(0, i + 1); const s2 = str.slice(i + 1); if (dict.includes(s1) &amp;&amp; canBreak(s2, dict, memo)) &#123; return true; &#125; &#125; // 当前子串无法拆分 memo.add(str); return false;&#125;function wordBreak(s: string, dict: string[]) &#123; const memo = new Set&lt;string&gt;(); return canBreak(s, dict, memo);&#125;优化 - dp定义状态 dp[i]代表子串 s[0:i-1]是否可以被拆分。dp[i] = dp[j] &amp;&amp; dict.has(s.slice(j,i)) j[0,i-1]将 s[0:i-1]以 j 分为两部分，如果 dp[j]为 true，说明 s[0,j-1]可以拆分如果 s[j:i-1]在 dict 中，则说明这两部分合起来也可以拆分(s[0:j-1],s[j,i-1])最终求的就是 dp[s.length];举个例子：s=leetcode; dict=[&#39;leet&#39;,&#39;code&#39;]; 那么dp[3]=true // 因为s[0,3]=&#39;leet&#39;; 而且s[4,7]=&#39;code&#39; 存在于dict中所以可以被拆分1234567891011121314151617function wordBreak(s: string, dict: string[]): boolean &#123; const len = s.length; const dp = Array(s.length + 1).fill(false); dp[0] = true; for (let i = 1; i &lt;= len; i++) &#123; for (let j = i - 1; j &gt;= 0; j--) &#123; const suffix = s.slice(j, i); // 后缀 if (dp[j] &amp;&amp; dict.includes(suffix)) &#123; dp[i] = true; break; &#125; &#125; &#125; return dp[s.length];&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"leetcode 112 路径总和","slug":"leetcode-112-路径总和","date":"2020-11-15T11:30:23.000Z","updated":"2021-11-06T12:54:08.424Z","comments":true,"path":"2020/11/15/leetcode-112-路径总和/","link":"","permalink":"http://yoursite.com/2020/11/15/leetcode-112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/","excerpt":"","text":"112 路径总和示例给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。说明: 叶子节点是指没有子节点的节点。示例:给定如下二叉树，以及目标和 sum = 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。问题分析Round One初看之下，让我想到了二叉树的最大深度，接着自然想到了 dfs 深度优先搜索，然后使用递归来实现代码。但是这里需要使用一个变量来记录当前路径和，然后想到了使用全局变量 count（事后证明这并不是一个最佳实践），如此一来，再全局变量增加之后，还需要利用回溯来恢复 count，无疑增加了复杂度。Round Two其实对于类似的问题，之所以使用全局变量，是基于我的一个刻板印象–count 是值类型，不是引用类型，无法直接操作修改 count 的值。但是后来发现，并不需要直接修改 count 的值，只需要操作传递给下一层递归的 count 就可以了。相当于每一次的递归调用里 count 都是新的。代码实现使用 dfs 递归最初想到的方案，使用 count 来记录当前的累加值。这里需要记住几种特殊 case空树需要返回 false[1,2] 1 这个 case，虽然树根为 1，但是树根没有左子树，因此不符合题意（从根节点到叶子节点），因此也是返回 false所以，真正的叶子节点就是本身不为 null，left 和 right 都是 null。1234567891011121314function calcSum(node: TreeNode | null, sum: number, count: number): boolean &#123; if (!node) return false; count += node.val; if (!node.left &amp;&amp; !node.right) &#123; return count === sum; &#125; return calcSum(node.left, sum, count) || calcSum(node.right, sum, count);&#125;function hasPathSum(root: TreeNode | null, sum: number): boolean &#123; return calcSum(root, sum, 0);&#125;使用 dfs 递归-优化传参看了 leetcode 的留言之后，发现了更好的方式，递减 sum，这样避免了一个多余的 count 参数。这种方式代码量更少，更加简洁。123456789101112131415function hasPathSum(root: TreeNode | null, sum: number): boolean &#123; // 没有根节点，直接false if (!root) return false; // 已经是叶子节点 if (!root.left &amp;&amp; !root.right) &#123; return root.val === sum; &#125; // 探索左右子树 return ( hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val) );&#125;使用 bfs使用 bfs 来遍历二叉树，自然要使用队列了。这里需要使用一个额外的队列来存储结果数据。并且数据队列与节点队列保持同步。1234567891011121314151617181920212223242526function hasPathSum(root: TreeNode | null, sum: number): boolean &#123; if (!root) return false; const queue = [root]; // 遍历节点 const result = [root.val]; // 记录路径和 while (queue.length) &#123; const node = queue.pop(); const value = result.pop(); if (!node) continue; if (!node.left &amp;&amp; !node.right) &#123; if (sum === value) &#123; return true; &#125; &#125; if (node.left) &#123; queue.push(node.left); result.push((value as number) + node.left.val); &#125; if (node.right) &#123; queue.push(node.right); result.push((value as number) + node.right.val); &#125; &#125; return false;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"First Post","slug":"Post","date":"2020-07-28T22:34:55.000Z","updated":"2021-11-06T12:54:08.424Z","comments":true,"path":"2020/07/28/Post/","link":"","permalink":"http://yoursite.com/2020/07/28/Post/","excerpt":"","text":"这是我用 Hexo 写的第一篇 blog，之前的 Hello World 真的就是 Hello World 而已。之所以开通这个 blog，是因为在 B 站上看到了一个教学视频，感觉很有意思，总结一下这个 blog 的几个优点。不需要自己的服务器，省钱呀。构建简单，使用 MarkDown 编写。之前很多的东西记录在印象笔记里，迁移到 blog 上可以被更多人看到（虽然可能只是一些浅显的理解）这是第一篇 blog，万事开头难，不能再拖了，必须先交稿，不然怕我的拖延症犯了之后，把 blog 晾起来了。这篇就随便聊聊。最近有了一些新的感悟，和朋友同事吃饭，总爱问他们平时休息都是做啥，有没有什么有意思的活动，因为总感觉自己的生活空洞无聊，想向别人讨些经验，然而得到的回答也大都差不多。然而我突然有一刻总结出了我理解的有意思(意义)的生活。学习。锻炼大脑运动。锻炼身体体验。算是娱乐吧，寻找开心另外就是健康舒适的身体真是太重要了，如果身体感到不适，那么是没有任何心情和精力去做其他事情的，只能闷头睡大觉，期待身体早日恢复。随便写写。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]}],"categories":[],"tags":[{"name":"vscode extension","slug":"vscode-extension","permalink":"http://yoursite.com/tags/vscode-extension/"},{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"前端开发中的算法","slug":"前端开发中的算法","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95/"},{"name":"英语学习","slug":"英语学习","permalink":"http://yoursite.com/tags/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"中间件","slug":"中间件","permalink":"http://yoursite.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"express","slug":"express","permalink":"http://yoursite.com/tags/express/"},{"name":"koa","slug":"koa","permalink":"http://yoursite.com/tags/koa/"},{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"},{"name":"web开发","slug":"web开发","permalink":"http://yoursite.com/tags/web%E5%BC%80%E5%8F%91/"}]}